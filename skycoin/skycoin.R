# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -DUSE_ASSERT_EXCEPTIONS -r -Iswig/include -Igopath/src/github.com/skycoin/libskycoin/include -outdir skycoin -o skycoin_wrap.c swig/skycoin.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = SWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################



setClass('_p_cipher_PubKey', contains = 'ExternalReference')
setClass("cipher_PubKey",
    representation(
        data = "integer"),
        contains = "RSWIGStruct")


# End class cipher_PubKey

setClass('_p_cipher_PubKey', contains = 'ExternalReference')
setClass('_p_cipher_SecKey', contains = 'ExternalReference')
setClass("cipher_SecKey",
    representation(
        data = "integer"),
        contains = "RSWIGStruct")


# End class cipher_SecKey

setClass('_p_cipher_SecKey', contains = 'ExternalReference')
setClass('_p_cipher_Ripemd160', contains = 'ExternalReference')
setClass("cipher_Ripemd160",
    representation(
        data = "integer"),
        contains = "RSWIGStruct")


# End class cipher_Ripemd160

setClass('_p_cipher_Ripemd160', contains = 'ExternalReference')
setClass('_p_cipher_Sig', contains = 'ExternalReference')
setClass("cipher_Sig",
    representation(
        data = "integer"),
        contains = "RSWIGStruct")


# End class cipher_Sig

setClass('_p_cipher_Sig', contains = 'ExternalReference')
setClass('_p_cipher_SHA256', contains = 'ExternalReference')
setClass("cipher_SHA256",
    representation(
        data = "integer"),
        contains = "RSWIGStruct")


# End class cipher_SHA256

setClass('_p_cipher_SHA256', contains = 'ExternalReference')
setClass('_p_cipher_Checksum', contains = 'ExternalReference')
setClass("cipher_Checksum",
    representation(
        data = "integer"),
        contains = "RSWIGStruct")


# End class cipher_Checksum

setClass('_p_cipher_Checksum', contains = 'ExternalReference')
setClass('_p_cipher_SecKeys', contains = 'ExternalReference')
setClass("cipher_SecKeys",
    representation(
        count = "integer"),
        contains = "RSWIGStruct")


# End class cipher_SecKeys

setClass('_p_cipher_SecKeys', contains = 'ExternalReference')
setClass('_p_cipher_PubKeys', contains = 'ExternalReference')
setClass("cipher_PubKeys",
    representation(
        count = "integer"),
        contains = "RSWIGStruct")


# End class cipher_PubKeys

setClass('_p_cipher_PubKeys', contains = 'ExternalReference')
setClass('_p_cipher_SHA256s', contains = 'ExternalReference')
setClass("cipher_SHA256s",
    representation(
        count = "integer"),
        contains = "RSWIGStruct")


# End class cipher_SHA256s

setClass('_p_cipher_SHA256s', contains = 'ExternalReference')
setClass('_p_coin_UxOutArray', contains = 'ExternalReference')
setClass("coin_UxOutArray",
    representation(
        count = "integer"),
        contains = "RSWIGStruct")


# End class coin_UxOutArray

setClass('_p_coin_UxOutArray', contains = 'ExternalReference')
setClass('_p_cipher_Addresses', contains = 'ExternalReference')
setClass("cipher_Addresses",
    representation(
        count = "integer"),
        contains = "RSWIGStruct")


# End class cipher_Addresses

setClass('_p_cipher_Addresses', contains = 'ExternalReference')
setClass('_p_f_Transaction__Handle_p_unsigned_long_long_p_void__GoUint32_',
        prototype = list(parameterTypes = c('_Transaction__Handle', '_p_unsigned_long_long', '_p_void'),
                        returnType = '_p_f_Transaction__Handle_p_unsigned_long_long_p_void__GoUint32_'),
        contains = 'CRoutinePointer')

##
setClass('_p_Fee_Calculator', contains = 'ExternalReference')
setClass("Fee_Calculator",
    representation(
),
        contains = "RSWIGStruct")


# End class Fee_Calculator

setClass('_p_Fee_Calculator', contains = 'ExternalReference')
setClass('_p__GoString_', contains = 'ExternalReference')
setClass("_GoString_",
    representation(
        p = "character",
        n = "integer"),
        contains = "RSWIGStruct")


# End class _GoString_

setClass('_p__GoString_', contains = 'ExternalReference')
setClass('_p_GoInterface', contains = 'ExternalReference')
setClass("GoInterface",
    representation(
),
        contains = "RSWIGStruct")


# End class GoInterface

setClass('_p_GoInterface', contains = 'ExternalReference')
setClass('_p_GoSlice', contains = 'ExternalReference')
setClass("GoSlice",
    representation(
        len = "integer",
        cap = "integer"),
        contains = "RSWIGStruct")


# End class GoSlice

setClass('_p_GoSlice', contains = 'ExternalReference')
setClass('_p_api__RichlistParams', contains = 'ExternalReference')
setClass("api__RichlistParams",
    representation(
        N = "integer",
        IncludeDistribution = "integer"),
        contains = "RSWIGStruct")


# End class api__RichlistParams

setClass('_p_api__RichlistParams', contains = 'ExternalReference')
setClass('_p_api__NetworkConnectionsFilter', contains = 'ExternalReference')
setClass("api__NetworkConnectionsFilter",
    representation(
),
        contains = "RSWIGStruct")


# End class api__NetworkConnectionsFilter

setClass('_p_api__NetworkConnectionsFilter', contains = 'ExternalReference')
setClass('_p_cipher__Address', contains = 'ExternalReference')
setClass("cipher__Address",
    representation(
        Version = "integer"),
        contains = "RSWIGStruct")


# End class cipher__Address

setClass('_p_cipher__Address', contains = 'ExternalReference')
setClass('_p_cipher__BitcoinAddress', contains = 'ExternalReference')
setClass("cipher__BitcoinAddress",
    representation(
        Version = "integer"),
        contains = "RSWIGStruct")


# End class cipher__BitcoinAddress

setClass('_p_cipher__BitcoinAddress', contains = 'ExternalReference')
setClass('_p_encrypt__ScryptChacha20poly1305', contains = 'ExternalReference')
setClass("encrypt__ScryptChacha20poly1305",
    representation(
        N = "integer",
        R = "integer",
        P = "integer",
        KeyLen = "integer"),
        contains = "RSWIGStruct")


# End class encrypt__ScryptChacha20poly1305

setClass('_p_encrypt__ScryptChacha20poly1305', contains = 'ExternalReference')
setClass('_p_secp256k1go__Field', contains = 'ExternalReference')
setClass("secp256k1go__Field",
    representation(
        n = "integer"),
        contains = "RSWIGStruct")


# End class secp256k1go__Field

setClass('_p_secp256k1go__Field', contains = 'ExternalReference')
setClass('_p_secp256k1go__XY', contains = 'ExternalReference')
setClass("secp256k1go__XY",
    representation(
        Infinity = "integer"),
        contains = "RSWIGStruct")


# End class secp256k1go__XY

setClass('_p_secp256k1go__XY', contains = 'ExternalReference')
setClass('_p_secp256k1go__XYZ', contains = 'ExternalReference')
setClass("secp256k1go__XYZ",
    representation(
        Infinity = "integer"),
        contains = "RSWIGStruct")


# End class secp256k1go__XYZ

setClass('_p_secp256k1go__XYZ', contains = 'ExternalReference')
setClass('_p_cli__SendAmount', contains = 'ExternalReference')
setClass("cli__SendAmount",
    representation(
        Coins = "integer"),
        contains = "RSWIGStruct")


# End class cli__SendAmount

setClass('_p_cli__SendAmount', contains = 'ExternalReference')
setClass('_p_coin__Transaction', contains = 'ExternalReference')
setClass("coin__Transaction",
    representation(
        Length = "integer",
        Type = "integer"),
        contains = "RSWIGStruct")


# End class coin__Transaction

setClass('_p_coin__Transaction', contains = 'ExternalReference')
setClass('_p_coin__TransactionOutput', contains = 'ExternalReference')
setClass("coin__TransactionOutput",
    representation(
        Coins = "integer",
        Hours = "integer"),
        contains = "RSWIGStruct")


# End class coin__TransactionOutput

setClass('_p_coin__TransactionOutput', contains = 'ExternalReference')
setClass('_p_coin__BlockHeader', contains = 'ExternalReference')
setClass("coin__BlockHeader",
    representation(
        Version = "integer",
        Time = "integer",
        BkSeq = "integer",
        Fee = "integer"),
        contains = "RSWIGStruct")


# End class coin__BlockHeader

setClass('_p_coin__BlockHeader', contains = 'ExternalReference')
setClass('_p_coin__BlockBody', contains = 'ExternalReference')
setClass("coin__BlockBody",
    representation(
),
        contains = "RSWIGStruct")


# End class coin__BlockBody

setClass('_p_coin__BlockBody', contains = 'ExternalReference')
setClass('_p_coin__Block', contains = 'ExternalReference')
setClass("coin__Block",
    representation(
),
        contains = "RSWIGStruct")


# End class coin__Block

setClass('_p_coin__Block', contains = 'ExternalReference')
setClass('_p_coin__SignedBlock', contains = 'ExternalReference')
setClass("coin__SignedBlock",
    representation(
),
        contains = "RSWIGStruct")


# End class coin__SignedBlock

setClass('_p_coin__SignedBlock', contains = 'ExternalReference')
setClass('_p_coin__UxHead', contains = 'ExternalReference')
setClass("coin__UxHead",
    representation(
        Time = "integer",
        BkSeq = "integer"),
        contains = "RSWIGStruct")


# End class coin__UxHead

setClass('_p_coin__UxHead', contains = 'ExternalReference')
setClass('_p_coin__UxBody', contains = 'ExternalReference')
setClass("coin__UxBody",
    representation(
        Coins = "integer",
        Hours = "integer"),
        contains = "RSWIGStruct")


# End class coin__UxBody

setClass('_p_coin__UxBody', contains = 'ExternalReference')
setClass('_p_coin__UxOut', contains = 'ExternalReference')
setClass("coin__UxOut",
    representation(
),
        contains = "RSWIGStruct")


# End class coin__UxOut

setClass('_p_coin__UxOut', contains = 'ExternalReference')
setClass('_p_httphelper__Address', contains = 'ExternalReference')
setClass("httphelper__Address",
    representation(
),
        contains = "RSWIGStruct")


# End class httphelper__Address

setClass('_p_httphelper__Address', contains = 'ExternalReference')
setClass('_p_httphelper__SHA256', contains = 'ExternalReference')
setClass("httphelper__SHA256",
    representation(
),
        contains = "RSWIGStruct")


# End class httphelper__SHA256

setClass('_p_httphelper__SHA256', contains = 'ExternalReference')
setClass('_p_wallet__Balance', contains = 'ExternalReference')
setClass("wallet__Balance",
    representation(
        Coins = "integer",
        Hours = "integer"),
        contains = "RSWIGStruct")


# End class wallet__Balance

setClass('_p_wallet__Balance', contains = 'ExternalReference')
setClass('_p_wallet__BalancePair', contains = 'ExternalReference')
setClass("wallet__BalancePair",
    representation(
),
        contains = "RSWIGStruct")


# End class wallet__BalancePair

setClass('_p_wallet__BalancePair', contains = 'ExternalReference')
setClass('_p_wallet__Entry', contains = 'ExternalReference')
setClass("wallet__Entry",
    representation(
),
        contains = "RSWIGStruct")


# End class wallet__Entry

setClass('_p_wallet__Entry', contains = 'ExternalReference')
setClass('_p_wallet__Note', contains = 'ExternalReference')
setClass("wallet__Note",
    representation(
),
        contains = "RSWIGStruct")


# End class wallet__Note

setClass('_p_wallet__Note', contains = 'ExternalReference')
setClass('_p_wallet__ReadableNote', contains = 'ExternalReference')
setClass("wallet__ReadableNote",
    representation(
),
        contains = "RSWIGStruct")


# End class wallet__ReadableNote

setClass('_p_wallet__ReadableNote', contains = 'ExternalReference')
setClass('_p_wallet__UxBalance', contains = 'ExternalReference')
setClass("wallet__UxBalance",
    representation(
        BkSeq = "integer",
        Coins = "integer",
        Hours = "integer"),
        contains = "RSWIGStruct")


# End class wallet__UxBalance

setClass('_p_wallet__UxBalance', contains = 'ExternalReference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

suppressMessages(suppressWarnings(setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})))

# Start of equalSlices

`equalSlices` = function(slice1, slice2, elem_size, .copy = FALSE)
{
  if (inherits(slice1, "ExternalReference")) slice1 = slot(slice1,"ref") 
  if (inherits(slice2, "ExternalReference")) slice2 = slot(slice2,"ref") 
  elem_size = as.integer(elem_size);
  
  if(length(elem_size) > 1) {
    warning("using only the first element of elem_size");
  };
  
  ;.Call('R_swig_equalSlices', slice1, slice2, elem_size, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`equalSlices`, 'returnType') = 'integer'
attr(`equalSlices`, "inputTypes") = c('_p_GoSlice', '_p_GoSlice', 'integer')
class(`equalSlices`) = c("SWIGFunction", class('equalSlices'))

# Start of equalTransactions

`equalTransactions` = function(t1, t2, .copy = FALSE)
{
  if (inherits(t1, "ExternalReference")) t1 = slot(t1,"ref") 
  if (inherits(t2, "ExternalReference")) t2 = slot(t2,"ref") 
  ;.Call('R_swig_equalTransactions', t1, t2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`equalTransactions`, 'returnType') = 'integer'
attr(`equalTransactions`, "inputTypes") = c('_p_coin__Transaction', '_p_coin__Transaction')
class(`equalTransactions`) = c("SWIGFunction", class('equalTransactions'))

# Start of equalTransactionsArrays

`equalTransactionsArrays` = function(pTxs1, pTxs2, .copy = FALSE)
{
  if (inherits(pTxs1, "ExternalReference")) pTxs1 = slot(pTxs1,"ref") 
  if (inherits(pTxs2, "ExternalReference")) pTxs2 = slot(pTxs2,"ref") 
  ;.Call('R_swig_equalTransactionsArrays', pTxs1, pTxs2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`equalTransactionsArrays`, 'returnType') = 'integer'
attr(`equalTransactionsArrays`, "inputTypes") = c('_p_GoSlice_', '_p_GoSlice_')
class(`equalTransactionsArrays`) = c("SWIGFunction", class('equalTransactionsArrays'))

# Start of equalBlockHeaders

`equalBlockHeaders` = function(bh1, bh2, .copy = FALSE)
{
  if (inherits(bh1, "ExternalReference")) bh1 = slot(bh1,"ref") 
  if (inherits(bh2, "ExternalReference")) bh2 = slot(bh2,"ref") 
  ;.Call('R_swig_equalBlockHeaders', bh1, bh2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`equalBlockHeaders`, 'returnType') = 'integer'
attr(`equalBlockHeaders`, "inputTypes") = c('_p_coin__BlockHeader', '_p_coin__BlockHeader')
class(`equalBlockHeaders`) = c("SWIGFunction", class('equalBlockHeaders'))

# Start of destroy_cipher_SecKeys

`destroy_cipher_SecKeys` = function(p)
{
  if (inherits(p, "ExternalReference")) p = slot(p,"ref") 
  ;.Call('R_swig_destroy_cipher_SecKeys', p, PACKAGE='skycoin');
  
}

attr(`destroy_cipher_SecKeys`, 'returnType') = 'void'
attr(`destroy_cipher_SecKeys`, "inputTypes") = c('_p_cipher_SecKeys')
class(`destroy_cipher_SecKeys`) = c("SWIGFunction", class('destroy_cipher_SecKeys'))

# Start of cipher_PubKey_isEqual

`cipher_PubKey_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_PubKey_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_PubKey_isEqual`, 'returnType') = 'integer'
attr(`cipher_PubKey_isEqual`, "inputTypes") = c('_p_cipher_PubKey', '_p_cipher_PubKey')
class(`cipher_PubKey_isEqual`) = c("SWIGFunction", class('cipher_PubKey_isEqual'))

# Start of cipher_PubKey_assignFrom

`cipher_PubKey_assignFrom` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_PubKey_assignFrom', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_PubKey_assignFrom`, 'returnType') = 'void'
attr(`cipher_PubKey_assignFrom`, "inputTypes") = c('_p_cipher_PubKey', '_p_cipher_PubKey')
class(`cipher_PubKey_assignFrom`) = c("SWIGFunction", class('cipher_PubKey_assignFrom'))

# Start of cipher_PubKey_assignTo

`cipher_PubKey_assignTo` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_PubKey_assignTo', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_PubKey_assignTo`, 'returnType') = 'void'
attr(`cipher_PubKey_assignTo`, "inputTypes") = c('_p_cipher_PubKey', '_p_cipher_PubKey')
class(`cipher_PubKey_assignTo`) = c("SWIGFunction", class('cipher_PubKey_assignTo'))

# Start of cipher_PubKey_assignSlice

`cipher_PubKey_assignSlice` = function(self, slice)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(slice, "ExternalReference")) slice = slot(slice,"ref") 
  ;.Call('R_swig_cipher_PubKey_assignSlice', self, slice, PACKAGE='skycoin');
  
}

attr(`cipher_PubKey_assignSlice`, 'returnType') = 'void'
attr(`cipher_PubKey_assignSlice`, "inputTypes") = c('_p_cipher_PubKey', '_p_GoSlice')
class(`cipher_PubKey_assignSlice`) = c("SWIGFunction", class('cipher_PubKey_assignSlice'))

# Start of cipher_PubKey_toSlice

`cipher_PubKey_toSlice` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_PubKey_toSlice', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoSlice", ref=ans);
  
  ans
  
}

attr(`cipher_PubKey_toSlice`, 'returnType') = '_p_GoSlice'
attr(`cipher_PubKey_toSlice`, "inputTypes") = c('_p_cipher_PubKey')
class(`cipher_PubKey_toSlice`) = c("SWIGFunction", class('cipher_PubKey_toSlice'))

# Start of cipher_PubKey_data_set

`cipher_PubKey_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  
#  assert(length(s_data) >= 33)
  
  ;.Call('R_swig_cipher_PubKey_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_PubKey_data_set`, 'returnType') = 'void'
attr(`cipher_PubKey_data_set`, "inputTypes") = c('_p_cipher_PubKey', 'integer')
class(`cipher_PubKey_data_set`) = c("SWIGFunction", class('cipher_PubKey_data_set'))

# Start of cipher_PubKey_data_get

`cipher_PubKey_data_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_PubKey_data_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_unsigned_char", ref=ans) ;
  
  ans
  
}

attr(`cipher_PubKey_data_get`, 'returnType') = 'integer'
attr(`cipher_PubKey_data_get`, "inputTypes") = c('_p_cipher_PubKey')
class(`cipher_PubKey_data_get`) = c("SWIGFunction", class('cipher_PubKey_data_get'))

# Start of new_cipher_PubKey

`cipher_PubKey` = function()
{
  ;ans = .Call('R_swig_new_cipher_PubKey', PACKAGE='skycoin');
  ans <- new("_p_cipher_PubKey", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_PubKey)
  ans
  
}

attr(`cipher_PubKey`, 'returnType') = '_p_cipher_PubKey'
class(`cipher_PubKey`) = c("SWIGFunction", class('cipher_PubKey'))

# Start of delete_cipher_PubKey

`delete_cipher_PubKey` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_PubKey', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_PubKey`, 'returnType') = 'void'
attr(`delete_cipher_PubKey`, "inputTypes") = c('_p_cipher_PubKey')
class(`delete_cipher_PubKey`) = c("SWIGFunction", class('delete_cipher_PubKey'))

# Start of accessor method for cipher_PubKey
setMethod('$', '_p_cipher_PubKey', function(x, name)

{
  accessorFuns = list('isEqual' = cipher_PubKey_isEqual, 'assignFrom' = cipher_PubKey_assignFrom, 'assignTo' = cipher_PubKey_assignTo, 'assignSlice' = cipher_PubKey_assignSlice, 'toSlice' = cipher_PubKey_toSlice, 'data' = cipher_PubKey_data_get);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_PubKey
# Start of accessor method for cipher_PubKey
setMethod('$<-', '_p_cipher_PubKey', function(x, name, value)

{
  accessorFuns = list('data' = cipher_PubKey_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_PubKey', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_PubKey_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_PubKey
setMethod('delete', '_p_cipher_PubKey', function(obj) {delete_cipher_PubKey(obj)})
# Start definition of copy functions & methods for cipher_PubKey
CopyToR_cipher_PubKey = function(value, obj = new("cipher_PubKey"))
{
  obj@data = value$data;
  obj;
}



CopyToC_cipher_PubKey = function(value, obj)
{
  obj$data = value@data;
  obj
}



# Start definition of copy methods for cipher_PubKey
setMethod('copyToR', '_p_cipher_PubKey', CopyToR_cipher_PubKey);
setMethod('copyToC', 'cipher_PubKey', CopyToC_cipher_PubKey);

# End definition of copy methods for cipher_PubKey
# End definition of copy functions & methods for cipher_PubKey
# Start of cipher_SecKey_isEqual

`cipher_SecKey_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_SecKey_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SecKey_isEqual`, 'returnType') = 'integer'
attr(`cipher_SecKey_isEqual`, "inputTypes") = c('_p_cipher_SecKey', '_p_cipher_SecKey')
class(`cipher_SecKey_isEqual`) = c("SWIGFunction", class('cipher_SecKey_isEqual'))

# Start of cipher_SecKey_assignFrom

`cipher_SecKey_assignFrom` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_SecKey_assignFrom', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_SecKey_assignFrom`, 'returnType') = 'void'
attr(`cipher_SecKey_assignFrom`, "inputTypes") = c('_p_cipher_SecKey', '_p_void')
class(`cipher_SecKey_assignFrom`) = c("SWIGFunction", class('cipher_SecKey_assignFrom'))

# Start of cipher_SecKey_assignTo

`cipher_SecKey_assignTo` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_SecKey_assignTo', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_SecKey_assignTo`, 'returnType') = 'void'
attr(`cipher_SecKey_assignTo`, "inputTypes") = c('_p_cipher_SecKey', '_p_void')
class(`cipher_SecKey_assignTo`) = c("SWIGFunction", class('cipher_SecKey_assignTo'))

# Start of cipher_SecKey_data_set

`cipher_SecKey_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  
#  assert(length(s_data) >= 32)
  
  ;.Call('R_swig_cipher_SecKey_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_SecKey_data_set`, 'returnType') = 'void'
attr(`cipher_SecKey_data_set`, "inputTypes") = c('_p_cipher_SecKey', 'integer')
class(`cipher_SecKey_data_set`) = c("SWIGFunction", class('cipher_SecKey_data_set'))

# Start of cipher_SecKey_data_get

`cipher_SecKey_data_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_SecKey_data_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_unsigned_char", ref=ans) ;
  
  ans
  
}

attr(`cipher_SecKey_data_get`, 'returnType') = 'integer'
attr(`cipher_SecKey_data_get`, "inputTypes") = c('_p_cipher_SecKey')
class(`cipher_SecKey_data_get`) = c("SWIGFunction", class('cipher_SecKey_data_get'))

# Start of new_cipher_SecKey

`cipher_SecKey` = function()
{
  ;ans = .Call('R_swig_new_cipher_SecKey', PACKAGE='skycoin');
  ans <- new("_p_cipher_SecKey", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_SecKey)
  ans
  
}

attr(`cipher_SecKey`, 'returnType') = '_p_cipher_SecKey'
class(`cipher_SecKey`) = c("SWIGFunction", class('cipher_SecKey'))

# Start of delete_cipher_SecKey

`delete_cipher_SecKey` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_SecKey', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_SecKey`, 'returnType') = 'void'
attr(`delete_cipher_SecKey`, "inputTypes") = c('_p_cipher_SecKey')
class(`delete_cipher_SecKey`) = c("SWIGFunction", class('delete_cipher_SecKey'))

# Start of accessor method for cipher_SecKey
setMethod('$', '_p_cipher_SecKey', function(x, name)

{
  accessorFuns = list('isEqual' = cipher_SecKey_isEqual, 'assignFrom' = cipher_SecKey_assignFrom, 'assignTo' = cipher_SecKey_assignTo, 'data' = cipher_SecKey_data_get);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_SecKey
# Start of accessor method for cipher_SecKey
setMethod('$<-', '_p_cipher_SecKey', function(x, name, value)

{
  accessorFuns = list('data' = cipher_SecKey_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_SecKey', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_SecKey_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_SecKey
setMethod('delete', '_p_cipher_SecKey', function(obj) {delete_cipher_SecKey(obj)})
# Start definition of copy functions & methods for cipher_SecKey
CopyToR_cipher_SecKey = function(value, obj = new("cipher_SecKey"))
{
  obj@data = value$data;
  obj;
}



CopyToC_cipher_SecKey = function(value, obj)
{
  obj$data = value@data;
  obj
}



# Start definition of copy methods for cipher_SecKey
setMethod('copyToR', '_p_cipher_SecKey', CopyToR_cipher_SecKey);
setMethod('copyToC', 'cipher_SecKey', CopyToC_cipher_SecKey);

# End definition of copy methods for cipher_SecKey
# End definition of copy functions & methods for cipher_SecKey
# Start of cipher_Ripemd160_isEqual

`cipher_Ripemd160_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_Ripemd160_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_Ripemd160_isEqual`, 'returnType') = 'integer'
attr(`cipher_Ripemd160_isEqual`, "inputTypes") = c('_p_cipher_Ripemd160', '_p_cipher_Ripemd160')
class(`cipher_Ripemd160_isEqual`) = c("SWIGFunction", class('cipher_Ripemd160_isEqual'))

# Start of cipher_Ripemd160_assignFrom

`cipher_Ripemd160_assignFrom` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_Ripemd160_assignFrom', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_Ripemd160_assignFrom`, 'returnType') = 'void'
attr(`cipher_Ripemd160_assignFrom`, "inputTypes") = c('_p_cipher_Ripemd160', '_p_void')
class(`cipher_Ripemd160_assignFrom`) = c("SWIGFunction", class('cipher_Ripemd160_assignFrom'))

# Start of cipher_Ripemd160_assignTo

`cipher_Ripemd160_assignTo` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_Ripemd160_assignTo', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_Ripemd160_assignTo`, 'returnType') = 'void'
attr(`cipher_Ripemd160_assignTo`, "inputTypes") = c('_p_cipher_Ripemd160', '_p_void')
class(`cipher_Ripemd160_assignTo`) = c("SWIGFunction", class('cipher_Ripemd160_assignTo'))

# Start of cipher_Ripemd160_data_set

`cipher_Ripemd160_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  
#  assert(length(s_data) >= 20)
  
  ;.Call('R_swig_cipher_Ripemd160_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_Ripemd160_data_set`, 'returnType') = 'void'
attr(`cipher_Ripemd160_data_set`, "inputTypes") = c('_p_cipher_Ripemd160', 'integer')
class(`cipher_Ripemd160_data_set`) = c("SWIGFunction", class('cipher_Ripemd160_data_set'))

# Start of cipher_Ripemd160_data_get

`cipher_Ripemd160_data_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_Ripemd160_data_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_unsigned_char", ref=ans) ;
  
  ans
  
}

attr(`cipher_Ripemd160_data_get`, 'returnType') = 'integer'
attr(`cipher_Ripemd160_data_get`, "inputTypes") = c('_p_cipher_Ripemd160')
class(`cipher_Ripemd160_data_get`) = c("SWIGFunction", class('cipher_Ripemd160_data_get'))

# Start of new_cipher_Ripemd160

`cipher_Ripemd160` = function()
{
  ;ans = .Call('R_swig_new_cipher_Ripemd160', PACKAGE='skycoin');
  ans <- new("_p_cipher_Ripemd160", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_Ripemd160)
  ans
  
}

attr(`cipher_Ripemd160`, 'returnType') = '_p_cipher_Ripemd160'
class(`cipher_Ripemd160`) = c("SWIGFunction", class('cipher_Ripemd160'))

# Start of delete_cipher_Ripemd160

`delete_cipher_Ripemd160` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_Ripemd160', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_Ripemd160`, 'returnType') = 'void'
attr(`delete_cipher_Ripemd160`, "inputTypes") = c('_p_cipher_Ripemd160')
class(`delete_cipher_Ripemd160`) = c("SWIGFunction", class('delete_cipher_Ripemd160'))

# Start of accessor method for cipher_Ripemd160
setMethod('$', '_p_cipher_Ripemd160', function(x, name)

{
  accessorFuns = list('isEqual' = cipher_Ripemd160_isEqual, 'assignFrom' = cipher_Ripemd160_assignFrom, 'assignTo' = cipher_Ripemd160_assignTo, 'data' = cipher_Ripemd160_data_get);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_Ripemd160
# Start of accessor method for cipher_Ripemd160
setMethod('$<-', '_p_cipher_Ripemd160', function(x, name, value)

{
  accessorFuns = list('data' = cipher_Ripemd160_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_Ripemd160', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_Ripemd160_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_Ripemd160
setMethod('delete', '_p_cipher_Ripemd160', function(obj) {delete_cipher_Ripemd160(obj)})
# Start definition of copy functions & methods for cipher_Ripemd160
CopyToR_cipher_Ripemd160 = function(value, obj = new("cipher_Ripemd160"))
{
  obj@data = value$data;
  obj;
}



CopyToC_cipher_Ripemd160 = function(value, obj)
{
  obj$data = value@data;
  obj
}



# Start definition of copy methods for cipher_Ripemd160
setMethod('copyToR', '_p_cipher_Ripemd160', CopyToR_cipher_Ripemd160);
setMethod('copyToC', 'cipher_Ripemd160', CopyToC_cipher_Ripemd160);

# End definition of copy methods for cipher_Ripemd160
# End definition of copy functions & methods for cipher_Ripemd160
# Start of cipher_Sig_isEqual

`cipher_Sig_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_Sig_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_Sig_isEqual`, 'returnType') = 'integer'
attr(`cipher_Sig_isEqual`, "inputTypes") = c('_p_cipher_Sig', '_p_cipher_Sig')
class(`cipher_Sig_isEqual`) = c("SWIGFunction", class('cipher_Sig_isEqual'))

# Start of cipher_Sig_assignFrom

`cipher_Sig_assignFrom` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_Sig_assignFrom', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_Sig_assignFrom`, 'returnType') = 'void'
attr(`cipher_Sig_assignFrom`, "inputTypes") = c('_p_cipher_Sig', '_p_void')
class(`cipher_Sig_assignFrom`) = c("SWIGFunction", class('cipher_Sig_assignFrom'))

# Start of cipher_Sig_assignTo

`cipher_Sig_assignTo` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_Sig_assignTo', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_Sig_assignTo`, 'returnType') = 'void'
attr(`cipher_Sig_assignTo`, "inputTypes") = c('_p_cipher_Sig', '_p_void')
class(`cipher_Sig_assignTo`) = c("SWIGFunction", class('cipher_Sig_assignTo'))

# Start of cipher_Sig_data_set

`cipher_Sig_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  
#  assert(length(s_data) >= 65)
  
  ;.Call('R_swig_cipher_Sig_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_Sig_data_set`, 'returnType') = 'void'
attr(`cipher_Sig_data_set`, "inputTypes") = c('_p_cipher_Sig', 'integer')
class(`cipher_Sig_data_set`) = c("SWIGFunction", class('cipher_Sig_data_set'))

# Start of cipher_Sig_data_get

`cipher_Sig_data_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_Sig_data_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_unsigned_char", ref=ans) ;
  
  ans
  
}

attr(`cipher_Sig_data_get`, 'returnType') = 'integer'
attr(`cipher_Sig_data_get`, "inputTypes") = c('_p_cipher_Sig')
class(`cipher_Sig_data_get`) = c("SWIGFunction", class('cipher_Sig_data_get'))

# Start of new_cipher_Sig

`cipher_Sig` = function()
{
  ;ans = .Call('R_swig_new_cipher_Sig', PACKAGE='skycoin');
  ans <- new("_p_cipher_Sig", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_Sig)
  ans
  
}

attr(`cipher_Sig`, 'returnType') = '_p_cipher_Sig'
class(`cipher_Sig`) = c("SWIGFunction", class('cipher_Sig'))

# Start of delete_cipher_Sig

`delete_cipher_Sig` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_Sig', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_Sig`, 'returnType') = 'void'
attr(`delete_cipher_Sig`, "inputTypes") = c('_p_cipher_Sig')
class(`delete_cipher_Sig`) = c("SWIGFunction", class('delete_cipher_Sig'))

# Start of accessor method for cipher_Sig
setMethod('$', '_p_cipher_Sig', function(x, name)

{
  accessorFuns = list('isEqual' = cipher_Sig_isEqual, 'assignFrom' = cipher_Sig_assignFrom, 'assignTo' = cipher_Sig_assignTo, 'data' = cipher_Sig_data_get);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_Sig
# Start of accessor method for cipher_Sig
setMethod('$<-', '_p_cipher_Sig', function(x, name, value)

{
  accessorFuns = list('data' = cipher_Sig_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_Sig', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_Sig_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_Sig
setMethod('delete', '_p_cipher_Sig', function(obj) {delete_cipher_Sig(obj)})
# Start definition of copy functions & methods for cipher_Sig
CopyToR_cipher_Sig = function(value, obj = new("cipher_Sig"))
{
  obj@data = value$data;
  obj;
}



CopyToC_cipher_Sig = function(value, obj)
{
  obj$data = value@data;
  obj
}



# Start definition of copy methods for cipher_Sig
setMethod('copyToR', '_p_cipher_Sig', CopyToR_cipher_Sig);
setMethod('copyToC', 'cipher_Sig', CopyToC_cipher_Sig);

# End definition of copy methods for cipher_Sig
# End definition of copy functions & methods for cipher_Sig
# Start of cipher_SHA256_isEqual

`cipher_SHA256_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_SHA256_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SHA256_isEqual`, 'returnType') = 'integer'
attr(`cipher_SHA256_isEqual`, "inputTypes") = c('_p_cipher_SHA256', '_p_cipher_SHA256')
class(`cipher_SHA256_isEqual`) = c("SWIGFunction", class('cipher_SHA256_isEqual'))

# Start of cipher_SHA256_assignFrom

`cipher_SHA256_assignFrom` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_SHA256_assignFrom', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_SHA256_assignFrom`, 'returnType') = 'void'
attr(`cipher_SHA256_assignFrom`, "inputTypes") = c('_p_cipher_SHA256', '_p_cipher_SHA256')
class(`cipher_SHA256_assignFrom`) = c("SWIGFunction", class('cipher_SHA256_assignFrom'))

# Start of cipher_SHA256_assignTo

`cipher_SHA256_assignTo` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_SHA256_assignTo', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_SHA256_assignTo`, 'returnType') = 'void'
attr(`cipher_SHA256_assignTo`, "inputTypes") = c('_p_cipher_SHA256', '_p_cipher_SHA256')
class(`cipher_SHA256_assignTo`) = c("SWIGFunction", class('cipher_SHA256_assignTo'))

# Start of cipher_SHA256_data_set

`cipher_SHA256_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  
#  assert(length(s_data) >= 32)
  
  ;.Call('R_swig_cipher_SHA256_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_SHA256_data_set`, 'returnType') = 'void'
attr(`cipher_SHA256_data_set`, "inputTypes") = c('_p_cipher_SHA256', 'integer')
class(`cipher_SHA256_data_set`) = c("SWIGFunction", class('cipher_SHA256_data_set'))

# Start of cipher_SHA256_data_get

`cipher_SHA256_data_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_SHA256_data_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_unsigned_char", ref=ans) ;
  
  ans
  
}

attr(`cipher_SHA256_data_get`, 'returnType') = 'integer'
attr(`cipher_SHA256_data_get`, "inputTypes") = c('_p_cipher_SHA256')
class(`cipher_SHA256_data_get`) = c("SWIGFunction", class('cipher_SHA256_data_get'))

# Start of new_cipher_SHA256

`cipher_SHA256` = function()
{
  ;ans = .Call('R_swig_new_cipher_SHA256', PACKAGE='skycoin');
  ans <- new("_p_cipher_SHA256", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_SHA256)
  ans
  
}

attr(`cipher_SHA256`, 'returnType') = '_p_cipher_SHA256'
class(`cipher_SHA256`) = c("SWIGFunction", class('cipher_SHA256'))

# Start of delete_cipher_SHA256

`delete_cipher_SHA256` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_SHA256', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_SHA256`, 'returnType') = 'void'
attr(`delete_cipher_SHA256`, "inputTypes") = c('_p_cipher_SHA256')
class(`delete_cipher_SHA256`) = c("SWIGFunction", class('delete_cipher_SHA256'))

# Start of accessor method for cipher_SHA256
setMethod('$', '_p_cipher_SHA256', function(x, name)

{
  accessorFuns = list('isEqual' = cipher_SHA256_isEqual, 'assignFrom' = cipher_SHA256_assignFrom, 'assignTo' = cipher_SHA256_assignTo, 'data' = cipher_SHA256_data_get);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_SHA256
# Start of accessor method for cipher_SHA256
setMethod('$<-', '_p_cipher_SHA256', function(x, name, value)

{
  accessorFuns = list('data' = cipher_SHA256_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_SHA256', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_SHA256_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_SHA256
setMethod('delete', '_p_cipher_SHA256', function(obj) {delete_cipher_SHA256(obj)})
# Start definition of copy functions & methods for cipher_SHA256
CopyToR_cipher_SHA256 = function(value, obj = new("cipher_SHA256"))
{
  obj@data = value$data;
  obj;
}



CopyToC_cipher_SHA256 = function(value, obj)
{
  obj$data = value@data;
  obj
}



# Start definition of copy methods for cipher_SHA256
setMethod('copyToR', '_p_cipher_SHA256', CopyToR_cipher_SHA256);
setMethod('copyToC', 'cipher_SHA256', CopyToC_cipher_SHA256);

# End definition of copy methods for cipher_SHA256
# End definition of copy functions & methods for cipher_SHA256
# Start of cipher_Checksum_isEqual

`cipher_Checksum_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_Checksum_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_Checksum_isEqual`, 'returnType') = 'integer'
attr(`cipher_Checksum_isEqual`, "inputTypes") = c('_p_cipher_Checksum', '_p_cipher_Checksum')
class(`cipher_Checksum_isEqual`) = c("SWIGFunction", class('cipher_Checksum_isEqual'))

# Start of cipher_Checksum_assignFrom

`cipher_Checksum_assignFrom` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_Checksum_assignFrom', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_Checksum_assignFrom`, 'returnType') = 'void'
attr(`cipher_Checksum_assignFrom`, "inputTypes") = c('_p_cipher_Checksum', '_p_void')
class(`cipher_Checksum_assignFrom`) = c("SWIGFunction", class('cipher_Checksum_assignFrom'))

# Start of cipher_Checksum_assignTo

`cipher_Checksum_assignTo` = function(self, data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(data, "ExternalReference")) data = slot(data,"ref") 
  ;.Call('R_swig_cipher_Checksum_assignTo', self, data, PACKAGE='skycoin');
  
}

attr(`cipher_Checksum_assignTo`, 'returnType') = 'void'
attr(`cipher_Checksum_assignTo`, "inputTypes") = c('_p_cipher_Checksum', '_p_void')
class(`cipher_Checksum_assignTo`) = c("SWIGFunction", class('cipher_Checksum_assignTo'))

# Start of cipher_Checksum_data_set

`cipher_Checksum_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_data = as.integer(s_data);
  
#  assert(length(s_data) >= 4)
  
  ;.Call('R_swig_cipher_Checksum_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_Checksum_data_set`, 'returnType') = 'void'
attr(`cipher_Checksum_data_set`, "inputTypes") = c('_p_cipher_Checksum', 'integer')
class(`cipher_Checksum_data_set`) = c("SWIGFunction", class('cipher_Checksum_data_set'))

# Start of cipher_Checksum_data_get

`cipher_Checksum_data_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_Checksum_data_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_unsigned_char", ref=ans) ;
  
  ans
  
}

attr(`cipher_Checksum_data_get`, 'returnType') = 'integer'
attr(`cipher_Checksum_data_get`, "inputTypes") = c('_p_cipher_Checksum')
class(`cipher_Checksum_data_get`) = c("SWIGFunction", class('cipher_Checksum_data_get'))

# Start of new_cipher_Checksum

`cipher_Checksum` = function()
{
  ;ans = .Call('R_swig_new_cipher_Checksum', PACKAGE='skycoin');
  ans <- new("_p_cipher_Checksum", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_Checksum)
  ans
  
}

attr(`cipher_Checksum`, 'returnType') = '_p_cipher_Checksum'
class(`cipher_Checksum`) = c("SWIGFunction", class('cipher_Checksum'))

# Start of delete_cipher_Checksum

`delete_cipher_Checksum` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_Checksum', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_Checksum`, 'returnType') = 'void'
attr(`delete_cipher_Checksum`, "inputTypes") = c('_p_cipher_Checksum')
class(`delete_cipher_Checksum`) = c("SWIGFunction", class('delete_cipher_Checksum'))

# Start of accessor method for cipher_Checksum
setMethod('$', '_p_cipher_Checksum', function(x, name)

{
  accessorFuns = list('isEqual' = cipher_Checksum_isEqual, 'assignFrom' = cipher_Checksum_assignFrom, 'assignTo' = cipher_Checksum_assignTo, 'data' = cipher_Checksum_data_get);
  vaccessors = c('data');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_Checksum
# Start of accessor method for cipher_Checksum
setMethod('$<-', '_p_cipher_Checksum', function(x, name, value)

{
  accessorFuns = list('data' = cipher_Checksum_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_Checksum', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_Checksum_data_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_Checksum
setMethod('delete', '_p_cipher_Checksum', function(obj) {delete_cipher_Checksum(obj)})
# Start definition of copy functions & methods for cipher_Checksum
CopyToR_cipher_Checksum = function(value, obj = new("cipher_Checksum"))
{
  obj@data = value$data;
  obj;
}



CopyToC_cipher_Checksum = function(value, obj)
{
  obj$data = value@data;
  obj
}



# Start definition of copy methods for cipher_Checksum
setMethod('copyToR', '_p_cipher_Checksum', CopyToR_cipher_Checksum);
setMethod('copyToC', 'cipher_Checksum', CopyToC_cipher_Checksum);

# End definition of copy methods for cipher_Checksum
# End definition of copy functions & methods for cipher_Checksum
# Start of cipher_SecKeys_getAt

`cipher_SecKeys_getAt` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_cipher_SecKeys_getAt', self, i, PACKAGE='skycoin');
  ans <- new("_p_cipher_SecKey", ref=ans) ;
  
  ans
  
}

attr(`cipher_SecKeys_getAt`, 'returnType') = '_p_cipher_SecKey'
attr(`cipher_SecKeys_getAt`, "inputTypes") = c('_p_cipher_SecKeys', 'integer')
class(`cipher_SecKeys_getAt`) = c("SWIGFunction", class('cipher_SecKeys_getAt'))

# Start of cipher_SecKeys_setAt

`cipher_SecKeys_setAt` = function(self, i, seckey, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(seckey, "ExternalReference")) seckey = slot(seckey,"ref") 
  ;.Call('R_swig_cipher_SecKeys_setAt', self, i, seckey, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SecKeys_setAt`, 'returnType') = 'integer'
attr(`cipher_SecKeys_setAt`, "inputTypes") = c('_p_cipher_SecKeys', 'integer', '_p_cipher_SecKey')
class(`cipher_SecKeys_setAt`) = c("SWIGFunction", class('cipher_SecKeys_setAt'))

# Start of cipher_SecKeys_isEqual

`cipher_SecKeys_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_SecKeys_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SecKeys_isEqual`, 'returnType') = 'integer'
attr(`cipher_SecKeys_isEqual`, "inputTypes") = c('_p_cipher_SecKeys', '_p_cipher_SecKeys')
class(`cipher_SecKeys_isEqual`) = c("SWIGFunction", class('cipher_SecKeys_isEqual'))

# Start of cipher_SecKeys_allocate

`cipher_SecKeys_allocate` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_cipher_SecKeys_allocate', self, n, PACKAGE='skycoin');
  
}

attr(`cipher_SecKeys_allocate`, 'returnType') = 'void'
attr(`cipher_SecKeys_allocate`, "inputTypes") = c('_p_cipher_SecKeys', 'integer')
class(`cipher_SecKeys_allocate`) = c("SWIGFunction", class('cipher_SecKeys_allocate'))

# Start of cipher_SecKeys_release

`cipher_SecKeys_release` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_SecKeys_release', self, PACKAGE='skycoin');
  
}

attr(`cipher_SecKeys_release`, 'returnType') = 'void'
attr(`cipher_SecKeys_release`, "inputTypes") = c('_p_cipher_SecKeys')
class(`cipher_SecKeys_release`) = c("SWIGFunction", class('cipher_SecKeys_release'))

# Start of cipher_SecKeys_data_set

`cipher_SecKeys_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_cipher_SecKeys_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_SecKeys_data_set`, 'returnType') = 'void'
attr(`cipher_SecKeys_data_set`, "inputTypes") = c('_p_cipher_SecKeys', '_p_cipher_SecKey')
class(`cipher_SecKeys_data_set`) = c("SWIGFunction", class('cipher_SecKeys_data_set'))

# Start of cipher_SecKeys_data_get

`cipher_SecKeys_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_SecKeys_data_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher_SecKey", ref=ans) ;
  
  ans
  
}

attr(`cipher_SecKeys_data_get`, 'returnType') = '_p_cipher_SecKey'
attr(`cipher_SecKeys_data_get`, "inputTypes") = c('_p_cipher_SecKeys')
class(`cipher_SecKeys_data_get`) = c("SWIGFunction", class('cipher_SecKeys_data_get'))

# Start of cipher_SecKeys_count_set

`cipher_SecKeys_count_set` = function(self, s_count)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_count = as.integer(s_count);
  
  if(length(s_count) > 1) {
    warning("using only the first element of s_count");
  };
  
  ;.Call('R_swig_cipher_SecKeys_count_set', self, s_count, PACKAGE='skycoin');
  
}

attr(`cipher_SecKeys_count_set`, 'returnType') = 'void'
attr(`cipher_SecKeys_count_set`, "inputTypes") = c('_p_cipher_SecKeys', 'integer')
class(`cipher_SecKeys_count_set`) = c("SWIGFunction", class('cipher_SecKeys_count_set'))

# Start of cipher_SecKeys_count_get

`cipher_SecKeys_count_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_SecKeys_count_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SecKeys_count_get`, 'returnType') = 'integer'
attr(`cipher_SecKeys_count_get`, "inputTypes") = c('_p_cipher_SecKeys')
class(`cipher_SecKeys_count_get`) = c("SWIGFunction", class('cipher_SecKeys_count_get'))

# Start of new_cipher_SecKeys

`cipher_SecKeys` = function()
{
  ;ans = .Call('R_swig_new_cipher_SecKeys', PACKAGE='skycoin');
  ans <- new("_p_cipher_SecKeys", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_SecKeys)
  ans
  
}

attr(`cipher_SecKeys`, 'returnType') = '_p_cipher_SecKeys'
class(`cipher_SecKeys`) = c("SWIGFunction", class('cipher_SecKeys'))

# Start of delete_cipher_SecKeys

`delete_cipher_SecKeys` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_SecKeys', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_SecKeys`, 'returnType') = 'void'
attr(`delete_cipher_SecKeys`, "inputTypes") = c('_p_cipher_SecKeys')
class(`delete_cipher_SecKeys`) = c("SWIGFunction", class('delete_cipher_SecKeys'))

# Start of accessor method for cipher_SecKeys
setMethod('$', '_p_cipher_SecKeys', function(x, name)

{
  accessorFuns = list('getAt' = cipher_SecKeys_getAt, 'setAt' = cipher_SecKeys_setAt, 'isEqual' = cipher_SecKeys_isEqual, 'allocate' = cipher_SecKeys_allocate, 'release' = cipher_SecKeys_release, 'data' = cipher_SecKeys_data_get, 'count' = cipher_SecKeys_count_get);
  vaccessors = c('data', 'count');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_SecKeys
# Start of accessor method for cipher_SecKeys
setMethod('$<-', '_p_cipher_SecKeys', function(x, name, value)

{
  accessorFuns = list('data' = cipher_SecKeys_data_set, 'count' = cipher_SecKeys_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_SecKeys', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_SecKeys_data_set, 'count' = cipher_SecKeys_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_SecKeys
setMethod('delete', '_p_cipher_SecKeys', function(obj) {delete_cipher_SecKeys(obj)})
# Start definition of copy functions & methods for cipher_SecKeys
CopyToR_cipher_SecKeys = function(value, obj = new("cipher_SecKeys"))
{
  obj@count = value$count;
  obj;
}



CopyToC_cipher_SecKeys = function(value, obj)
{
  obj$count = value@count;
  obj
}



# Start definition of copy methods for cipher_SecKeys
setMethod('copyToR', '_p_cipher_SecKeys', CopyToR_cipher_SecKeys);
setMethod('copyToC', 'cipher_SecKeys', CopyToC_cipher_SecKeys);

# End definition of copy methods for cipher_SecKeys
# End definition of copy functions & methods for cipher_SecKeys
# Start of cipher_PubKeys_getAt

`cipher_PubKeys_getAt` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_cipher_PubKeys_getAt', self, i, PACKAGE='skycoin');
  ans <- new("_p_cipher_PubKey", ref=ans) ;
  
  ans
  
}

attr(`cipher_PubKeys_getAt`, 'returnType') = '_p_cipher_PubKey'
attr(`cipher_PubKeys_getAt`, "inputTypes") = c('_p_cipher_PubKeys', 'integer')
class(`cipher_PubKeys_getAt`) = c("SWIGFunction", class('cipher_PubKeys_getAt'))

# Start of cipher_PubKeys_setAt

`cipher_PubKeys_setAt` = function(self, i, pubkey, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(pubkey, "ExternalReference")) pubkey = slot(pubkey,"ref") 
  ;.Call('R_swig_cipher_PubKeys_setAt', self, i, pubkey, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_PubKeys_setAt`, 'returnType') = 'integer'
attr(`cipher_PubKeys_setAt`, "inputTypes") = c('_p_cipher_PubKeys', 'integer', '_p_cipher_PubKey')
class(`cipher_PubKeys_setAt`) = c("SWIGFunction", class('cipher_PubKeys_setAt'))

# Start of cipher_PubKeys_isEqual

`cipher_PubKeys_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_PubKeys_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_PubKeys_isEqual`, 'returnType') = 'integer'
attr(`cipher_PubKeys_isEqual`, "inputTypes") = c('_p_cipher_PubKeys', '_p_cipher_PubKeys')
class(`cipher_PubKeys_isEqual`) = c("SWIGFunction", class('cipher_PubKeys_isEqual'))

# Start of cipher_PubKeys_allocate

`cipher_PubKeys_allocate` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_cipher_PubKeys_allocate', self, n, PACKAGE='skycoin');
  
}

attr(`cipher_PubKeys_allocate`, 'returnType') = 'void'
attr(`cipher_PubKeys_allocate`, "inputTypes") = c('_p_cipher_PubKeys', 'integer')
class(`cipher_PubKeys_allocate`) = c("SWIGFunction", class('cipher_PubKeys_allocate'))

# Start of cipher_PubKeys_release

`cipher_PubKeys_release` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_PubKeys_release', self, PACKAGE='skycoin');
  
}

attr(`cipher_PubKeys_release`, 'returnType') = 'void'
attr(`cipher_PubKeys_release`, "inputTypes") = c('_p_cipher_PubKeys')
class(`cipher_PubKeys_release`) = c("SWIGFunction", class('cipher_PubKeys_release'))

# Start of cipher_PubKeys_data_set

`cipher_PubKeys_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_cipher_PubKeys_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_PubKeys_data_set`, 'returnType') = 'void'
attr(`cipher_PubKeys_data_set`, "inputTypes") = c('_p_cipher_PubKeys', '_p_cipher_PubKey')
class(`cipher_PubKeys_data_set`) = c("SWIGFunction", class('cipher_PubKeys_data_set'))

# Start of cipher_PubKeys_data_get

`cipher_PubKeys_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_PubKeys_data_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher_PubKey", ref=ans) ;
  
  ans
  
}

attr(`cipher_PubKeys_data_get`, 'returnType') = '_p_cipher_PubKey'
attr(`cipher_PubKeys_data_get`, "inputTypes") = c('_p_cipher_PubKeys')
class(`cipher_PubKeys_data_get`) = c("SWIGFunction", class('cipher_PubKeys_data_get'))

# Start of cipher_PubKeys_count_set

`cipher_PubKeys_count_set` = function(self, s_count)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_count = as.integer(s_count);
  
  if(length(s_count) > 1) {
    warning("using only the first element of s_count");
  };
  
  ;.Call('R_swig_cipher_PubKeys_count_set', self, s_count, PACKAGE='skycoin');
  
}

attr(`cipher_PubKeys_count_set`, 'returnType') = 'void'
attr(`cipher_PubKeys_count_set`, "inputTypes") = c('_p_cipher_PubKeys', 'integer')
class(`cipher_PubKeys_count_set`) = c("SWIGFunction", class('cipher_PubKeys_count_set'))

# Start of cipher_PubKeys_count_get

`cipher_PubKeys_count_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_PubKeys_count_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_PubKeys_count_get`, 'returnType') = 'integer'
attr(`cipher_PubKeys_count_get`, "inputTypes") = c('_p_cipher_PubKeys')
class(`cipher_PubKeys_count_get`) = c("SWIGFunction", class('cipher_PubKeys_count_get'))

# Start of new_cipher_PubKeys

`cipher_PubKeys` = function()
{
  ;ans = .Call('R_swig_new_cipher_PubKeys', PACKAGE='skycoin');
  ans <- new("_p_cipher_PubKeys", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_PubKeys)
  ans
  
}

attr(`cipher_PubKeys`, 'returnType') = '_p_cipher_PubKeys'
class(`cipher_PubKeys`) = c("SWIGFunction", class('cipher_PubKeys'))

# Start of delete_cipher_PubKeys

`delete_cipher_PubKeys` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_PubKeys', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_PubKeys`, 'returnType') = 'void'
attr(`delete_cipher_PubKeys`, "inputTypes") = c('_p_cipher_PubKeys')
class(`delete_cipher_PubKeys`) = c("SWIGFunction", class('delete_cipher_PubKeys'))

# Start of accessor method for cipher_PubKeys
setMethod('$', '_p_cipher_PubKeys', function(x, name)

{
  accessorFuns = list('getAt' = cipher_PubKeys_getAt, 'setAt' = cipher_PubKeys_setAt, 'isEqual' = cipher_PubKeys_isEqual, 'allocate' = cipher_PubKeys_allocate, 'release' = cipher_PubKeys_release, 'data' = cipher_PubKeys_data_get, 'count' = cipher_PubKeys_count_get);
  vaccessors = c('data', 'count');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_PubKeys
# Start of accessor method for cipher_PubKeys
setMethod('$<-', '_p_cipher_PubKeys', function(x, name, value)

{
  accessorFuns = list('data' = cipher_PubKeys_data_set, 'count' = cipher_PubKeys_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_PubKeys', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_PubKeys_data_set, 'count' = cipher_PubKeys_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_PubKeys
setMethod('delete', '_p_cipher_PubKeys', function(obj) {delete_cipher_PubKeys(obj)})
# Start definition of copy functions & methods for cipher_PubKeys
CopyToR_cipher_PubKeys = function(value, obj = new("cipher_PubKeys"))
{
  obj@count = value$count;
  obj;
}



CopyToC_cipher_PubKeys = function(value, obj)
{
  obj$count = value@count;
  obj
}



# Start definition of copy methods for cipher_PubKeys
setMethod('copyToR', '_p_cipher_PubKeys', CopyToR_cipher_PubKeys);
setMethod('copyToC', 'cipher_PubKeys', CopyToC_cipher_PubKeys);

# End definition of copy methods for cipher_PubKeys
# End definition of copy functions & methods for cipher_PubKeys
# Start of cipher_SHA256s_getAt

`cipher_SHA256s_getAt` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_cipher_SHA256s_getAt', self, i, PACKAGE='skycoin');
  ans <- new("_p_cipher_SHA256", ref=ans) ;
  
  ans
  
}

attr(`cipher_SHA256s_getAt`, 'returnType') = '_p_cipher_SHA256'
attr(`cipher_SHA256s_getAt`, "inputTypes") = c('_p_cipher_SHA256s', 'integer')
class(`cipher_SHA256s_getAt`) = c("SWIGFunction", class('cipher_SHA256s_getAt'))

# Start of cipher_SHA256s_setAt

`cipher_SHA256s_setAt` = function(self, i, hash, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(hash, "ExternalReference")) hash = slot(hash,"ref") 
  ;.Call('R_swig_cipher_SHA256s_setAt', self, i, hash, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SHA256s_setAt`, 'returnType') = 'integer'
attr(`cipher_SHA256s_setAt`, "inputTypes") = c('_p_cipher_SHA256s', 'integer', '_p_cipher_SHA256')
class(`cipher_SHA256s_setAt`) = c("SWIGFunction", class('cipher_SHA256s_setAt'))

# Start of cipher_SHA256s_isEqual

`cipher_SHA256s_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_SHA256s_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SHA256s_isEqual`, 'returnType') = 'integer'
attr(`cipher_SHA256s_isEqual`, "inputTypes") = c('_p_cipher_SHA256s', '_p_cipher_SHA256s')
class(`cipher_SHA256s_isEqual`) = c("SWIGFunction", class('cipher_SHA256s_isEqual'))

# Start of cipher_SHA256s_allocate

`cipher_SHA256s_allocate` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_cipher_SHA256s_allocate', self, n, PACKAGE='skycoin');
  
}

attr(`cipher_SHA256s_allocate`, 'returnType') = 'void'
attr(`cipher_SHA256s_allocate`, "inputTypes") = c('_p_cipher_SHA256s', 'integer')
class(`cipher_SHA256s_allocate`) = c("SWIGFunction", class('cipher_SHA256s_allocate'))

# Start of cipher_SHA256s_release

`cipher_SHA256s_release` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_SHA256s_release', self, PACKAGE='skycoin');
  
}

attr(`cipher_SHA256s_release`, 'returnType') = 'void'
attr(`cipher_SHA256s_release`, "inputTypes") = c('_p_cipher_SHA256s')
class(`cipher_SHA256s_release`) = c("SWIGFunction", class('cipher_SHA256s_release'))

# Start of cipher_SHA256s_data_set

`cipher_SHA256s_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_cipher_SHA256s_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_SHA256s_data_set`, 'returnType') = 'void'
attr(`cipher_SHA256s_data_set`, "inputTypes") = c('_p_cipher_SHA256s', '_p_cipher_SHA256')
class(`cipher_SHA256s_data_set`) = c("SWIGFunction", class('cipher_SHA256s_data_set'))

# Start of cipher_SHA256s_data_get

`cipher_SHA256s_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_SHA256s_data_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher_SHA256", ref=ans) ;
  
  ans
  
}

attr(`cipher_SHA256s_data_get`, 'returnType') = '_p_cipher_SHA256'
attr(`cipher_SHA256s_data_get`, "inputTypes") = c('_p_cipher_SHA256s')
class(`cipher_SHA256s_data_get`) = c("SWIGFunction", class('cipher_SHA256s_data_get'))

# Start of cipher_SHA256s_count_set

`cipher_SHA256s_count_set` = function(self, s_count)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_count = as.integer(s_count);
  
  if(length(s_count) > 1) {
    warning("using only the first element of s_count");
  };
  
  ;.Call('R_swig_cipher_SHA256s_count_set', self, s_count, PACKAGE='skycoin');
  
}

attr(`cipher_SHA256s_count_set`, 'returnType') = 'void'
attr(`cipher_SHA256s_count_set`, "inputTypes") = c('_p_cipher_SHA256s', 'integer')
class(`cipher_SHA256s_count_set`) = c("SWIGFunction", class('cipher_SHA256s_count_set'))

# Start of cipher_SHA256s_count_get

`cipher_SHA256s_count_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_SHA256s_count_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_SHA256s_count_get`, 'returnType') = 'integer'
attr(`cipher_SHA256s_count_get`, "inputTypes") = c('_p_cipher_SHA256s')
class(`cipher_SHA256s_count_get`) = c("SWIGFunction", class('cipher_SHA256s_count_get'))

# Start of new_cipher_SHA256s

`cipher_SHA256s` = function()
{
  ;ans = .Call('R_swig_new_cipher_SHA256s', PACKAGE='skycoin');
  ans <- new("_p_cipher_SHA256s", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_SHA256s)
  ans
  
}

attr(`cipher_SHA256s`, 'returnType') = '_p_cipher_SHA256s'
class(`cipher_SHA256s`) = c("SWIGFunction", class('cipher_SHA256s'))

# Start of delete_cipher_SHA256s

`delete_cipher_SHA256s` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_SHA256s', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_SHA256s`, 'returnType') = 'void'
attr(`delete_cipher_SHA256s`, "inputTypes") = c('_p_cipher_SHA256s')
class(`delete_cipher_SHA256s`) = c("SWIGFunction", class('delete_cipher_SHA256s'))

# Start of accessor method for cipher_SHA256s
setMethod('$', '_p_cipher_SHA256s', function(x, name)

{
  accessorFuns = list('getAt' = cipher_SHA256s_getAt, 'setAt' = cipher_SHA256s_setAt, 'isEqual' = cipher_SHA256s_isEqual, 'allocate' = cipher_SHA256s_allocate, 'release' = cipher_SHA256s_release, 'data' = cipher_SHA256s_data_get, 'count' = cipher_SHA256s_count_get);
  vaccessors = c('data', 'count');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_SHA256s
# Start of accessor method for cipher_SHA256s
setMethod('$<-', '_p_cipher_SHA256s', function(x, name, value)

{
  accessorFuns = list('data' = cipher_SHA256s_data_set, 'count' = cipher_SHA256s_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_SHA256s', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_SHA256s_data_set, 'count' = cipher_SHA256s_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_SHA256s
setMethod('delete', '_p_cipher_SHA256s', function(obj) {delete_cipher_SHA256s(obj)})
# Start definition of copy functions & methods for cipher_SHA256s
CopyToR_cipher_SHA256s = function(value, obj = new("cipher_SHA256s"))
{
  obj@count = value$count;
  obj;
}



CopyToC_cipher_SHA256s = function(value, obj)
{
  obj$count = value@count;
  obj
}



# Start definition of copy methods for cipher_SHA256s
setMethod('copyToR', '_p_cipher_SHA256s', CopyToR_cipher_SHA256s);
setMethod('copyToC', 'cipher_SHA256s', CopyToC_cipher_SHA256s);

# End definition of copy methods for cipher_SHA256s
# End definition of copy functions & methods for cipher_SHA256s
# Start of coin_UxOutArray_getAt

`coin_UxOutArray_getAt` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_coin_UxOutArray_getAt', self, i, PACKAGE='skycoin');
  ans <- new("_p_coin__UxOut", ref=ans) ;
  
  ans
  
}

attr(`coin_UxOutArray_getAt`, 'returnType') = '_p_coin__UxOut'
attr(`coin_UxOutArray_getAt`, "inputTypes") = c('_p_coin_UxOutArray', 'integer')
class(`coin_UxOutArray_getAt`) = c("SWIGFunction", class('coin_UxOutArray_getAt'))

# Start of coin_UxOutArray_setAt

`coin_UxOutArray_setAt` = function(self, i, uxout, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(uxout, "ExternalReference")) uxout = slot(uxout,"ref") 
  ;.Call('R_swig_coin_UxOutArray_setAt', self, i, uxout, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_setAt`, 'returnType') = 'integer'
attr(`coin_UxOutArray_setAt`, "inputTypes") = c('_p_coin_UxOutArray', 'integer', '_p_coin__UxOut')
class(`coin_UxOutArray_setAt`) = c("SWIGFunction", class('coin_UxOutArray_setAt'))

# Start of coin_UxOutArray_isEqual

`coin_UxOutArray_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_coin_UxOutArray_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_isEqual`, 'returnType') = 'integer'
attr(`coin_UxOutArray_isEqual`, "inputTypes") = c('_p_coin_UxOutArray', '_p_coin_UxOutArray')
class(`coin_UxOutArray_isEqual`) = c("SWIGFunction", class('coin_UxOutArray_isEqual'))

# Start of coin_UxOutArray_allocate

`coin_UxOutArray_allocate` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_coin_UxOutArray_allocate', self, n, PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_allocate`, 'returnType') = 'void'
attr(`coin_UxOutArray_allocate`, "inputTypes") = c('_p_coin_UxOutArray', 'integer')
class(`coin_UxOutArray_allocate`) = c("SWIGFunction", class('coin_UxOutArray_allocate'))

# Start of coin_UxOutArray_append

`coin_UxOutArray_append` = function(self, uxout)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(uxout, "ExternalReference")) uxout = slot(uxout,"ref") 
  ;.Call('R_swig_coin_UxOutArray_append', self, uxout, PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_append`, 'returnType') = 'void'
attr(`coin_UxOutArray_append`, "inputTypes") = c('_p_coin_UxOutArray', '_p_coin__UxOut')
class(`coin_UxOutArray_append`) = c("SWIGFunction", class('coin_UxOutArray_append'))

# Start of coin_UxOutArray_release

`coin_UxOutArray_release` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin_UxOutArray_release', self, PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_release`, 'returnType') = 'void'
attr(`coin_UxOutArray_release`, "inputTypes") = c('_p_coin_UxOutArray')
class(`coin_UxOutArray_release`) = c("SWIGFunction", class('coin_UxOutArray_release'))

# Start of coin_UxOutArray_data_set

`coin_UxOutArray_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_coin_UxOutArray_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_data_set`, 'returnType') = 'void'
attr(`coin_UxOutArray_data_set`, "inputTypes") = c('_p_coin_UxOutArray', '_p_coin__UxOut')
class(`coin_UxOutArray_data_set`) = c("SWIGFunction", class('coin_UxOutArray_data_set'))

# Start of coin_UxOutArray_data_get

`coin_UxOutArray_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin_UxOutArray_data_get', self, PACKAGE='skycoin');
  ans <- new("_p_coin__UxOut", ref=ans) ;
  
  ans
  
}

attr(`coin_UxOutArray_data_get`, 'returnType') = '_p_coin__UxOut'
attr(`coin_UxOutArray_data_get`, "inputTypes") = c('_p_coin_UxOutArray')
class(`coin_UxOutArray_data_get`) = c("SWIGFunction", class('coin_UxOutArray_data_get'))

# Start of coin_UxOutArray_count_set

`coin_UxOutArray_count_set` = function(self, s_count)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_count = as.integer(s_count);
  
  if(length(s_count) > 1) {
    warning("using only the first element of s_count");
  };
  
  ;.Call('R_swig_coin_UxOutArray_count_set', self, s_count, PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_count_set`, 'returnType') = 'void'
attr(`coin_UxOutArray_count_set`, "inputTypes") = c('_p_coin_UxOutArray', 'integer')
class(`coin_UxOutArray_count_set`) = c("SWIGFunction", class('coin_UxOutArray_count_set'))

# Start of coin_UxOutArray_count_get

`coin_UxOutArray_count_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin_UxOutArray_count_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin_UxOutArray_count_get`, 'returnType') = 'integer'
attr(`coin_UxOutArray_count_get`, "inputTypes") = c('_p_coin_UxOutArray')
class(`coin_UxOutArray_count_get`) = c("SWIGFunction", class('coin_UxOutArray_count_get'))

# Start of new_coin_UxOutArray

`coin_UxOutArray` = function()
{
  ;ans = .Call('R_swig_new_coin_UxOutArray', PACKAGE='skycoin');
  ans <- new("_p_coin_UxOutArray", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin_UxOutArray)
  ans
  
}

attr(`coin_UxOutArray`, 'returnType') = '_p_coin_UxOutArray'
class(`coin_UxOutArray`) = c("SWIGFunction", class('coin_UxOutArray'))

# Start of delete_coin_UxOutArray

`delete_coin_UxOutArray` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin_UxOutArray', self, PACKAGE='skycoin');
  
}

attr(`delete_coin_UxOutArray`, 'returnType') = 'void'
attr(`delete_coin_UxOutArray`, "inputTypes") = c('_p_coin_UxOutArray')
class(`delete_coin_UxOutArray`) = c("SWIGFunction", class('delete_coin_UxOutArray'))

# Start of accessor method for coin_UxOutArray
setMethod('$', '_p_coin_UxOutArray', function(x, name)

{
  accessorFuns = list('getAt' = coin_UxOutArray_getAt, 'setAt' = coin_UxOutArray_setAt, 'isEqual' = coin_UxOutArray_isEqual, 'allocate' = coin_UxOutArray_allocate, 'append' = coin_UxOutArray_append, 'release' = coin_UxOutArray_release, 'data' = coin_UxOutArray_data_get, 'count' = coin_UxOutArray_count_get);
  vaccessors = c('data', 'count');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin_UxOutArray
# Start of accessor method for coin_UxOutArray
setMethod('$<-', '_p_coin_UxOutArray', function(x, name, value)

{
  accessorFuns = list('data' = coin_UxOutArray_data_set, 'count' = coin_UxOutArray_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin_UxOutArray', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = coin_UxOutArray_data_set, 'count' = coin_UxOutArray_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin_UxOutArray
setMethod('delete', '_p_coin_UxOutArray', function(obj) {delete_coin_UxOutArray(obj)})
# Start definition of copy functions & methods for coin_UxOutArray
CopyToR_coin_UxOutArray = function(value, obj = new("coin_UxOutArray"))
{
  obj@count = value$count;
  obj;
}



CopyToC_coin_UxOutArray = function(value, obj)
{
  obj$count = value@count;
  obj
}



# Start definition of copy methods for coin_UxOutArray
setMethod('copyToR', '_p_coin_UxOutArray', CopyToR_coin_UxOutArray);
setMethod('copyToC', 'coin_UxOutArray', CopyToC_coin_UxOutArray);

# End definition of copy methods for coin_UxOutArray
# End definition of copy functions & methods for coin_UxOutArray
# Start of cipher_Addresses_getAt

`cipher_Addresses_getAt` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_cipher_Addresses_getAt', self, i, PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  ans
  
}

attr(`cipher_Addresses_getAt`, 'returnType') = '_p_cipher__Address'
attr(`cipher_Addresses_getAt`, "inputTypes") = c('_p_cipher_Addresses', 'integer')
class(`cipher_Addresses_getAt`) = c("SWIGFunction", class('cipher_Addresses_getAt'))

# Start of cipher_Addresses_setAt

`cipher_Addresses_setAt` = function(self, i, addr, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(addr, "ExternalReference")) addr = slot(addr,"ref") 
  ;.Call('R_swig_cipher_Addresses_setAt', self, i, addr, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_Addresses_setAt`, 'returnType') = 'integer'
attr(`cipher_Addresses_setAt`, "inputTypes") = c('_p_cipher_Addresses', 'integer', '_p_cipher_Addresses')
class(`cipher_Addresses_setAt`) = c("SWIGFunction", class('cipher_Addresses_setAt'))

# Start of cipher_Addresses_isEqual

`cipher_Addresses_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher_Addresses_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_Addresses_isEqual`, 'returnType') = 'integer'
attr(`cipher_Addresses_isEqual`, "inputTypes") = c('_p_cipher_Addresses', '_p_cipher_Addresses')
class(`cipher_Addresses_isEqual`) = c("SWIGFunction", class('cipher_Addresses_isEqual'))

# Start of cipher_Addresses_allocate

`cipher_Addresses_allocate` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_cipher_Addresses_allocate', self, n, PACKAGE='skycoin');
  
}

attr(`cipher_Addresses_allocate`, 'returnType') = 'void'
attr(`cipher_Addresses_allocate`, "inputTypes") = c('_p_cipher_Addresses', 'integer')
class(`cipher_Addresses_allocate`) = c("SWIGFunction", class('cipher_Addresses_allocate'))

# Start of cipher_Addresses_release

`cipher_Addresses_release` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_Addresses_release', self, PACKAGE='skycoin');
  
}

attr(`cipher_Addresses_release`, 'returnType') = 'void'
attr(`cipher_Addresses_release`, "inputTypes") = c('_p_cipher_Addresses')
class(`cipher_Addresses_release`) = c("SWIGFunction", class('cipher_Addresses_release'))

# Start of cipher_Addresses_data_set

`cipher_Addresses_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_cipher_Addresses_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`cipher_Addresses_data_set`, 'returnType') = 'void'
attr(`cipher_Addresses_data_set`, "inputTypes") = c('_p_cipher_Addresses', '_p_cipher__Address')
class(`cipher_Addresses_data_set`) = c("SWIGFunction", class('cipher_Addresses_data_set'))

# Start of cipher_Addresses_data_get

`cipher_Addresses_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher_Addresses_data_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  ans
  
}

attr(`cipher_Addresses_data_get`, 'returnType') = '_p_cipher__Address'
attr(`cipher_Addresses_data_get`, "inputTypes") = c('_p_cipher_Addresses')
class(`cipher_Addresses_data_get`) = c("SWIGFunction", class('cipher_Addresses_data_get'))

# Start of cipher_Addresses_count_set

`cipher_Addresses_count_set` = function(self, s_count)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_count = as.integer(s_count);
  
  if(length(s_count) > 1) {
    warning("using only the first element of s_count");
  };
  
  ;.Call('R_swig_cipher_Addresses_count_set', self, s_count, PACKAGE='skycoin');
  
}

attr(`cipher_Addresses_count_set`, 'returnType') = 'void'
attr(`cipher_Addresses_count_set`, "inputTypes") = c('_p_cipher_Addresses', 'integer')
class(`cipher_Addresses_count_set`) = c("SWIGFunction", class('cipher_Addresses_count_set'))

# Start of cipher_Addresses_count_get

`cipher_Addresses_count_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher_Addresses_count_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher_Addresses_count_get`, 'returnType') = 'integer'
attr(`cipher_Addresses_count_get`, "inputTypes") = c('_p_cipher_Addresses')
class(`cipher_Addresses_count_get`) = c("SWIGFunction", class('cipher_Addresses_count_get'))

# Start of new_cipher_Addresses

`cipher_Addresses` = function()
{
  ;ans = .Call('R_swig_new_cipher_Addresses', PACKAGE='skycoin');
  ans <- new("_p_cipher_Addresses", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher_Addresses)
  ans
  
}

attr(`cipher_Addresses`, 'returnType') = '_p_cipher_Addresses'
class(`cipher_Addresses`) = c("SWIGFunction", class('cipher_Addresses'))

# Start of delete_cipher_Addresses

`delete_cipher_Addresses` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher_Addresses', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher_Addresses`, 'returnType') = 'void'
attr(`delete_cipher_Addresses`, "inputTypes") = c('_p_cipher_Addresses')
class(`delete_cipher_Addresses`) = c("SWIGFunction", class('delete_cipher_Addresses'))

# Start of accessor method for cipher_Addresses
setMethod('$', '_p_cipher_Addresses', function(x, name)

{
  accessorFuns = list('getAt' = cipher_Addresses_getAt, 'setAt' = cipher_Addresses_setAt, 'isEqual' = cipher_Addresses_isEqual, 'allocate' = cipher_Addresses_allocate, 'release' = cipher_Addresses_release, 'data' = cipher_Addresses_data_get, 'count' = cipher_Addresses_count_get);
  vaccessors = c('data', 'count');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher_Addresses
# Start of accessor method for cipher_Addresses
setMethod('$<-', '_p_cipher_Addresses', function(x, name, value)

{
  accessorFuns = list('data' = cipher_Addresses_data_set, 'count' = cipher_Addresses_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher_Addresses', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = cipher_Addresses_data_set, 'count' = cipher_Addresses_count_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher_Addresses
setMethod('delete', '_p_cipher_Addresses', function(obj) {delete_cipher_Addresses(obj)})
# Start definition of copy functions & methods for cipher_Addresses
CopyToR_cipher_Addresses = function(value, obj = new("cipher_Addresses"))
{
  obj@count = value$count;
  obj;
}



CopyToC_cipher_Addresses = function(value, obj)
{
  obj$count = value@count;
  obj
}



# Start definition of copy methods for cipher_Addresses
setMethod('copyToR', '_p_cipher_Addresses', CopyToR_cipher_Addresses);
setMethod('copyToC', 'cipher_Addresses', CopyToC_cipher_Addresses);

# End definition of copy methods for cipher_Addresses
# End definition of copy functions & methods for cipher_Addresses
# Start of Fee_Calculator_callback_set

`Fee_Calculator_callback_set` = function(self, s_callback)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_callback, "ExternalReference")) s_callback = slot(s_callback,"ref") 
  ;.Call('R_swig_Fee_Calculator_callback_set', self, s_callback, PACKAGE='skycoin');
  
}

attr(`Fee_Calculator_callback_set`, 'returnType') = 'void'
attr(`Fee_Calculator_callback_set`, "inputTypes") = c('_p_Fee_Calculator', '_p_f_Transaction__Handle_p_unsigned_long_long_p_void__GoUint32_')
class(`Fee_Calculator_callback_set`) = c("SWIGFunction", class('Fee_Calculator_callback_set'))

# Start of Fee_Calculator_callback_get

`Fee_Calculator_callback_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Fee_Calculator_callback_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_f_Transaction__Handle_p_unsigned_long_long_p_void__GoUint32_", ref=ans) ;
  
  ans
  
}

attr(`Fee_Calculator_callback_get`, 'returnType') = '_p_f_Transaction__Handle_p_unsigned_long_long_p_void__GoUint32_'
attr(`Fee_Calculator_callback_get`, "inputTypes") = c('_p_Fee_Calculator')
class(`Fee_Calculator_callback_get`) = c("SWIGFunction", class('Fee_Calculator_callback_get'))

# Start of Fee_Calculator_context_set

`Fee_Calculator_context_set` = function(self, s_context)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_context, "ExternalReference")) s_context = slot(s_context,"ref") 
  ;.Call('R_swig_Fee_Calculator_context_set', self, s_context, PACKAGE='skycoin');
  
}

attr(`Fee_Calculator_context_set`, 'returnType') = 'void'
attr(`Fee_Calculator_context_set`, "inputTypes") = c('_p_Fee_Calculator', '_p_void')
class(`Fee_Calculator_context_set`) = c("SWIGFunction", class('Fee_Calculator_context_set'))

# Start of Fee_Calculator_context_get

`Fee_Calculator_context_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Fee_Calculator_context_get', self, PACKAGE='skycoin');
  ans <- new("_p_void", ref=ans) ;
  
  ans
  
}

attr(`Fee_Calculator_context_get`, 'returnType') = '_p_void'
attr(`Fee_Calculator_context_get`, "inputTypes") = c('_p_Fee_Calculator')
class(`Fee_Calculator_context_get`) = c("SWIGFunction", class('Fee_Calculator_context_get'))

# Start of new_Fee_Calculator

`Fee_Calculator` = function()
{
  ;ans = .Call('R_swig_new_Fee_Calculator', PACKAGE='skycoin');
  ans <- new("_p_Fee_Calculator", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Fee_Calculator)
  ans
  
}

attr(`Fee_Calculator`, 'returnType') = '_p_Fee_Calculator'
class(`Fee_Calculator`) = c("SWIGFunction", class('Fee_Calculator'))

# Start of delete_Fee_Calculator

`delete_Fee_Calculator` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Fee_Calculator', self, PACKAGE='skycoin');
  
}

attr(`delete_Fee_Calculator`, 'returnType') = 'void'
attr(`delete_Fee_Calculator`, "inputTypes") = c('_p_Fee_Calculator')
class(`delete_Fee_Calculator`) = c("SWIGFunction", class('delete_Fee_Calculator'))

# Start of accessor method for Fee_Calculator
setMethod('$', '_p_Fee_Calculator', function(x, name)

{
  accessorFuns = list('callback' = Fee_Calculator_callback_get, 'context' = Fee_Calculator_context_get);
  vaccessors = c('callback', 'context');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for Fee_Calculator
# Start of accessor method for Fee_Calculator
setMethod('$<-', '_p_Fee_Calculator', function(x, name, value)

{
  accessorFuns = list('callback' = Fee_Calculator_callback_set, 'context' = Fee_Calculator_context_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_Fee_Calculator', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('callback' = Fee_Calculator_callback_set, 'context' = Fee_Calculator_context_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for Fee_Calculator
setMethod('delete', '_p_Fee_Calculator', function(obj) {delete_Fee_Calculator(obj)})
# Start definition of copy functions & methods for Fee_Calculator
CopyToR_Fee_Calculator = function(value, obj = new("Fee_Calculator"))
{
  obj;
}



CopyToC_Fee_Calculator = function(value, obj)
{
  obj
}



# Start definition of copy methods for Fee_Calculator
setMethod('copyToR', '_p_Fee_Calculator', CopyToR_Fee_Calculator);
setMethod('copyToC', 'Fee_Calculator', CopyToC_Fee_Calculator);

# End definition of copy methods for Fee_Calculator
# End definition of copy functions & methods for Fee_Calculator
# Start of _GoString__p_set

`_GoString__p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_p = as(s_p, "character"); 
  ;.Call('R_swig__GoString__p_set', self, s_p, PACKAGE='skycoin');
  
}

attr(`_GoString__p_set`, 'returnType') = 'void'
attr(`_GoString__p_set`, "inputTypes") = c('_p__GoString_', 'character')
class(`_GoString__p_set`) = c("SWIGFunction", class('_GoString__p_set'))

# Start of _GoString__p_get

`_GoString__p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig__GoString__p_get', self, PACKAGE='skycoin');
  
}

attr(`_GoString__p_get`, 'returnType') = 'character'
attr(`_GoString__p_get`, "inputTypes") = c('_p__GoString_')
class(`_GoString__p_get`) = c("SWIGFunction", class('_GoString__p_get'))

# Start of _GoString__n_set

`_GoString__n_set` = function(self, s_n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_n = as.integer(s_n);
  
  if(length(s_n) > 1) {
    warning("using only the first element of s_n");
  };
  
  ;.Call('R_swig__GoString__n_set', self, s_n, PACKAGE='skycoin');
  
}

attr(`_GoString__n_set`, 'returnType') = 'void'
attr(`_GoString__n_set`, "inputTypes") = c('_p__GoString_', 'integer')
class(`_GoString__n_set`) = c("SWIGFunction", class('_GoString__n_set'))

# Start of _GoString__n_get

`_GoString__n_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig__GoString__n_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`_GoString__n_get`, 'returnType') = 'integer'
attr(`_GoString__n_get`, "inputTypes") = c('_p__GoString_')
class(`_GoString__n_get`) = c("SWIGFunction", class('_GoString__n_get'))

# Start of new__GoString_

`_GoString_` = function()
{
  ;ans = .Call('R_swig_new__GoString_', PACKAGE='skycoin');
  ans <- new("_p__GoString_", ref=ans) ;
  
  reg.finalizer(ans@ref, delete__GoString_)
  ans
  
}

attr(`_GoString_`, 'returnType') = '_p__GoString_'
class(`_GoString_`) = c("SWIGFunction", class('_GoString_'))

# Start of delete__GoString_

`delete__GoString_` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete__GoString_', self, PACKAGE='skycoin');
  
}

attr(`delete__GoString_`, 'returnType') = 'void'
attr(`delete__GoString_`, "inputTypes") = c('_p__GoString_')
class(`delete__GoString_`) = c("SWIGFunction", class('delete__GoString_'))

# Start of accessor method for _GoString_
setMethod('$', '_p__GoString_', function(x, name)

{
  accessorFuns = list('p' = _GoString__p_get, 'n' = _GoString__n_get);
  vaccessors = c('p', 'n');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for _GoString_
# Start of accessor method for _GoString_
setMethod('$<-', '_p__GoString_', function(x, name, value)

{
  accessorFuns = list('p' = _GoString__p_set, 'n' = _GoString__n_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p__GoString_', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('p' = _GoString__p_set, 'n' = _GoString__n_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for _GoString_
setMethod('delete', '_p__GoString_', function(obj) {delete__GoString_(obj)})
# Start definition of copy functions & methods for _GoString_
CopyToR__GoString_ = function(value, obj = new("_GoString_"))
{
  obj@p = value$p;
  obj@n = value$n;
  obj;
}



CopyToC__GoString_ = function(value, obj)
{
  obj$p = value@p;
  obj$n = value@n;
  obj
}



# Start definition of copy methods for _GoString_
setMethod('copyToR', '_p__GoString_', CopyToR__GoString_);
setMethod('copyToC', '_GoString_', CopyToC__GoString_);

# End definition of copy methods for _GoString_
# End definition of copy functions & methods for _GoString_
# Start of GoInterface_t_set

`GoInterface_t_set` = function(self, s_t)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_t, "ExternalReference")) s_t = slot(s_t,"ref") 
  ;.Call('R_swig_GoInterface_t_set', self, s_t, PACKAGE='skycoin');
  
}

attr(`GoInterface_t_set`, 'returnType') = 'void'
attr(`GoInterface_t_set`, "inputTypes") = c('_p_GoInterface', '_p_void')
class(`GoInterface_t_set`) = c("SWIGFunction", class('GoInterface_t_set'))

# Start of GoInterface_t_get

`GoInterface_t_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GoInterface_t_get', self, PACKAGE='skycoin');
  ans <- new("_p_void", ref=ans) ;
  
  ans
  
}

attr(`GoInterface_t_get`, 'returnType') = '_p_void'
attr(`GoInterface_t_get`, "inputTypes") = c('_p_GoInterface')
class(`GoInterface_t_get`) = c("SWIGFunction", class('GoInterface_t_get'))

# Start of GoInterface_v_set

`GoInterface_v_set` = function(self, s_v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_v, "ExternalReference")) s_v = slot(s_v,"ref") 
  ;.Call('R_swig_GoInterface_v_set', self, s_v, PACKAGE='skycoin');
  
}

attr(`GoInterface_v_set`, 'returnType') = 'void'
attr(`GoInterface_v_set`, "inputTypes") = c('_p_GoInterface', '_p_void')
class(`GoInterface_v_set`) = c("SWIGFunction", class('GoInterface_v_set'))

# Start of GoInterface_v_get

`GoInterface_v_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GoInterface_v_get', self, PACKAGE='skycoin');
  ans <- new("_p_void", ref=ans) ;
  
  ans
  
}

attr(`GoInterface_v_get`, 'returnType') = '_p_void'
attr(`GoInterface_v_get`, "inputTypes") = c('_p_GoInterface')
class(`GoInterface_v_get`) = c("SWIGFunction", class('GoInterface_v_get'))

# Start of new_GoInterface

`GoInterface` = function()
{
  ;ans = .Call('R_swig_new_GoInterface', PACKAGE='skycoin');
  ans <- new("_p_GoInterface", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_GoInterface)
  ans
  
}

attr(`GoInterface`, 'returnType') = '_p_GoInterface'
class(`GoInterface`) = c("SWIGFunction", class('GoInterface'))

# Start of delete_GoInterface

`delete_GoInterface` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GoInterface', self, PACKAGE='skycoin');
  
}

attr(`delete_GoInterface`, 'returnType') = 'void'
attr(`delete_GoInterface`, "inputTypes") = c('_p_GoInterface')
class(`delete_GoInterface`) = c("SWIGFunction", class('delete_GoInterface'))

# Start of accessor method for GoInterface
setMethod('$', '_p_GoInterface', function(x, name)

{
  accessorFuns = list('t' = GoInterface_t_get, 'v' = GoInterface_v_get);
  vaccessors = c('t', 'v');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GoInterface
# Start of accessor method for GoInterface
setMethod('$<-', '_p_GoInterface', function(x, name, value)

{
  accessorFuns = list('t' = GoInterface_t_set, 'v' = GoInterface_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GoInterface', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('t' = GoInterface_t_set, 'v' = GoInterface_v_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GoInterface
setMethod('delete', '_p_GoInterface', function(obj) {delete_GoInterface(obj)})
# Start definition of copy functions & methods for GoInterface
CopyToR_GoInterface = function(value, obj = new("GoInterface"))
{
  obj;
}



CopyToC_GoInterface = function(value, obj)
{
  obj
}



# Start definition of copy methods for GoInterface
setMethod('copyToR', '_p_GoInterface', CopyToR_GoInterface);
setMethod('copyToC', 'GoInterface', CopyToC_GoInterface);

# End definition of copy methods for GoInterface
# End definition of copy functions & methods for GoInterface
# Start of GoSlice_data_set

`GoSlice_data_set` = function(self, s_data)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_data, "ExternalReference")) s_data = slot(s_data,"ref") 
  ;.Call('R_swig_GoSlice_data_set', self, s_data, PACKAGE='skycoin');
  
}

attr(`GoSlice_data_set`, 'returnType') = 'void'
attr(`GoSlice_data_set`, "inputTypes") = c('_p_GoSlice', '_p_void')
class(`GoSlice_data_set`) = c("SWIGFunction", class('GoSlice_data_set'))

# Start of GoSlice_data_get

`GoSlice_data_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_GoSlice_data_get', self, PACKAGE='skycoin');
  ans <- new("_p_void", ref=ans) ;
  
  ans
  
}

attr(`GoSlice_data_get`, 'returnType') = '_p_void'
attr(`GoSlice_data_get`, "inputTypes") = c('_p_GoSlice')
class(`GoSlice_data_get`) = c("SWIGFunction", class('GoSlice_data_get'))

# Start of GoSlice_len_set

`GoSlice_len_set` = function(self, s_len)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_len = as.integer(s_len);
  
  if(length(s_len) > 1) {
    warning("using only the first element of s_len");
  };
  
  ;.Call('R_swig_GoSlice_len_set', self, s_len, PACKAGE='skycoin');
  
}

attr(`GoSlice_len_set`, 'returnType') = 'void'
attr(`GoSlice_len_set`, "inputTypes") = c('_p_GoSlice', 'integer')
class(`GoSlice_len_set`) = c("SWIGFunction", class('GoSlice_len_set'))

# Start of GoSlice_len_get

`GoSlice_len_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GoSlice_len_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`GoSlice_len_get`, 'returnType') = 'integer'
attr(`GoSlice_len_get`, "inputTypes") = c('_p_GoSlice')
class(`GoSlice_len_get`) = c("SWIGFunction", class('GoSlice_len_get'))

# Start of GoSlice_cap_set

`GoSlice_cap_set` = function(self, s_cap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_cap = as.integer(s_cap);
  
  if(length(s_cap) > 1) {
    warning("using only the first element of s_cap");
  };
  
  ;.Call('R_swig_GoSlice_cap_set', self, s_cap, PACKAGE='skycoin');
  
}

attr(`GoSlice_cap_set`, 'returnType') = 'void'
attr(`GoSlice_cap_set`, "inputTypes") = c('_p_GoSlice', 'integer')
class(`GoSlice_cap_set`) = c("SWIGFunction", class('GoSlice_cap_set'))

# Start of GoSlice_cap_get

`GoSlice_cap_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GoSlice_cap_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`GoSlice_cap_get`, 'returnType') = 'integer'
attr(`GoSlice_cap_get`, "inputTypes") = c('_p_GoSlice')
class(`GoSlice_cap_get`) = c("SWIGFunction", class('GoSlice_cap_get'))

# Start of new_GoSlice

`GoSlice` = function()
{
  ;ans = .Call('R_swig_new_GoSlice', PACKAGE='skycoin');
  ans <- new("_p_GoSlice", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_GoSlice)
  ans
  
}

attr(`GoSlice`, 'returnType') = '_p_GoSlice'
class(`GoSlice`) = c("SWIGFunction", class('GoSlice'))

# Start of delete_GoSlice

`delete_GoSlice` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GoSlice', self, PACKAGE='skycoin');
  
}

attr(`delete_GoSlice`, 'returnType') = 'void'
attr(`delete_GoSlice`, "inputTypes") = c('_p_GoSlice')
class(`delete_GoSlice`) = c("SWIGFunction", class('delete_GoSlice'))

# Start of accessor method for GoSlice
setMethod('$', '_p_GoSlice', function(x, name)

{
  accessorFuns = list('data' = GoSlice_data_get, 'len' = GoSlice_len_get, 'cap' = GoSlice_cap_get);
  vaccessors = c('data', 'len', 'cap');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for GoSlice
# Start of accessor method for GoSlice
setMethod('$<-', '_p_GoSlice', function(x, name, value)

{
  accessorFuns = list('data' = GoSlice_data_set, 'len' = GoSlice_len_set, 'cap' = GoSlice_cap_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_GoSlice', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('data' = GoSlice_data_set, 'len' = GoSlice_len_set, 'cap' = GoSlice_cap_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for GoSlice
setMethod('delete', '_p_GoSlice', function(obj) {delete_GoSlice(obj)})
# Start definition of copy functions & methods for GoSlice
CopyToR_GoSlice = function(value, obj = new("GoSlice"))
{
  obj@len = value$len;
  obj@cap = value$cap;
  obj;
}



CopyToC_GoSlice = function(value, obj)
{
  obj$len = value@len;
  obj$cap = value@cap;
  obj
}



# Start definition of copy methods for GoSlice
setMethod('copyToR', '_p_GoSlice', CopyToR_GoSlice);
setMethod('copyToC', 'GoSlice', CopyToC_GoSlice);

# End definition of copy methods for GoSlice
# End definition of copy functions & methods for GoSlice
# Start of SKY_wallet_CryptoTypeFromString

`SKY_wallet_CryptoTypeFromString` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_CryptoTypeFromString', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_CryptoTypeFromString`, 'returnType') = 'integer'
attr(`SKY_wallet_CryptoTypeFromString`, "inputTypes") = c('_p__GoString_', '_p_GoString_')
class(`SKY_wallet_CryptoTypeFromString`) = c("SWIGFunction", class('SKY_wallet_CryptoTypeFromString'))

# Start of SKY_coin_Create_Transaction

`SKY_coin_Create_Transaction` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_coin_Create_Transaction', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Create_Transaction`, 'returnType') = 'integer'
attr(`SKY_coin_Create_Transaction`, "inputTypes") = c('_p_Transaction__Handle')
class(`SKY_coin_Create_Transaction`) = c("SWIGFunction", class('SKY_coin_Create_Transaction'))

# Start of SKY_coin_Transaction_Copy

`SKY_coin_Transaction_Copy` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_Copy', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_Copy`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_Copy`, "inputTypes") = c('_p_Transaction__Handle', '_p_Transaction__Handle')
class(`SKY_coin_Transaction_Copy`) = c("SWIGFunction", class('SKY_coin_Transaction_Copy'))

# Start of SKY_coin_GetTransactionObject

`SKY_coin_GetTransactionObject` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_GetTransactionObject', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_GetTransactionObject`, 'returnType') = 'integer'
attr(`SKY_coin_GetTransactionObject`, "inputTypes") = c('_p_Transaction__Handle', '_p_p_coin__Transaction')
class(`SKY_coin_GetTransactionObject`) = c("SWIGFunction", class('SKY_coin_GetTransactionObject'))

# Start of SKY_coin_Transaction_ResetInputs

`SKY_coin_Transaction_ResetInputs` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  ;.Call('R_swig_SKY_coin_Transaction_ResetInputs', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_ResetInputs`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_ResetInputs`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_ResetInputs`) = c("SWIGFunction", class('SKY_coin_Transaction_ResetInputs'))

# Start of SKY_coin_Transaction_GetInputsCount

`SKY_coin_Transaction_GetInputsCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Transaction_GetInputsCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_GetInputsCount`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_GetInputsCount`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_GetInputsCount`) = c("SWIGFunction", class('SKY_coin_Transaction_GetInputsCount'))

# Start of SKY_coin_Transaction_GetInputAt

`SKY_coin_Transaction_GetInputAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_GetInputAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_GetInputAt`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_GetInputAt`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_a_32__GoUint8_')
class(`SKY_coin_Transaction_GetInputAt`) = c("SWIGFunction", class('SKY_coin_Transaction_GetInputAt'))

# Start of SKY_coin_Transaction_SetInputAt

`SKY_coin_Transaction_SetInputAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_SetInputAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_SetInputAt`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_SetInputAt`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_a_32__GoUint8_')
class(`SKY_coin_Transaction_SetInputAt`) = c("SWIGFunction", class('SKY_coin_Transaction_SetInputAt'))

# Start of SKY_coin_Transaction_GetOutputsCount

`SKY_coin_Transaction_GetOutputsCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Transaction_GetOutputsCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_GetOutputsCount`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_GetOutputsCount`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_GetOutputsCount`) = c("SWIGFunction", class('SKY_coin_Transaction_GetOutputsCount'))

# Start of SKY_coin_Transaction_GetOutputAt

`SKY_coin_Transaction_GetOutputAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_GetOutputAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_GetOutputAt`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_GetOutputAt`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_coin__TransactionOutput')
class(`SKY_coin_Transaction_GetOutputAt`) = c("SWIGFunction", class('SKY_coin_Transaction_GetOutputAt'))

# Start of SKY_coin_Transaction_SetOutputAt

`SKY_coin_Transaction_SetOutputAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_SetOutputAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_SetOutputAt`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_SetOutputAt`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_coin__TransactionOutput')
class(`SKY_coin_Transaction_SetOutputAt`) = c("SWIGFunction", class('SKY_coin_Transaction_SetOutputAt'))

# Start of SKY_coin_Transaction_GetSignaturesCount

`SKY_coin_Transaction_GetSignaturesCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Transaction_GetSignaturesCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_GetSignaturesCount`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_GetSignaturesCount`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_GetSignaturesCount`) = c("SWIGFunction", class('SKY_coin_Transaction_GetSignaturesCount'))

# Start of SKY_coin_Transaction_GetSignatureAt

`SKY_coin_Transaction_GetSignatureAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_GetSignatureAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_GetSignatureAt`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_GetSignatureAt`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_a_65__GoUint8_')
class(`SKY_coin_Transaction_GetSignatureAt`) = c("SWIGFunction", class('SKY_coin_Transaction_GetSignatureAt'))

# Start of SKY_coin_Transaction_SetSignatureAt

`SKY_coin_Transaction_SetSignatureAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_SetSignatureAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_SetSignatureAt`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_SetSignatureAt`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_a_65__GoUint8_')
class(`SKY_coin_Transaction_SetSignatureAt`) = c("SWIGFunction", class('SKY_coin_Transaction_SetSignatureAt'))

# Start of SKY_coin_Transaction_PushSignature

`SKY_coin_Transaction_PushSignature` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_PushSignature', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_PushSignature`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_PushSignature`, "inputTypes") = c('_p_Transaction__Handle', '_p_a_65__GoUint8_')
class(`SKY_coin_Transaction_PushSignature`) = c("SWIGFunction", class('SKY_coin_Transaction_PushSignature'))

# Start of SKY_coin_Transaction_ResetOutputs

`SKY_coin_Transaction_ResetOutputs` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  ;.Call('R_swig_SKY_coin_Transaction_ResetOutputs', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_ResetOutputs`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_ResetOutputs`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_ResetOutputs`) = c("SWIGFunction", class('SKY_coin_Transaction_ResetOutputs'))

# Start of SKY_coin_Transaction_ResetSignatures

`SKY_coin_Transaction_ResetSignatures` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  ;.Call('R_swig_SKY_coin_Transaction_ResetSignatures', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_ResetSignatures`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_ResetSignatures`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_ResetSignatures`) = c("SWIGFunction", class('SKY_coin_Transaction_ResetSignatures'))

# Start of SKY_coin_Transaction_Verify

`SKY_coin_Transaction_Verify` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_Verify', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_Verify`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_Verify`, "inputTypes") = c('_p_Transaction__Handle')
class(`SKY_coin_Transaction_Verify`) = c("SWIGFunction", class('SKY_coin_Transaction_Verify'))

# Start of SKY_coin_Transaction_VerifyInput

`SKY_coin_Transaction_VerifyInput` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_VerifyInput', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_VerifyInput`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_VerifyInput`, "inputTypes") = c('_p_Transaction__Handle', '_p_GoSlice_')
class(`SKY_coin_Transaction_VerifyInput`) = c("SWIGFunction", class('SKY_coin_Transaction_VerifyInput'))

# Start of SKY_coin_Transaction_PushInput

`SKY_coin_Transaction_PushInput` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_coin_Transaction_PushInput', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_PushInput`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_PushInput`, "inputTypes") = c('_p_Transaction__Handle', '_p_a_32__GoUint8_', 'integer')
class(`SKY_coin_Transaction_PushInput`) = c("SWIGFunction", class('SKY_coin_Transaction_PushInput'))

# Start of SKY_coin_TransactionOutput_UxID

`SKY_coin_TransactionOutput_UxID` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_TransactionOutput_UxID', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_TransactionOutput_UxID`, 'returnType') = 'integer'
attr(`SKY_coin_TransactionOutput_UxID`, "inputTypes") = c('_p_coin__TransactionOutput', '_p_a_32__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_coin_TransactionOutput_UxID`) = c("SWIGFunction", class('SKY_coin_TransactionOutput_UxID'))

# Start of SKY_coin_Transaction_PushOutput

`SKY_coin_Transaction_PushOutput` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  p3 = as.integer(p3);
  
  if(length(p3) > 1) {
    warning("using only the first element of p3");
  };
  
  ;.Call('R_swig_SKY_coin_Transaction_PushOutput', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_PushOutput`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_PushOutput`, "inputTypes") = c('_p_Transaction__Handle', '_p_cipher__Address', 'integer', 'integer')
class(`SKY_coin_Transaction_PushOutput`) = c("SWIGFunction", class('SKY_coin_Transaction_PushOutput'))

# Start of SKY_coin_Transaction_SignInputs

`SKY_coin_Transaction_SignInputs` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_SignInputs', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_SignInputs`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_SignInputs`, "inputTypes") = c('_p_Transaction__Handle', '_p_GoSlice')
class(`SKY_coin_Transaction_SignInputs`) = c("SWIGFunction", class('SKY_coin_Transaction_SignInputs'))

# Start of SKY_coin_Transaction_Size

`SKY_coin_Transaction_Size` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Transaction_Size', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_Size`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_Size`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_Size`) = c("SWIGFunction", class('SKY_coin_Transaction_Size'))

# Start of SKY_coin_Transaction_Hash

`SKY_coin_Transaction_Hash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_Hash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_Hash`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_Hash`, "inputTypes") = c('_p_Transaction__Handle', '_p_a_32__GoUint8_')
class(`SKY_coin_Transaction_Hash`) = c("SWIGFunction", class('SKY_coin_Transaction_Hash'))

# Start of SKY_coin_Transaction_SizeHash

`SKY_coin_Transaction_SizeHash` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_SizeHash', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_SizeHash`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_SizeHash`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_a_32__GoUint8_')
class(`SKY_coin_Transaction_SizeHash`) = c("SWIGFunction", class('SKY_coin_Transaction_SizeHash'))

# Start of SKY_coin_Transaction_TxID

`SKY_coin_Transaction_TxID` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_TxID', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_TxID`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_TxID`, "inputTypes") = c('_p_Transaction__Handle', '_p_GoSlice_')
class(`SKY_coin_Transaction_TxID`) = c("SWIGFunction", class('SKY_coin_Transaction_TxID'))

# Start of SKY_coin_Transaction_TxIDHex

`SKY_coin_Transaction_TxIDHex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_TxIDHex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_TxIDHex`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_TxIDHex`, "inputTypes") = c('_p_Transaction__Handle', '_p_GoString_')
class(`SKY_coin_Transaction_TxIDHex`) = c("SWIGFunction", class('SKY_coin_Transaction_TxIDHex'))

# Start of SKY_coin_Transaction_UpdateHeader

`SKY_coin_Transaction_UpdateHeader` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_UpdateHeader', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_UpdateHeader`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_UpdateHeader`, "inputTypes") = c('_p_Transaction__Handle')
class(`SKY_coin_Transaction_UpdateHeader`) = c("SWIGFunction", class('SKY_coin_Transaction_UpdateHeader'))

# Start of SKY_coin_Transaction_HashInner

`SKY_coin_Transaction_HashInner` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_HashInner', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_HashInner`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_HashInner`, "inputTypes") = c('_p_Transaction__Handle', '_p_a_32__GoUint8_')
class(`SKY_coin_Transaction_HashInner`) = c("SWIGFunction", class('SKY_coin_Transaction_HashInner'))

# Start of SKY_coin_Transaction_Serialize

`SKY_coin_Transaction_Serialize` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transaction_Serialize', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_Serialize`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_Serialize`, "inputTypes") = c('_p_Transaction__Handle', '_p_GoSlice_')
class(`SKY_coin_Transaction_Serialize`) = c("SWIGFunction", class('SKY_coin_Transaction_Serialize'))

# Start of SKY_coin_TransactionDeserialize

`SKY_coin_TransactionDeserialize` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_TransactionDeserialize', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_TransactionDeserialize`, 'returnType') = 'integer'
attr(`SKY_coin_TransactionDeserialize`, "inputTypes") = c('_p_GoSlice', '_p_Transaction__Handle')
class(`SKY_coin_TransactionDeserialize`) = c("SWIGFunction", class('SKY_coin_TransactionDeserialize'))

# Start of SKY_coin_Transaction_OutputHours

`SKY_coin_Transaction_OutputHours` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Transaction_OutputHours', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transaction_OutputHours`, 'returnType') = 'integer'
attr(`SKY_coin_Transaction_OutputHours`, "inputTypes") = c('_p_Transaction__Handle', 'integer')
class(`SKY_coin_Transaction_OutputHours`) = c("SWIGFunction", class('SKY_coin_Transaction_OutputHours'))

# Start of SKY_coin_Create_Transactions

`SKY_coin_Create_Transactions` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_coin_Create_Transactions', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Create_Transactions`, 'returnType') = 'integer'
attr(`SKY_coin_Create_Transactions`, "inputTypes") = c('_p_Transactions__Handle')
class(`SKY_coin_Create_Transactions`) = c("SWIGFunction", class('SKY_coin_Create_Transactions'))

# Start of SKY_coin_GetTransactionsObject

`SKY_coin_GetTransactionsObject` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_GetTransactionsObject', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_GetTransactionsObject`, 'returnType') = 'integer'
attr(`SKY_coin_GetTransactionsObject`, "inputTypes") = c('_p_Transactions__Handle', '_p_p_GoSlice_')
class(`SKY_coin_GetTransactionsObject`) = c("SWIGFunction", class('SKY_coin_GetTransactionsObject'))

# Start of SKY_coin_Transactions_Length

`SKY_coin_Transactions_Length` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Transactions_Length', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transactions_Length`, 'returnType') = 'integer'
attr(`SKY_coin_Transactions_Length`, "inputTypes") = c('_p_Transactions__Handle', 'integer')
class(`SKY_coin_Transactions_Length`) = c("SWIGFunction", class('SKY_coin_Transactions_Length'))

# Start of SKY_coin_Transactions_Add

`SKY_coin_Transactions_Add` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transactions_Add', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transactions_Add`, 'returnType') = 'integer'
attr(`SKY_coin_Transactions_Add`, "inputTypes") = c('_p_Transactions__Handle', '_p_Transaction__Handle')
class(`SKY_coin_Transactions_Add`) = c("SWIGFunction", class('SKY_coin_Transactions_Add'))

# Start of SKY_coin_Transactions_Fees

`SKY_coin_Transactions_Fees` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_coin_Transactions_Fees', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transactions_Fees`, 'returnType') = 'integer'
attr(`SKY_coin_Transactions_Fees`, "inputTypes") = c('_p_Transactions__Handle', '_p_FeeCalculator', 'integer')
class(`SKY_coin_Transactions_Fees`) = c("SWIGFunction", class('SKY_coin_Transactions_Fees'))

# Start of SKY_coin_Transactions_GetAt

`SKY_coin_Transactions_GetAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transactions_GetAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transactions_GetAt`, 'returnType') = 'integer'
attr(`SKY_coin_Transactions_GetAt`, "inputTypes") = c('_p_Transactions__Handle', 'integer', '_p_Transaction__Handle')
class(`SKY_coin_Transactions_GetAt`) = c("SWIGFunction", class('SKY_coin_Transactions_GetAt'))

# Start of SKY_coin_Transactions_Hashes

`SKY_coin_Transactions_Hashes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Transactions_Hashes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transactions_Hashes`, 'returnType') = 'integer'
attr(`SKY_coin_Transactions_Hashes`, "inputTypes") = c('_p_Transactions__Handle', '_p_GoSlice_')
class(`SKY_coin_Transactions_Hashes`) = c("SWIGFunction", class('SKY_coin_Transactions_Hashes'))

# Start of SKY_coin_Transactions_Size

`SKY_coin_Transactions_Size` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Transactions_Size', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transactions_Size`, 'returnType') = 'integer'
attr(`SKY_coin_Transactions_Size`, "inputTypes") = c('_p_Transactions__Handle', 'integer')
class(`SKY_coin_Transactions_Size`) = c("SWIGFunction", class('SKY_coin_Transactions_Size'))

# Start of SKY_coin_Transactions_TruncateBytesTo

`SKY_coin_Transactions_TruncateBytesTo` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_Transactions_TruncateBytesTo', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Transactions_TruncateBytesTo`, 'returnType') = 'integer'
attr(`SKY_coin_Transactions_TruncateBytesTo`, "inputTypes") = c('_p_Transactions__Handle', 'integer', '_p_Transactions__Handle')
class(`SKY_coin_Transactions_TruncateBytesTo`) = c("SWIGFunction", class('SKY_coin_Transactions_TruncateBytesTo'))

# Start of SKY_coin_SortTransactions

`SKY_coin_SortTransactions` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_SortTransactions', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_SortTransactions`, 'returnType') = 'integer'
attr(`SKY_coin_SortTransactions`, "inputTypes") = c('_p_Transactions__Handle', '_p_FeeCalculator', '_p_Transactions__Handle')
class(`SKY_coin_SortTransactions`) = c("SWIGFunction", class('SKY_coin_SortTransactions'))

# Start of SKY_coin_NewSortableTransactions

`SKY_coin_NewSortableTransactions` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_NewSortableTransactions', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_NewSortableTransactions`, 'returnType') = 'integer'
attr(`SKY_coin_NewSortableTransactions`, "inputTypes") = c('_p_Transactions__Handle', '_p_FeeCalculator', '_p_SortableTransactionResult_Handle')
class(`SKY_coin_NewSortableTransactions`) = c("SWIGFunction", class('SKY_coin_NewSortableTransactions'))

# Start of SKY_coin_SortableTransactions_Sort

`SKY_coin_SortableTransactions_Sort` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_coin_SortableTransactions_Sort', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_SortableTransactions_Sort`, 'returnType') = 'integer'
attr(`SKY_coin_SortableTransactions_Sort`, "inputTypes") = c('_p_SortableTransactionResult_Handle')
class(`SKY_coin_SortableTransactions_Sort`) = c("SWIGFunction", class('SKY_coin_SortableTransactions_Sort'))

# Start of SKY_coin_SortableTransactions_Len

`SKY_coin_SortableTransactions_Len` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_SortableTransactions_Len', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_SortableTransactions_Len`, 'returnType') = 'integer'
attr(`SKY_coin_SortableTransactions_Len`, "inputTypes") = c('_p_SortableTransactionResult_Handle', 'integer')
class(`SKY_coin_SortableTransactions_Len`) = c("SWIGFunction", class('SKY_coin_SortableTransactions_Len'))

# Start of SKY_coin_SortableTransactions_Less

`SKY_coin_SortableTransactions_Less` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  p3 = as.integer(p3);
  ;.Call('R_swig_SKY_coin_SortableTransactions_Less', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_SortableTransactions_Less`, 'returnType') = 'integer'
attr(`SKY_coin_SortableTransactions_Less`, "inputTypes") = c('_p_SortableTransactionResult_Handle', 'integer', 'integer', 'integer')
class(`SKY_coin_SortableTransactions_Less`) = c("SWIGFunction", class('SKY_coin_SortableTransactions_Less'))

# Start of SKY_coin_SortableTransactions_Swap

`SKY_coin_SortableTransactions_Swap` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  ;.Call('R_swig_SKY_coin_SortableTransactions_Swap', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_SortableTransactions_Swap`, 'returnType') = 'integer'
attr(`SKY_coin_SortableTransactions_Swap`, "inputTypes") = c('_p_SortableTransactionResult_Handle', 'integer', 'integer')
class(`SKY_coin_SortableTransactions_Swap`) = c("SWIGFunction", class('SKY_coin_SortableTransactions_Swap'))

# Start of SKY_coin_VerifyTransactionCoinsSpending

`SKY_coin_VerifyTransactionCoinsSpending` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_VerifyTransactionCoinsSpending', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_VerifyTransactionCoinsSpending`, 'returnType') = 'integer'
attr(`SKY_coin_VerifyTransactionCoinsSpending`, "inputTypes") = c('_p_GoSlice_', '_p_GoSlice_')
class(`SKY_coin_VerifyTransactionCoinsSpending`) = c("SWIGFunction", class('SKY_coin_VerifyTransactionCoinsSpending'))

# Start of SKY_coin_VerifyTransactionHoursSpending

`SKY_coin_VerifyTransactionHoursSpending` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_VerifyTransactionHoursSpending', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_VerifyTransactionHoursSpending`, 'returnType') = 'integer'
attr(`SKY_coin_VerifyTransactionHoursSpending`, "inputTypes") = c('integer', '_p_GoSlice_', '_p_GoSlice_')
class(`SKY_coin_VerifyTransactionHoursSpending`) = c("SWIGFunction", class('SKY_coin_VerifyTransactionHoursSpending'))

# Start of SKY_encrypt_ScryptChacha20poly1305_Encrypt

`SKY_encrypt_ScryptChacha20poly1305_Encrypt` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_encrypt_ScryptChacha20poly1305_Encrypt', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_encrypt_ScryptChacha20poly1305_Encrypt`, 'returnType') = 'integer'
attr(`SKY_encrypt_ScryptChacha20poly1305_Encrypt`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305', '_p_GoSlice', '_p_GoSlice', '_p_GoSlice_')
class(`SKY_encrypt_ScryptChacha20poly1305_Encrypt`) = c("SWIGFunction", class('SKY_encrypt_ScryptChacha20poly1305_Encrypt'))

# Start of SKY_encrypt_ScryptChacha20poly1305_Decrypt

`SKY_encrypt_ScryptChacha20poly1305_Decrypt` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_encrypt_ScryptChacha20poly1305_Decrypt', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_encrypt_ScryptChacha20poly1305_Decrypt`, 'returnType') = 'integer'
attr(`SKY_encrypt_ScryptChacha20poly1305_Decrypt`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305', '_p_GoSlice', '_p_GoSlice', '_p_GoSlice_')
class(`SKY_encrypt_ScryptChacha20poly1305_Decrypt`) = c("SWIGFunction", class('SKY_encrypt_ScryptChacha20poly1305_Decrypt'))

# Start of SKY_cli_LoadConfig

`SKY_cli_LoadConfig` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cli_LoadConfig', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_LoadConfig`, 'returnType') = 'integer'
attr(`SKY_cli_LoadConfig`, "inputTypes") = c('_p_Config__Handle')
class(`SKY_cli_LoadConfig`) = c("SWIGFunction", class('SKY_cli_LoadConfig'))

# Start of SKY_cli_Config_FullWalletPath

`SKY_cli_Config_FullWalletPath` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_Config_FullWalletPath', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_Config_FullWalletPath`, 'returnType') = 'integer'
attr(`SKY_cli_Config_FullWalletPath`, "inputTypes") = c('_p_Config__Handle', '_p_GoString_')
class(`SKY_cli_Config_FullWalletPath`) = c("SWIGFunction", class('SKY_cli_Config_FullWalletPath'))

# Start of SKY_cli_Config_FullDBPath

`SKY_cli_Config_FullDBPath` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_Config_FullDBPath', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_Config_FullDBPath`, 'returnType') = 'integer'
attr(`SKY_cli_Config_FullDBPath`, "inputTypes") = c('_p_Config__Handle', '_p_GoString_')
class(`SKY_cli_Config_FullDBPath`) = c("SWIGFunction", class('SKY_cli_Config_FullDBPath'))

# Start of SKY_cli_NewCLI

`SKY_cli_NewCLI` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_NewCLI', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_NewCLI`, 'returnType') = 'integer'
attr(`SKY_cli_NewCLI`, "inputTypes") = c('_p_Config__Handle', '_p_CLI__Handle')
class(`SKY_cli_NewCLI`) = c("SWIGFunction", class('SKY_cli_NewCLI'))

# Start of SKY_cli_NewPasswordReader

`SKY_cli_NewPasswordReader` = function(p0, p1)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_NewPasswordReader', p0, p1, PACKAGE='skycoin');
  
}

attr(`SKY_cli_NewPasswordReader`, 'returnType') = 'void'
attr(`SKY_cli_NewPasswordReader`, "inputTypes") = c('_p_GoSlice', '_p_PasswordReader__Handle')
class(`SKY_cli_NewPasswordReader`) = c("SWIGFunction", class('SKY_cli_NewPasswordReader'))

# Start of SKY_cli_PasswordFromBytes_Password

`SKY_cli_PasswordFromBytes_Password` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_PasswordFromBytes_Password', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_PasswordFromBytes_Password`, 'returnType') = 'integer'
attr(`SKY_cli_PasswordFromBytes_Password`, "inputTypes") = c('_p_GoSlice_', '_p_GoSlice_')
class(`SKY_cli_PasswordFromBytes_Password`) = c("SWIGFunction", class('SKY_cli_PasswordFromBytes_Password'))

# Start of SKY_cli_PasswordFromTerm_Password

`SKY_cli_PasswordFromTerm_Password` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cli_PasswordFromTerm_Password', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_PasswordFromTerm_Password`, 'returnType') = 'integer'
attr(`SKY_cli_PasswordFromTerm_Password`, "inputTypes") = c('_p_GoSlice_')
class(`SKY_cli_PasswordFromTerm_Password`) = c("SWIGFunction", class('SKY_cli_PasswordFromTerm_Password'))

# Start of SKY_cli_GenerateWallet

`SKY_cli_GenerateWallet` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_cli_GenerateWallet', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_GenerateWallet`, 'returnType') = 'integer'
attr(`SKY_cli_GenerateWallet`, "inputTypes") = c('_p__GoString_', '_p_Options__Handle', 'integer', '_p_Wallet__Handle')
class(`SKY_cli_GenerateWallet`) = c("SWIGFunction", class('SKY_cli_GenerateWallet'))

# Start of SKY_cli_MakeAlphanumericSeed

`SKY_cli_MakeAlphanumericSeed` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cli_MakeAlphanumericSeed', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_MakeAlphanumericSeed`, 'returnType') = 'integer'
attr(`SKY_cli_MakeAlphanumericSeed`, "inputTypes") = c('_p_GoString_')
class(`SKY_cli_MakeAlphanumericSeed`) = c("SWIGFunction", class('SKY_cli_MakeAlphanumericSeed'))

# Start of SKY_cli_CheckWalletBalance

`SKY_cli_CheckWalletBalance` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cli_CheckWalletBalance', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_CheckWalletBalance`, 'returnType') = 'integer'
attr(`SKY_cli_CheckWalletBalance`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p__GoString_', '_p_BalanceResult_Handle')
class(`SKY_cli_CheckWalletBalance`) = c("SWIGFunction", class('SKY_cli_CheckWalletBalance'))

# Start of SKY_cli_GetBalanceOfAddresses

`SKY_cli_GetBalanceOfAddresses` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cli_GetBalanceOfAddresses', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_GetBalanceOfAddresses`, 'returnType') = 'integer'
attr(`SKY_cli_GetBalanceOfAddresses`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_GoSlice', '_p_BalanceResult_Handle')
class(`SKY_cli_GetBalanceOfAddresses`) = c("SWIGFunction", class('SKY_cli_GetBalanceOfAddresses'))

# Start of SKY_cipher_RandByte

`SKY_cipher_RandByte` = function(p0, p1, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_RandByte', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_RandByte`, 'returnType') = 'integer'
attr(`SKY_cipher_RandByte`, "inputTypes") = c('integer', '_p_GoSlice_')
class(`SKY_cipher_RandByte`) = c("SWIGFunction", class('SKY_cipher_RandByte'))

# Start of SKY_cipher_NewPubKey

`SKY_cipher_NewPubKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_NewPubKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_NewPubKey`, 'returnType') = 'integer'
attr(`SKY_cipher_NewPubKey`, "inputTypes") = c('_p_GoSlice', '_p_a_33__GoUint8_')
class(`SKY_cipher_NewPubKey`) = c("SWIGFunction", class('SKY_cipher_NewPubKey'))

# Start of SKY_cipher_PubKeyFromHex

`SKY_cipher_PubKeyFromHex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_PubKeyFromHex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_PubKeyFromHex`, 'returnType') = 'integer'
attr(`SKY_cipher_PubKeyFromHex`, "inputTypes") = c('_p__GoString_', '_p_a_33__GoUint8_')
class(`SKY_cipher_PubKeyFromHex`) = c("SWIGFunction", class('SKY_cipher_PubKeyFromHex'))

# Start of SKY_cipher_PubKeyFromSecKey

`SKY_cipher_PubKeyFromSecKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_PubKeyFromSecKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_PubKeyFromSecKey`, 'returnType') = 'integer'
attr(`SKY_cipher_PubKeyFromSecKey`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_a_33__GoUint8_')
class(`SKY_cipher_PubKeyFromSecKey`) = c("SWIGFunction", class('SKY_cipher_PubKeyFromSecKey'))

# Start of SKY_cipher_PubKeyFromSig

`SKY_cipher_PubKeyFromSig` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_PubKeyFromSig', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_PubKeyFromSig`, 'returnType') = 'integer'
attr(`SKY_cipher_PubKeyFromSig`, "inputTypes") = c('_p_a_65__GoUint8_', '_p_a_32__GoUint8_', '_p_a_33__GoUint8_')
class(`SKY_cipher_PubKeyFromSig`) = c("SWIGFunction", class('SKY_cipher_PubKeyFromSig'))

# Start of SKY_cipher_PubKey_Verify

`SKY_cipher_PubKey_Verify` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cipher_PubKey_Verify', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_PubKey_Verify`, 'returnType') = 'integer'
attr(`SKY_cipher_PubKey_Verify`, "inputTypes") = c('_p_a_33__GoUint8_')
class(`SKY_cipher_PubKey_Verify`) = c("SWIGFunction", class('SKY_cipher_PubKey_Verify'))

# Start of SKY_cipher_PubKey_Hex

`SKY_cipher_PubKey_Hex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_PubKey_Hex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_PubKey_Hex`, 'returnType') = 'integer'
attr(`SKY_cipher_PubKey_Hex`, "inputTypes") = c('_p_a_33__GoUint8_', '_p_GoString_')
class(`SKY_cipher_PubKey_Hex`) = c("SWIGFunction", class('SKY_cipher_PubKey_Hex'))

# Start of SKY_cipher_PubKeyRipemd160

`SKY_cipher_PubKeyRipemd160` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_PubKeyRipemd160', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_PubKeyRipemd160`, 'returnType') = 'integer'
attr(`SKY_cipher_PubKeyRipemd160`, "inputTypes") = c('_p_a_33__GoUint8_', '_p_a_20__GoUint8_')
class(`SKY_cipher_PubKeyRipemd160`) = c("SWIGFunction", class('SKY_cipher_PubKeyRipemd160'))

# Start of SKY_cipher_NewSecKey

`SKY_cipher_NewSecKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_NewSecKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_NewSecKey`, 'returnType') = 'integer'
attr(`SKY_cipher_NewSecKey`, "inputTypes") = c('_p_GoSlice', '_p_a_32__GoUint8_')
class(`SKY_cipher_NewSecKey`) = c("SWIGFunction", class('SKY_cipher_NewSecKey'))

# Start of SKY_cipher_SecKeyFromHex

`SKY_cipher_SecKeyFromHex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SecKeyFromHex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SecKeyFromHex`, 'returnType') = 'integer'
attr(`SKY_cipher_SecKeyFromHex`, "inputTypes") = c('_p__GoString_', '_p_a_32__GoUint8_')
class(`SKY_cipher_SecKeyFromHex`) = c("SWIGFunction", class('SKY_cipher_SecKeyFromHex'))

# Start of SKY_cipher_SecKey_Verify

`SKY_cipher_SecKey_Verify` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cipher_SecKey_Verify', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SecKey_Verify`, 'returnType') = 'integer'
attr(`SKY_cipher_SecKey_Verify`, "inputTypes") = c('_p_a_32__GoUint8_')
class(`SKY_cipher_SecKey_Verify`) = c("SWIGFunction", class('SKY_cipher_SecKey_Verify'))

# Start of SKY_cipher_SecKey_Hex

`SKY_cipher_SecKey_Hex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SecKey_Hex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SecKey_Hex`, 'returnType') = 'integer'
attr(`SKY_cipher_SecKey_Hex`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_GoString_')
class(`SKY_cipher_SecKey_Hex`) = c("SWIGFunction", class('SKY_cipher_SecKey_Hex'))

# Start of SKY_cipher_ECDH

`SKY_cipher_ECDH` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_ECDH', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_ECDH`, 'returnType') = 'integer'
attr(`SKY_cipher_ECDH`, "inputTypes") = c('_p_a_33__GoUint8_', '_p_a_32__GoUint8_', '_p_GoSlice_')
class(`SKY_cipher_ECDH`) = c("SWIGFunction", class('SKY_cipher_ECDH'))

# Start of SKY_cipher_NewSig

`SKY_cipher_NewSig` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_NewSig', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_NewSig`, 'returnType') = 'integer'
attr(`SKY_cipher_NewSig`, "inputTypes") = c('_p_GoSlice', '_p_a_65__GoUint8_')
class(`SKY_cipher_NewSig`) = c("SWIGFunction", class('SKY_cipher_NewSig'))

# Start of SKY_cipher_SigFromHex

`SKY_cipher_SigFromHex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SigFromHex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SigFromHex`, 'returnType') = 'integer'
attr(`SKY_cipher_SigFromHex`, "inputTypes") = c('_p__GoString_', '_p_a_65__GoUint8_')
class(`SKY_cipher_SigFromHex`) = c("SWIGFunction", class('SKY_cipher_SigFromHex'))

# Start of SKY_cipher_Sig_Hex

`SKY_cipher_Sig_Hex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_Sig_Hex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Sig_Hex`, 'returnType') = 'integer'
attr(`SKY_cipher_Sig_Hex`, "inputTypes") = c('_p_a_65__GoUint8_', '_p_GoString_')
class(`SKY_cipher_Sig_Hex`) = c("SWIGFunction", class('SKY_cipher_Sig_Hex'))

# Start of SKY_cipher_SignHash

`SKY_cipher_SignHash` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_SignHash', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SignHash`, 'returnType') = 'integer'
attr(`SKY_cipher_SignHash`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_a_32__GoUint8_', '_p_a_65__GoUint8_')
class(`SKY_cipher_SignHash`) = c("SWIGFunction", class('SKY_cipher_SignHash'))

# Start of SKY_cipher_VerifyAddressSignedHash

`SKY_cipher_VerifyAddressSignedHash` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_VerifyAddressSignedHash', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_VerifyAddressSignedHash`, 'returnType') = 'integer'
attr(`SKY_cipher_VerifyAddressSignedHash`, "inputTypes") = c('_p_cipher__Address', '_p_a_65__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_VerifyAddressSignedHash`) = c("SWIGFunction", class('SKY_cipher_VerifyAddressSignedHash'))

# Start of SKY_cipher_VerifySignedHash

`SKY_cipher_VerifySignedHash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_VerifySignedHash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_VerifySignedHash`, 'returnType') = 'integer'
attr(`SKY_cipher_VerifySignedHash`, "inputTypes") = c('_p_a_65__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_VerifySignedHash`) = c("SWIGFunction", class('SKY_cipher_VerifySignedHash'))

# Start of SKY_cipher_VerifyPubKeySignedHash

`SKY_cipher_VerifyPubKeySignedHash` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_VerifyPubKeySignedHash', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_VerifyPubKeySignedHash`, 'returnType') = 'integer'
attr(`SKY_cipher_VerifyPubKeySignedHash`, "inputTypes") = c('_p_a_33__GoUint8_', '_p_a_65__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_VerifyPubKeySignedHash`) = c("SWIGFunction", class('SKY_cipher_VerifyPubKeySignedHash'))

# Start of SKY_cipher_GenerateKeyPair

`SKY_cipher_GenerateKeyPair` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_GenerateKeyPair', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_GenerateKeyPair`, 'returnType') = 'integer'
attr(`SKY_cipher_GenerateKeyPair`, "inputTypes") = c('_p_a_33__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_GenerateKeyPair`) = c("SWIGFunction", class('SKY_cipher_GenerateKeyPair'))

# Start of SKY_cipher_GenerateDeterministicKeyPair

`SKY_cipher_GenerateDeterministicKeyPair` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_GenerateDeterministicKeyPair', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_GenerateDeterministicKeyPair`, 'returnType') = 'integer'
attr(`SKY_cipher_GenerateDeterministicKeyPair`, "inputTypes") = c('_p_GoSlice', '_p_a_33__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_GenerateDeterministicKeyPair`) = c("SWIGFunction", class('SKY_cipher_GenerateDeterministicKeyPair'))

# Start of SKY_cipher_DeterministicKeyPairIterator

`SKY_cipher_DeterministicKeyPairIterator` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_cipher_DeterministicKeyPairIterator', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_DeterministicKeyPairIterator`, 'returnType') = 'integer'
attr(`SKY_cipher_DeterministicKeyPairIterator`, "inputTypes") = c('_p_GoSlice', '_p_GoSlice_', '_p_a_33__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_DeterministicKeyPairIterator`) = c("SWIGFunction", class('SKY_cipher_DeterministicKeyPairIterator'))

# Start of SKY_cipher_GenerateDeterministicKeyPairs

`SKY_cipher_GenerateDeterministicKeyPairs` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_GenerateDeterministicKeyPairs', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_GenerateDeterministicKeyPairs`, 'returnType') = 'integer'
attr(`SKY_cipher_GenerateDeterministicKeyPairs`, "inputTypes") = c('_p_GoSlice', 'integer', '_p_GoSlice_')
class(`SKY_cipher_GenerateDeterministicKeyPairs`) = c("SWIGFunction", class('SKY_cipher_GenerateDeterministicKeyPairs'))

# Start of SKY_cipher_GenerateDeterministicKeyPairsSeed

`SKY_cipher_GenerateDeterministicKeyPairsSeed` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_cipher_GenerateDeterministicKeyPairsSeed', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_GenerateDeterministicKeyPairsSeed`, 'returnType') = 'integer'
attr(`SKY_cipher_GenerateDeterministicKeyPairsSeed`, "inputTypes") = c('_p_GoSlice', 'integer', '_p_GoSlice_', '_p_GoSlice_')
class(`SKY_cipher_GenerateDeterministicKeyPairsSeed`) = c("SWIGFunction", class('SKY_cipher_GenerateDeterministicKeyPairsSeed'))

# Start of SKY_cipher_CheckSecKey

`SKY_cipher_CheckSecKey` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cipher_CheckSecKey', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_CheckSecKey`, 'returnType') = 'integer'
attr(`SKY_cipher_CheckSecKey`, "inputTypes") = c('_p_a_32__GoUint8_')
class(`SKY_cipher_CheckSecKey`) = c("SWIGFunction", class('SKY_cipher_CheckSecKey'))

# Start of SKY_cipher_CheckSecKeyHash

`SKY_cipher_CheckSecKeyHash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_CheckSecKeyHash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_CheckSecKeyHash`, 'returnType') = 'integer'
attr(`SKY_cipher_CheckSecKeyHash`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_CheckSecKeyHash`) = c("SWIGFunction", class('SKY_cipher_CheckSecKeyHash'))

# Start of SKY_map_Get

`SKY_map_Get` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_map_Get', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_map_Get`, 'returnType') = 'integer'
attr(`SKY_map_Get`, "inputTypes") = c('_p_GoStringMap_', '_p__GoString_', '_p_GoString_')
class(`SKY_map_Get`) = c("SWIGFunction", class('SKY_map_Get'))

# Start of SKY_map_HasKey

`SKY_map_HasKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_map_HasKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_map_HasKey`, 'returnType') = 'integer'
attr(`SKY_map_HasKey`, "inputTypes") = c('_p_GoStringMap_', '_p__GoString_')
class(`SKY_map_HasKey`) = c("SWIGFunction", class('SKY_map_HasKey'))

# Start of SKY_map_Close

`SKY_map_Close` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_map_Close', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_map_Close`, 'returnType') = 'integer'
attr(`SKY_map_Close`, "inputTypes") = c('_p_GoStringMap_')
class(`SKY_map_Close`) = c("SWIGFunction", class('SKY_map_Close'))

# Start of SKY_cli_GenerateAddressesInFile

`SKY_cli_GenerateAddressesInFile` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_cli_GenerateAddressesInFile', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_GenerateAddressesInFile`, 'returnType') = 'integer'
attr(`SKY_cli_GenerateAddressesInFile`, "inputTypes") = c('_p__GoString_', 'integer', '_p_PasswordReader__Handle', '_p_GoSlice_')
class(`SKY_cli_GenerateAddressesInFile`) = c("SWIGFunction", class('SKY_cli_GenerateAddressesInFile'))

# Start of SKY_cli_FormatAddressesAsJSON

`SKY_cli_FormatAddressesAsJSON` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_FormatAddressesAsJSON', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_FormatAddressesAsJSON`, 'returnType') = 'integer'
attr(`SKY_cli_FormatAddressesAsJSON`, "inputTypes") = c('_p_GoSlice', '_p_GoString_')
class(`SKY_cli_FormatAddressesAsJSON`) = c("SWIGFunction", class('SKY_cli_FormatAddressesAsJSON'))

# Start of SKY_cli_FormatAddressesAsJoinedArray

`SKY_cli_FormatAddressesAsJoinedArray` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_FormatAddressesAsJoinedArray', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_FormatAddressesAsJoinedArray`, 'returnType') = 'integer'
attr(`SKY_cli_FormatAddressesAsJoinedArray`, "inputTypes") = c('_p_GoSlice', '_p_GoString_')
class(`SKY_cli_FormatAddressesAsJoinedArray`) = c("SWIGFunction", class('SKY_cli_FormatAddressesAsJoinedArray'))

# Start of SKY_cli_AddressesToStrings

`SKY_cli_AddressesToStrings` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_AddressesToStrings', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_AddressesToStrings`, 'returnType') = 'integer'
attr(`SKY_cli_AddressesToStrings`, "inputTypes") = c('_p_GoSlice', '_p_GoSlice_')
class(`SKY_cli_AddressesToStrings`) = c("SWIGFunction", class('SKY_cli_AddressesToStrings'))

# Start of SKY_logging_EnableColors

`SKY_logging_EnableColors` = function(.copy = FALSE)
{
  ;.Call('R_swig_SKY_logging_EnableColors', as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_logging_EnableColors`, 'returnType') = 'integer'
class(`SKY_logging_EnableColors`) = c("SWIGFunction", class('SKY_logging_EnableColors'))

# Start of SKY_logging_DisableColors

`SKY_logging_DisableColors` = function(.copy = FALSE)
{
  ;.Call('R_swig_SKY_logging_DisableColors', as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_logging_DisableColors`, 'returnType') = 'integer'
class(`SKY_logging_DisableColors`) = c("SWIGFunction", class('SKY_logging_DisableColors'))

# Start of SKY_logging_Disable

`SKY_logging_Disable` = function(.copy = FALSE)
{
  ;.Call('R_swig_SKY_logging_Disable', as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_logging_Disable`, 'returnType') = 'integer'
class(`SKY_logging_Disable`) = c("SWIGFunction", class('SKY_logging_Disable'))

# Start of SKY_certutil_NewTLSCertPair

`SKY_certutil_NewTLSCertPair` = function(p0, p1, p2, p3, p4, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  ;.Call('R_swig_SKY_certutil_NewTLSCertPair', p0, p1, p2, p3, p4, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_certutil_NewTLSCertPair`, 'returnType') = 'integer'
attr(`SKY_certutil_NewTLSCertPair`, "inputTypes") = c('_p__GoString_', '_p__GoString_', '_p_GoSlice', '_p_GoSlice_', '_p_GoSlice_')
class(`SKY_certutil_NewTLSCertPair`) = c("SWIGFunction", class('SKY_certutil_NewTLSCertPair'))

# Start of SKY_api_NewWalletResponse

`SKY_api_NewWalletResponse` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_NewWalletResponse', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_NewWalletResponse`, 'returnType') = 'integer'
attr(`SKY_api_NewWalletResponse`, "inputTypes") = c('_p_Wallet__Handle', '_p_WalletResponse__Handle')
class(`SKY_api_NewWalletResponse`) = c("SWIGFunction", class('SKY_api_NewWalletResponse'))

# Start of SKY_apputil_CatchInterruptPanic

`SKY_apputil_CatchInterruptPanic` = function(.copy = FALSE)
{
  ;.Call('R_swig_SKY_apputil_CatchInterruptPanic', as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_apputil_CatchInterruptPanic`, 'returnType') = 'integer'
class(`SKY_apputil_CatchInterruptPanic`) = c("SWIGFunction", class('SKY_apputil_CatchInterruptPanic'))

# Start of SKY_apputil_CatchDebug

`SKY_apputil_CatchDebug` = function(.copy = FALSE)
{
  ;.Call('R_swig_SKY_apputil_CatchDebug', as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_apputil_CatchDebug`, 'returnType') = 'integer'
class(`SKY_apputil_CatchDebug`) = c("SWIGFunction", class('SKY_apputil_CatchDebug'))

# Start of SKY_apputil_PrintProgramStatus

`SKY_apputil_PrintProgramStatus` = function(.copy = FALSE)
{
  ;.Call('R_swig_SKY_apputil_PrintProgramStatus', as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_apputil_PrintProgramStatus`, 'returnType') = 'integer'
class(`SKY_apputil_PrintProgramStatus`) = c("SWIGFunction", class('SKY_apputil_PrintProgramStatus'))

# Start of SKY_params_DropletPrecisionToDivisor

`SKY_params_DropletPrecisionToDivisor` = function(p0, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  ;.Call('R_swig_SKY_params_DropletPrecisionToDivisor', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_params_DropletPrecisionToDivisor`, 'returnType') = 'integer'
attr(`SKY_params_DropletPrecisionToDivisor`, "inputTypes") = c('integer')
class(`SKY_params_DropletPrecisionToDivisor`) = c("SWIGFunction", class('SKY_params_DropletPrecisionToDivisor'))

# Start of SKY_params_DropletPrecisionCheck

`SKY_params_DropletPrecisionCheck` = function(p0, p1, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  ;.Call('R_swig_SKY_params_DropletPrecisionCheck', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_params_DropletPrecisionCheck`, 'returnType') = 'integer'
attr(`SKY_params_DropletPrecisionCheck`, "inputTypes") = c('integer', 'integer')
class(`SKY_params_DropletPrecisionCheck`) = c("SWIGFunction", class('SKY_params_DropletPrecisionCheck'))

# Start of SKY_cipher_DecodeBase58Address

`SKY_cipher_DecodeBase58Address` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_DecodeBase58Address', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_DecodeBase58Address`, 'returnType') = 'integer'
attr(`SKY_cipher_DecodeBase58Address`, "inputTypes") = c('_p__GoString_', '_p_cipher__Address')
class(`SKY_cipher_DecodeBase58Address`) = c("SWIGFunction", class('SKY_cipher_DecodeBase58Address'))

# Start of SKY_cipher_AddressFromBytes

`SKY_cipher_AddressFromBytes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_AddressFromBytes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_AddressFromBytes`, 'returnType') = 'integer'
attr(`SKY_cipher_AddressFromBytes`, "inputTypes") = c('_p_GoSlice', '_p_cipher__Address')
class(`SKY_cipher_AddressFromBytes`) = c("SWIGFunction", class('SKY_cipher_AddressFromBytes'))

# Start of SKY_cipher_AddressFromPubKey

`SKY_cipher_AddressFromPubKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_AddressFromPubKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_AddressFromPubKey`, 'returnType') = 'integer'
attr(`SKY_cipher_AddressFromPubKey`, "inputTypes") = c('_p_a_33__GoUint8_', '_p_cipher__Address')
class(`SKY_cipher_AddressFromPubKey`) = c("SWIGFunction", class('SKY_cipher_AddressFromPubKey'))

# Start of SKY_cipher_AddressFromSecKey

`SKY_cipher_AddressFromSecKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_AddressFromSecKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_AddressFromSecKey`, 'returnType') = 'integer'
attr(`SKY_cipher_AddressFromSecKey`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_cipher__Address')
class(`SKY_cipher_AddressFromSecKey`) = c("SWIGFunction", class('SKY_cipher_AddressFromSecKey'))

# Start of SKY_cipher_Address_Null

`SKY_cipher_Address_Null` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_cipher_Address_Null', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Address_Null`, 'returnType') = 'integer'
attr(`SKY_cipher_Address_Null`, "inputTypes") = c('_p_cipher__Address', 'integer')
class(`SKY_cipher_Address_Null`) = c("SWIGFunction", class('SKY_cipher_Address_Null'))

# Start of SKY_cipher_Address_Bytes

`SKY_cipher_Address_Bytes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_Address_Bytes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Address_Bytes`, 'returnType') = 'integer'
attr(`SKY_cipher_Address_Bytes`, "inputTypes") = c('_p_cipher__Address', '_p_GoSlice_')
class(`SKY_cipher_Address_Bytes`) = c("SWIGFunction", class('SKY_cipher_Address_Bytes'))

# Start of SKY_cipher_Address_Verify

`SKY_cipher_Address_Verify` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_Address_Verify', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Address_Verify`, 'returnType') = 'integer'
attr(`SKY_cipher_Address_Verify`, "inputTypes") = c('_p_cipher__Address', '_p_a_33__GoUint8_')
class(`SKY_cipher_Address_Verify`) = c("SWIGFunction", class('SKY_cipher_Address_Verify'))

# Start of SKY_cipher_Address_String

`SKY_cipher_Address_String` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_Address_String', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Address_String`, 'returnType') = 'integer'
attr(`SKY_cipher_Address_String`, "inputTypes") = c('_p_cipher__Address', '_p_GoString_')
class(`SKY_cipher_Address_String`) = c("SWIGFunction", class('SKY_cipher_Address_String'))

# Start of SKY_cipher_Address_Checksum

`SKY_cipher_Address_Checksum` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_Address_Checksum', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Address_Checksum`, 'returnType') = 'integer'
attr(`SKY_cipher_Address_Checksum`, "inputTypes") = c('_p_cipher__Address', '_p_a_4__GoUint8_')
class(`SKY_cipher_Address_Checksum`) = c("SWIGFunction", class('SKY_cipher_Address_Checksum'))

# Start of SKY_testutil_MakeAddress

`SKY_testutil_MakeAddress` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_testutil_MakeAddress', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_testutil_MakeAddress`, 'returnType') = 'integer'
attr(`SKY_testutil_MakeAddress`, "inputTypes") = c('_p_cipher__Address')
class(`SKY_testutil_MakeAddress`) = c("SWIGFunction", class('SKY_testutil_MakeAddress'))

# Start of SKY_coin_NewBlock

`SKY_coin_NewBlock` = function(p0, p1, p2, p3, p4, p5, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  ;.Call('R_swig_SKY_coin_NewBlock', p0, p1, p2, p3, p4, p5, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_NewBlock`, 'returnType') = 'integer'
attr(`SKY_coin_NewBlock`, "inputTypes") = c('_p_Block__Handle', 'integer', '_p_a_32__GoUint8_', '_p_Transactions__Handle', '_p_FeeCalculator', '_p_Block__Handle')
class(`SKY_coin_NewBlock`) = c("SWIGFunction", class('SKY_coin_NewBlock'))

# Start of SKY_coin_SignedBlock_VerifySignature

`SKY_coin_SignedBlock_VerifySignature` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_SignedBlock_VerifySignature', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_SignedBlock_VerifySignature`, 'returnType') = 'integer'
attr(`SKY_coin_SignedBlock_VerifySignature`, "inputTypes") = c('_p_coin__SignedBlock', '_p_a_33__GoUint8_')
class(`SKY_coin_SignedBlock_VerifySignature`) = c("SWIGFunction", class('SKY_coin_SignedBlock_VerifySignature'))

# Start of SKY_coin_NewGenesisBlock

`SKY_coin_NewGenesisBlock` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_coin_NewGenesisBlock', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_NewGenesisBlock`, 'returnType') = 'integer'
attr(`SKY_coin_NewGenesisBlock`, "inputTypes") = c('_p_cipher__Address', 'integer', 'integer', '_p_Block__Handle')
class(`SKY_coin_NewGenesisBlock`) = c("SWIGFunction", class('SKY_coin_NewGenesisBlock'))

# Start of SKY_coin_Block_HashHeader

`SKY_coin_Block_HashHeader` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Block_HashHeader', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_HashHeader`, 'returnType') = 'integer'
attr(`SKY_coin_Block_HashHeader`, "inputTypes") = c('_p_Block__Handle', '_p_a_32__GoUint8_')
class(`SKY_coin_Block_HashHeader`) = c("SWIGFunction", class('SKY_coin_Block_HashHeader'))

# Start of SKY_coin_Block_PreHashHeader

`SKY_coin_Block_PreHashHeader` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Block_PreHashHeader', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_PreHashHeader`, 'returnType') = 'integer'
attr(`SKY_coin_Block_PreHashHeader`, "inputTypes") = c('_p_Block__Handle', '_p_a_32__GoUint8_')
class(`SKY_coin_Block_PreHashHeader`) = c("SWIGFunction", class('SKY_coin_Block_PreHashHeader'))

# Start of SKY_coin_Block_Time

`SKY_coin_Block_Time` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Block_Time', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_Time`, 'returnType') = 'integer'
attr(`SKY_coin_Block_Time`, "inputTypes") = c('_p_Block__Handle', 'integer')
class(`SKY_coin_Block_Time`) = c("SWIGFunction", class('SKY_coin_Block_Time'))

# Start of SKY_coin_Block_Seq

`SKY_coin_Block_Seq` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Block_Seq', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_Seq`, 'returnType') = 'integer'
attr(`SKY_coin_Block_Seq`, "inputTypes") = c('_p_Block__Handle', 'integer')
class(`SKY_coin_Block_Seq`) = c("SWIGFunction", class('SKY_coin_Block_Seq'))

# Start of SKY_coin_Block_HashBody

`SKY_coin_Block_HashBody` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Block_HashBody', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_HashBody`, 'returnType') = 'integer'
attr(`SKY_coin_Block_HashBody`, "inputTypes") = c('_p_Block__Handle', '_p_a_32__GoUint8_')
class(`SKY_coin_Block_HashBody`) = c("SWIGFunction", class('SKY_coin_Block_HashBody'))

# Start of SKY_coin_Block_Size

`SKY_coin_Block_Size` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Block_Size', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_Size`, 'returnType') = 'integer'
attr(`SKY_coin_Block_Size`, "inputTypes") = c('_p_Block__Handle', 'integer')
class(`SKY_coin_Block_Size`) = c("SWIGFunction", class('SKY_coin_Block_Size'))

# Start of SKY_coin_Block_String

`SKY_coin_Block_String` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Block_String', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_String`, 'returnType') = 'integer'
attr(`SKY_coin_Block_String`, "inputTypes") = c('_p_Block__Handle', '_p_GoString_')
class(`SKY_coin_Block_String`) = c("SWIGFunction", class('SKY_coin_Block_String'))

# Start of SKY_coin_Block_GetTransaction

`SKY_coin_Block_GetTransaction` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  p3 = as.integer(p3);
  ;.Call('R_swig_SKY_coin_Block_GetTransaction', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_GetTransaction`, 'returnType') = 'integer'
attr(`SKY_coin_Block_GetTransaction`, "inputTypes") = c('_p_Block__Handle', '_p_a_32__GoUint8_', '_p_Transaction__Handle', 'integer')
class(`SKY_coin_Block_GetTransaction`) = c("SWIGFunction", class('SKY_coin_Block_GetTransaction'))

# Start of SKY_coin_NewBlockHeader

`SKY_coin_NewBlockHeader` = function(p0, p1, p2, p3, p4, p5, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  p3 = as.integer(p3);
  
  if(length(p3) > 1) {
    warning("using only the first element of p3");
  };
  
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  ;.Call('R_swig_SKY_coin_NewBlockHeader', p0, p1, p2, p3, p4, p5, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_NewBlockHeader`, 'returnType') = 'integer'
attr(`SKY_coin_NewBlockHeader`, "inputTypes") = c('_p_coin__BlockHeader', '_p_a_32__GoUint8_', 'integer', 'integer', '_p_BlockBody__Handle', '_p_coin__BlockHeader')
class(`SKY_coin_NewBlockHeader`) = c("SWIGFunction", class('SKY_coin_NewBlockHeader'))

# Start of SKY_coin_BlockHeader_Hash

`SKY_coin_BlockHeader_Hash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_BlockHeader_Hash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockHeader_Hash`, 'returnType') = 'integer'
attr(`SKY_coin_BlockHeader_Hash`, "inputTypes") = c('_p_coin__BlockHeader', '_p_a_32__GoUint8_')
class(`SKY_coin_BlockHeader_Hash`) = c("SWIGFunction", class('SKY_coin_BlockHeader_Hash'))

# Start of SKY_coin_BlockHeader_Bytes

`SKY_coin_BlockHeader_Bytes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_BlockHeader_Bytes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockHeader_Bytes`, 'returnType') = 'integer'
attr(`SKY_coin_BlockHeader_Bytes`, "inputTypes") = c('_p_coin__BlockHeader', '_p_GoSlice_')
class(`SKY_coin_BlockHeader_Bytes`) = c("SWIGFunction", class('SKY_coin_BlockHeader_Bytes'))

# Start of SKY_coin_BlockHeader_String

`SKY_coin_BlockHeader_String` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_BlockHeader_String', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockHeader_String`, 'returnType') = 'integer'
attr(`SKY_coin_BlockHeader_String`, "inputTypes") = c('_p_coin__BlockHeader', '_p_GoString_')
class(`SKY_coin_BlockHeader_String`) = c("SWIGFunction", class('SKY_coin_BlockHeader_String'))

# Start of SKY_coin_BlockBody_Hash

`SKY_coin_BlockBody_Hash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_BlockBody_Hash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockBody_Hash`, 'returnType') = 'integer'
attr(`SKY_coin_BlockBody_Hash`, "inputTypes") = c('_p_BlockBody__Handle', '_p_a_32__GoUint8_')
class(`SKY_coin_BlockBody_Hash`) = c("SWIGFunction", class('SKY_coin_BlockBody_Hash'))

# Start of SKY_coin_BlockBody_Size

`SKY_coin_BlockBody_Size` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_BlockBody_Size', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockBody_Size`, 'returnType') = 'integer'
attr(`SKY_coin_BlockBody_Size`, "inputTypes") = c('_p_BlockBody__Handle', 'integer')
class(`SKY_coin_BlockBody_Size`) = c("SWIGFunction", class('SKY_coin_BlockBody_Size'))

# Start of SKY_coin_BlockBody_Bytes

`SKY_coin_BlockBody_Bytes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_BlockBody_Bytes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockBody_Bytes`, 'returnType') = 'integer'
attr(`SKY_coin_BlockBody_Bytes`, "inputTypes") = c('_p_BlockBody__Handle', '_p_GoSlice_')
class(`SKY_coin_BlockBody_Bytes`) = c("SWIGFunction", class('SKY_coin_BlockBody_Bytes'))

# Start of SKY_coin_CreateUnspents

`SKY_coin_CreateUnspents` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_CreateUnspents', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_CreateUnspents`, 'returnType') = 'integer'
attr(`SKY_coin_CreateUnspents`, "inputTypes") = c('_p_coin__BlockHeader', '_p_Transaction__Handle', '_p_GoSlice_')
class(`SKY_coin_CreateUnspents`) = c("SWIGFunction", class('SKY_coin_CreateUnspents'))

# Start of SKY_coin_CreateUnspent

`SKY_coin_CreateUnspent` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_coin_CreateUnspent', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_CreateUnspent`, 'returnType') = 'integer'
attr(`SKY_coin_CreateUnspent`, "inputTypes") = c('_p_coin__BlockHeader', '_p_Transaction__Handle', 'integer', '_p_coin__UxOut')
class(`SKY_coin_CreateUnspent`) = c("SWIGFunction", class('SKY_coin_CreateUnspent'))

# Start of SKY_coin_GetBlockObject

`SKY_coin_GetBlockObject` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_GetBlockObject', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_GetBlockObject`, 'returnType') = 'integer'
attr(`SKY_coin_GetBlockObject`, "inputTypes") = c('_p_Block__Handle', '_p_p_coin__Block')
class(`SKY_coin_GetBlockObject`) = c("SWIGFunction", class('SKY_coin_GetBlockObject'))

# Start of SKY_coin_GetBlockBody

`SKY_coin_GetBlockBody` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_GetBlockBody', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_GetBlockBody`, 'returnType') = 'integer'
attr(`SKY_coin_GetBlockBody`, "inputTypes") = c('_p_Block__Handle', '_p_BlockBody__Handle')
class(`SKY_coin_GetBlockBody`) = c("SWIGFunction", class('SKY_coin_GetBlockBody'))

# Start of SKY_coin_NewEmptyBlock

`SKY_coin_NewEmptyBlock` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_NewEmptyBlock', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_NewEmptyBlock`, 'returnType') = 'integer'
attr(`SKY_coin_NewEmptyBlock`, "inputTypes") = c('_p_Transactions__Handle', '_p_Block__Handle')
class(`SKY_coin_NewEmptyBlock`) = c("SWIGFunction", class('SKY_coin_NewEmptyBlock'))

# Start of SKY_coin_Block_GetBlockHeader

`SKY_coin_Block_GetBlockHeader` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_Block_GetBlockHeader', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Block_GetBlockHeader`, 'returnType') = 'integer'
attr(`SKY_coin_Block_GetBlockHeader`, "inputTypes") = c('_p_Block__Handle', '_p_BlockHeader__Handle')
class(`SKY_coin_Block_GetBlockHeader`) = c("SWIGFunction", class('SKY_coin_Block_GetBlockHeader'))

# Start of SKY_coin_GetBlockHeaderObject

`SKY_coin_GetBlockHeaderObject` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_GetBlockHeaderObject', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_GetBlockHeaderObject`, 'returnType') = 'integer'
attr(`SKY_coin_GetBlockHeaderObject`, "inputTypes") = c('_p_BlockHeader__Handle', '_p_p_coin__BlockHeader')
class(`SKY_coin_GetBlockHeaderObject`) = c("SWIGFunction", class('SKY_coin_GetBlockHeaderObject'))

# Start of SKY_coin_BlockHeader_Time

`SKY_coin_BlockHeader_Time` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_BlockHeader_Time', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockHeader_Time`, 'returnType') = 'integer'
attr(`SKY_coin_BlockHeader_Time`, "inputTypes") = c('_p_BlockHeader__Handle', 'integer')
class(`SKY_coin_BlockHeader_Time`) = c("SWIGFunction", class('SKY_coin_BlockHeader_Time'))

# Start of SKY_coin_BlockHeader_BkSeq

`SKY_coin_BlockHeader_BkSeq` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_BlockHeader_BkSeq', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockHeader_BkSeq`, 'returnType') = 'integer'
attr(`SKY_coin_BlockHeader_BkSeq`, "inputTypes") = c('_p_BlockHeader__Handle', 'integer')
class(`SKY_coin_BlockHeader_BkSeq`) = c("SWIGFunction", class('SKY_coin_BlockHeader_BkSeq'))

# Start of SKY_coin_BlockHeader_UxHash

`SKY_coin_BlockHeader_UxHash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_BlockHeader_UxHash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockHeader_UxHash`, 'returnType') = 'integer'
attr(`SKY_coin_BlockHeader_UxHash`, "inputTypes") = c('_p_BlockHeader__Handle', '_p_a_32__GoUint8_')
class(`SKY_coin_BlockHeader_UxHash`) = c("SWIGFunction", class('SKY_coin_BlockHeader_UxHash'))

# Start of SKY_coin_BlockHeader_Fee

`SKY_coin_BlockHeader_Fee` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_BlockHeader_Fee', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockHeader_Fee`, 'returnType') = 'integer'
attr(`SKY_coin_BlockHeader_Fee`, "inputTypes") = c('_p_BlockHeader__Handle', 'integer')
class(`SKY_coin_BlockHeader_Fee`) = c("SWIGFunction", class('SKY_coin_BlockHeader_Fee'))

# Start of SKY_coin_BlockBody_Transactions

`SKY_coin_BlockBody_Transactions` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_BlockBody_Transactions', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_BlockBody_Transactions`, 'returnType') = 'integer'
attr(`SKY_coin_BlockBody_Transactions`, "inputTypes") = c('_p_BlockBody__Handle', '_p_Transactions__Handle')
class(`SKY_coin_BlockBody_Transactions`) = c("SWIGFunction", class('SKY_coin_BlockBody_Transactions'))

# Start of SKY_wallet_Entry_Verify

`SKY_wallet_Entry_Verify` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_wallet_Entry_Verify', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Entry_Verify`, 'returnType') = 'integer'
attr(`SKY_wallet_Entry_Verify`, "inputTypes") = c('_p_wallet__Entry')
class(`SKY_wallet_Entry_Verify`) = c("SWIGFunction", class('SKY_wallet_Entry_Verify'))

# Start of SKY_wallet_Entry_VerifyPublic

`SKY_wallet_Entry_VerifyPublic` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_wallet_Entry_VerifyPublic', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Entry_VerifyPublic`, 'returnType') = 'integer'
attr(`SKY_wallet_Entry_VerifyPublic`, "inputTypes") = c('_p_wallet__Entry')
class(`SKY_wallet_Entry_VerifyPublic`) = c("SWIGFunction", class('SKY_wallet_Entry_VerifyPublic'))

# Start of SKY_api_NewCreateTransactionResponse

`SKY_api_NewCreateTransactionResponse` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_NewCreateTransactionResponse', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_NewCreateTransactionResponse`, 'returnType') = 'integer'
attr(`SKY_api_NewCreateTransactionResponse`, "inputTypes") = c('_p_Transaction__Handle', '_p_GoSlice', '_p_CreateTransactionResponse__Handle')
class(`SKY_api_NewCreateTransactionResponse`) = c("SWIGFunction", class('SKY_api_NewCreateTransactionResponse'))

# Start of SKY_api_NewCreatedTransaction

`SKY_api_NewCreatedTransaction` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_NewCreatedTransaction', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_NewCreatedTransaction`, 'returnType') = 'integer'
attr(`SKY_api_NewCreatedTransaction`, "inputTypes") = c('_p_Transaction__Handle', '_p_GoSlice', '_p_CreatedTransaction__Handle')
class(`SKY_api_NewCreatedTransaction`) = c("SWIGFunction", class('SKY_api_NewCreatedTransaction'))

# Start of SKY_api_CreatedTransaction_ToTransaction

`SKY_api_CreatedTransaction_ToTransaction` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_CreatedTransaction_ToTransaction', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_CreatedTransaction_ToTransaction`, 'returnType') = 'integer'
attr(`SKY_api_CreatedTransaction_ToTransaction`, "inputTypes") = c('_p_CreatedTransaction__Handle', '_p_Transaction__Handle')
class(`SKY_api_CreatedTransaction_ToTransaction`) = c("SWIGFunction", class('SKY_api_CreatedTransaction_ToTransaction'))

# Start of SKY_api_NewCreatedTransactionOutput

`SKY_api_NewCreatedTransactionOutput` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_NewCreatedTransactionOutput', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_NewCreatedTransactionOutput`, 'returnType') = 'integer'
attr(`SKY_api_NewCreatedTransactionOutput`, "inputTypes") = c('_p_coin__TransactionOutput', '_p_a_32__GoUint8_', '_p_CreatedTransactionOutput__Handle')
class(`SKY_api_NewCreatedTransactionOutput`) = c("SWIGFunction", class('SKY_api_NewCreatedTransactionOutput'))

# Start of SKY_api_NewCreatedTransactionInput

`SKY_api_NewCreatedTransactionInput` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_NewCreatedTransactionInput', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_NewCreatedTransactionInput`, 'returnType') = 'integer'
attr(`SKY_api_NewCreatedTransactionInput`, "inputTypes") = c('_p_wallet__UxBalance', '_p_CreatedTransactionInput__Handle')
class(`SKY_api_NewCreatedTransactionInput`) = c("SWIGFunction", class('SKY_api_NewCreatedTransactionInput'))

# Start of SKY_cli_AddPrivateKey

`SKY_cli_AddPrivateKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_AddPrivateKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_AddPrivateKey`, 'returnType') = 'integer'
attr(`SKY_cli_AddPrivateKey`, "inputTypes") = c('_p_Wallet__Handle', '_p__GoString_')
class(`SKY_cli_AddPrivateKey`) = c("SWIGFunction", class('SKY_cli_AddPrivateKey'))

# Start of SKY_cli_AddPrivateKeyToFile

`SKY_cli_AddPrivateKeyToFile` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cli_AddPrivateKeyToFile', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_AddPrivateKeyToFile`, 'returnType') = 'integer'
attr(`SKY_cli_AddPrivateKeyToFile`, "inputTypes") = c('_p__GoString_', '_p__GoString_', '_p_PasswordReader__Handle')
class(`SKY_cli_AddPrivateKeyToFile`) = c("SWIGFunction", class('SKY_cli_AddPrivateKeyToFile'))

# Start of SKY_bip39_NewDefaultMnemomic

`SKY_bip39_NewDefaultMnemomic` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_bip39_NewDefaultMnemomic', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_bip39_NewDefaultMnemomic`, 'returnType') = 'integer'
attr(`SKY_bip39_NewDefaultMnemomic`, "inputTypes") = c('_p_GoString_')
class(`SKY_bip39_NewDefaultMnemomic`) = c("SWIGFunction", class('SKY_bip39_NewDefaultMnemomic'))

# Start of SKY_bip39_NewEntropy

`SKY_bip39_NewEntropy` = function(p0, p1, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_bip39_NewEntropy', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_bip39_NewEntropy`, 'returnType') = 'integer'
attr(`SKY_bip39_NewEntropy`, "inputTypes") = c('integer', '_p_GoSlice_')
class(`SKY_bip39_NewEntropy`) = c("SWIGFunction", class('SKY_bip39_NewEntropy'))

# Start of SKY_bip39_NewMnemonic

`SKY_bip39_NewMnemonic` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_bip39_NewMnemonic', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_bip39_NewMnemonic`, 'returnType') = 'integer'
attr(`SKY_bip39_NewMnemonic`, "inputTypes") = c('_p_GoSlice', '_p_GoString_')
class(`SKY_bip39_NewMnemonic`) = c("SWIGFunction", class('SKY_bip39_NewMnemonic'))

# Start of SKY_bip39_MnemonicToByteArray

`SKY_bip39_MnemonicToByteArray` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_bip39_MnemonicToByteArray', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_bip39_MnemonicToByteArray`, 'returnType') = 'integer'
attr(`SKY_bip39_MnemonicToByteArray`, "inputTypes") = c('_p__GoString_', '_p_GoSlice_')
class(`SKY_bip39_MnemonicToByteArray`) = c("SWIGFunction", class('SKY_bip39_MnemonicToByteArray'))

# Start of SKY_bip39_IsMnemonicValid

`SKY_bip39_IsMnemonicValid` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_bip39_IsMnemonicValid', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_bip39_IsMnemonicValid`, 'returnType') = 'integer'
attr(`SKY_bip39_IsMnemonicValid`, "inputTypes") = c('_p__GoString_', 'integer')
class(`SKY_bip39_IsMnemonicValid`) = c("SWIGFunction", class('SKY_bip39_IsMnemonicValid'))

# Start of SKY_JsonEncode_Handle

`SKY_JsonEncode_Handle` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_JsonEncode_Handle', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_JsonEncode_Handle`, 'returnType') = 'integer'
attr(`SKY_JsonEncode_Handle`, "inputTypes") = c('_p_Handle', '_p_GoString_')
class(`SKY_JsonEncode_Handle`) = c("SWIGFunction", class('SKY_JsonEncode_Handle'))

# Start of SKY_Handle_Progress_GetCurrent

`SKY_Handle_Progress_GetCurrent` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_Handle_Progress_GetCurrent', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Progress_GetCurrent`, 'returnType') = 'integer'
attr(`SKY_Handle_Progress_GetCurrent`, "inputTypes") = c('_p_Handle', 'integer')
class(`SKY_Handle_Progress_GetCurrent`) = c("SWIGFunction", class('SKY_Handle_Progress_GetCurrent'))

# Start of SKY_Handle_Block_GetHeadSeq

`SKY_Handle_Block_GetHeadSeq` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_Handle_Block_GetHeadSeq', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Block_GetHeadSeq`, 'returnType') = 'integer'
attr(`SKY_Handle_Block_GetHeadSeq`, "inputTypes") = c('_p_Handle', 'integer')
class(`SKY_Handle_Block_GetHeadSeq`) = c("SWIGFunction", class('SKY_Handle_Block_GetHeadSeq'))

# Start of SKY_Handle_Block_GetHeadHash

`SKY_Handle_Block_GetHeadHash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_Handle_Block_GetHeadHash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Block_GetHeadHash`, 'returnType') = 'integer'
attr(`SKY_Handle_Block_GetHeadHash`, "inputTypes") = c('_p_Handle', '_p_GoString_')
class(`SKY_Handle_Block_GetHeadHash`) = c("SWIGFunction", class('SKY_Handle_Block_GetHeadHash'))

# Start of SKY_Handle_Block_GetPreviousBlockHash

`SKY_Handle_Block_GetPreviousBlockHash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_Handle_Block_GetPreviousBlockHash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Block_GetPreviousBlockHash`, 'returnType') = 'integer'
attr(`SKY_Handle_Block_GetPreviousBlockHash`, "inputTypes") = c('_p_Handle', '_p_GoString_')
class(`SKY_Handle_Block_GetPreviousBlockHash`) = c("SWIGFunction", class('SKY_Handle_Block_GetPreviousBlockHash'))

# Start of SKY_Handle_Blocks_GetAt

`SKY_Handle_Blocks_GetAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_Handle_Blocks_GetAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Blocks_GetAt`, 'returnType') = 'integer'
attr(`SKY_Handle_Blocks_GetAt`, "inputTypes") = c('_p_Handle', 'integer', '_p_Handle')
class(`SKY_Handle_Blocks_GetAt`) = c("SWIGFunction", class('SKY_Handle_Blocks_GetAt'))

# Start of SKY_Handle_Blocks_GetCount

`SKY_Handle_Blocks_GetCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_Handle_Blocks_GetCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Blocks_GetCount`, 'returnType') = 'integer'
attr(`SKY_Handle_Blocks_GetCount`, "inputTypes") = c('_p_Handle', 'integer')
class(`SKY_Handle_Blocks_GetCount`) = c("SWIGFunction", class('SKY_Handle_Blocks_GetCount'))

# Start of SKY_Handle_Connections_GetCount

`SKY_Handle_Connections_GetCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_Handle_Connections_GetCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Connections_GetCount`, 'returnType') = 'integer'
attr(`SKY_Handle_Connections_GetCount`, "inputTypes") = c('_p_Handle', 'integer')
class(`SKY_Handle_Connections_GetCount`) = c("SWIGFunction", class('SKY_Handle_Connections_GetCount'))

# Start of SKY_Handle_Strings_GetCount

`SKY_Handle_Strings_GetCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_Handle_Strings_GetCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Strings_GetCount`, 'returnType') = 'integer'
attr(`SKY_Handle_Strings_GetCount`, "inputTypes") = c('_p_Strings__Handle', 'integer')
class(`SKY_Handle_Strings_GetCount`) = c("SWIGFunction", class('SKY_Handle_Strings_GetCount'))

# Start of SKY_Handle_Strings_Sort

`SKY_Handle_Strings_Sort` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_Handle_Strings_Sort', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Strings_Sort`, 'returnType') = 'integer'
attr(`SKY_Handle_Strings_Sort`, "inputTypes") = c('_p_Strings__Handle')
class(`SKY_Handle_Strings_Sort`) = c("SWIGFunction", class('SKY_Handle_Strings_Sort'))

# Start of SKY_Handle_Strings_GetAt

`SKY_Handle_Strings_GetAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_Handle_Strings_GetAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_Handle_Strings_GetAt`, 'returnType') = 'integer'
attr(`SKY_Handle_Strings_GetAt`, "inputTypes") = c('_p_Strings__Handle', 'integer', '_p_GoString_')
class(`SKY_Handle_Strings_GetAt`) = c("SWIGFunction", class('SKY_Handle_Strings_GetAt'))

# Start of SKY_api_Handle_Client_GetWalletDir

`SKY_api_Handle_Client_GetWalletDir` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_Client_GetWalletDir', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_Client_GetWalletDir`, 'returnType') = 'integer'
attr(`SKY_api_Handle_Client_GetWalletDir`, "inputTypes") = c('_p_Client__Handle', '_p_GoString_')
class(`SKY_api_Handle_Client_GetWalletDir`) = c("SWIGFunction", class('SKY_api_Handle_Client_GetWalletDir'))

# Start of SKY_api_Handle_Client_GetWalletFileName

`SKY_api_Handle_Client_GetWalletFileName` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_Client_GetWalletFileName', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_Client_GetWalletFileName`, 'returnType') = 'integer'
attr(`SKY_api_Handle_Client_GetWalletFileName`, "inputTypes") = c('_p_WalletResponse__Handle', '_p_GoString_')
class(`SKY_api_Handle_Client_GetWalletFileName`) = c("SWIGFunction", class('SKY_api_Handle_Client_GetWalletFileName'))

# Start of SKY_api_Handle_Client_GetWalletLabel

`SKY_api_Handle_Client_GetWalletLabel` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_Client_GetWalletLabel', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_Client_GetWalletLabel`, 'returnType') = 'integer'
attr(`SKY_api_Handle_Client_GetWalletLabel`, "inputTypes") = c('_p_WalletResponse__Handle', '_p_GoString_')
class(`SKY_api_Handle_Client_GetWalletLabel`) = c("SWIGFunction", class('SKY_api_Handle_Client_GetWalletLabel'))

# Start of SKY_api_Handle_Client_GetWalletFullPath

`SKY_api_Handle_Client_GetWalletFullPath` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Handle_Client_GetWalletFullPath', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_Client_GetWalletFullPath`, 'returnType') = 'integer'
attr(`SKY_api_Handle_Client_GetWalletFullPath`, "inputTypes") = c('_p_Client__Handle', '_p_WalletResponse__Handle', '_p_GoString_')
class(`SKY_api_Handle_Client_GetWalletFullPath`) = c("SWIGFunction", class('SKY_api_Handle_Client_GetWalletFullPath'))

# Start of SKY_api_Handle_GetWalletMeta

`SKY_api_Handle_GetWalletMeta` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_GetWalletMeta', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_GetWalletMeta`, 'returnType') = 'integer'
attr(`SKY_api_Handle_GetWalletMeta`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoStringMap_')
class(`SKY_api_Handle_GetWalletMeta`) = c("SWIGFunction", class('SKY_api_Handle_GetWalletMeta'))

# Start of SKY_api_Handle_GetWalletEntriesCount

`SKY_api_Handle_GetWalletEntriesCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_api_Handle_GetWalletEntriesCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_GetWalletEntriesCount`, 'returnType') = 'integer'
attr(`SKY_api_Handle_GetWalletEntriesCount`, "inputTypes") = c('_p_Wallet__Handle', 'integer')
class(`SKY_api_Handle_GetWalletEntriesCount`) = c("SWIGFunction", class('SKY_api_Handle_GetWalletEntriesCount'))

# Start of SKY_api_Handle_Client_GetWalletResponseEntriesCount

`SKY_api_Handle_Client_GetWalletResponseEntriesCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_api_Handle_Client_GetWalletResponseEntriesCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_Client_GetWalletResponseEntriesCount`, 'returnType') = 'integer'
attr(`SKY_api_Handle_Client_GetWalletResponseEntriesCount`, "inputTypes") = c('_p_WalletResponse__Handle', 'integer')
class(`SKY_api_Handle_Client_GetWalletResponseEntriesCount`) = c("SWIGFunction", class('SKY_api_Handle_Client_GetWalletResponseEntriesCount'))

# Start of SKY_api_Handle_WalletGetEntry

`SKY_api_Handle_WalletGetEntry` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_api_Handle_WalletGetEntry', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_WalletGetEntry`, 'returnType') = 'integer'
attr(`SKY_api_Handle_WalletGetEntry`, "inputTypes") = c('_p_Wallet__Handle', 'integer', '_p_cipher__Address', '_p_a_33__GoUint8_')
class(`SKY_api_Handle_WalletGetEntry`) = c("SWIGFunction", class('SKY_api_Handle_WalletGetEntry'))

# Start of SKY_api_Handle_WalletResponseGetEntry

`SKY_api_Handle_WalletResponseGetEntry` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_api_Handle_WalletResponseGetEntry', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_WalletResponseGetEntry`, 'returnType') = 'integer'
attr(`SKY_api_Handle_WalletResponseGetEntry`, "inputTypes") = c('_p_WalletResponse__Handle', 'integer', '_p_GoString_', '_p_GoString_')
class(`SKY_api_Handle_WalletResponseGetEntry`) = c("SWIGFunction", class('SKY_api_Handle_WalletResponseGetEntry'))

# Start of SKY_api_Handle_WalletResponseIsEncrypted

`SKY_api_Handle_WalletResponseIsEncrypted` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_api_Handle_WalletResponseIsEncrypted', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_WalletResponseIsEncrypted`, 'returnType') = 'integer'
attr(`SKY_api_Handle_WalletResponseIsEncrypted`, "inputTypes") = c('_p_WalletResponse__Handle', 'integer')
class(`SKY_api_Handle_WalletResponseIsEncrypted`) = c("SWIGFunction", class('SKY_api_Handle_WalletResponseIsEncrypted'))

# Start of SKY_api_Handle_WalletResponseGetCryptoType

`SKY_api_Handle_WalletResponseGetCryptoType` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_WalletResponseGetCryptoType', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_WalletResponseGetCryptoType`, 'returnType') = 'integer'
attr(`SKY_api_Handle_WalletResponseGetCryptoType`, "inputTypes") = c('_p_WalletResponse__Handle', '_p_GoString_')
class(`SKY_api_Handle_WalletResponseGetCryptoType`) = c("SWIGFunction", class('SKY_api_Handle_WalletResponseGetCryptoType'))

# Start of SKY_api_Handle_WalletsResponseGetCount

`SKY_api_Handle_WalletsResponseGetCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_api_Handle_WalletsResponseGetCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_WalletsResponseGetCount`, 'returnType') = 'integer'
attr(`SKY_api_Handle_WalletsResponseGetCount`, "inputTypes") = c('_p_Wallets__Handle', 'integer')
class(`SKY_api_Handle_WalletsResponseGetCount`) = c("SWIGFunction", class('SKY_api_Handle_WalletsResponseGetCount'))

# Start of SKY_api_Handle_WalletsResponseGetAt

`SKY_api_Handle_WalletsResponseGetAt` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Handle_WalletsResponseGetAt', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_WalletsResponseGetAt`, 'returnType') = 'integer'
attr(`SKY_api_Handle_WalletsResponseGetAt`, "inputTypes") = c('_p_Wallets__Handle', 'integer', '_p_WalletResponse__Handle')
class(`SKY_api_Handle_WalletsResponseGetAt`) = c("SWIGFunction", class('SKY_api_Handle_WalletsResponseGetAt'))

# Start of SKY_api_Handle_GetWalletFolderAddress

`SKY_api_Handle_GetWalletFolderAddress` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_GetWalletFolderAddress', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_GetWalletFolderAddress`, 'returnType') = 'integer'
attr(`SKY_api_Handle_GetWalletFolderAddress`, "inputTypes") = c('_p_Handle', '_p_GoString_')
class(`SKY_api_Handle_GetWalletFolderAddress`) = c("SWIGFunction", class('SKY_api_Handle_GetWalletFolderAddress'))

# Start of SKY_api_Handle_GetWalletSeed

`SKY_api_Handle_GetWalletSeed` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_GetWalletSeed', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_GetWalletSeed`, 'returnType') = 'integer'
attr(`SKY_api_Handle_GetWalletSeed`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoString_')
class(`SKY_api_Handle_GetWalletSeed`) = c("SWIGFunction", class('SKY_api_Handle_GetWalletSeed'))

# Start of SKY_api_Handle_GetWalletLastSeed

`SKY_api_Handle_GetWalletLastSeed` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Handle_GetWalletLastSeed', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_GetWalletLastSeed`, 'returnType') = 'integer'
attr(`SKY_api_Handle_GetWalletLastSeed`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoString_')
class(`SKY_api_Handle_GetWalletLastSeed`) = c("SWIGFunction", class('SKY_api_Handle_GetWalletLastSeed'))

# Start of SKY_api_Handle_GetBuildInfoData

`SKY_api_Handle_GetBuildInfoData` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_api_Handle_GetBuildInfoData', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Handle_GetBuildInfoData`, 'returnType') = 'integer'
attr(`SKY_api_Handle_GetBuildInfoData`, "inputTypes") = c('_p_BuildInfo_Handle', '_p_GoString_', '_p_GoString_', '_p_GoString_')
class(`SKY_api_Handle_GetBuildInfoData`) = c("SWIGFunction", class('SKY_api_Handle_GetBuildInfoData'))

# Start of SKY_coin_AddUint64

`SKY_coin_AddUint64` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_coin_AddUint64', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddUint64`, 'returnType') = 'integer'
attr(`SKY_coin_AddUint64`, "inputTypes") = c('integer', 'integer', 'integer')
class(`SKY_coin_AddUint64`) = c("SWIGFunction", class('SKY_coin_AddUint64'))

# Start of SKY_coin_Uint64ToInt64

`SKY_coin_Uint64ToInt64` = function(p0, p1, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Uint64ToInt64', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Uint64ToInt64`, 'returnType') = 'integer'
attr(`SKY_coin_Uint64ToInt64`, "inputTypes") = c('integer', 'integer')
class(`SKY_coin_Uint64ToInt64`) = c("SWIGFunction", class('SKY_coin_Uint64ToInt64'))

# Start of SKY_coin_Int64ToUint64

`SKY_coin_Int64ToUint64` = function(p0, p1, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_Int64ToUint64', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_Int64ToUint64`, 'returnType') = 'integer'
attr(`SKY_coin_Int64ToUint64`, "inputTypes") = c('integer', 'integer')
class(`SKY_coin_Int64ToUint64`) = c("SWIGFunction", class('SKY_coin_Int64ToUint64'))

# Start of SKY_coin_IntToUint32

`SKY_coin_IntToUint32` = function(p0, p1, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_IntToUint32', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_IntToUint32`, 'returnType') = 'integer'
attr(`SKY_coin_IntToUint32`, "inputTypes") = c('integer', 'integer')
class(`SKY_coin_IntToUint32`) = c("SWIGFunction", class('SKY_coin_IntToUint32'))

# Start of SKY_wallet_NewBalance

`SKY_wallet_NewBalance` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_NewBalance', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_NewBalance`, 'returnType') = 'integer'
attr(`SKY_wallet_NewBalance`, "inputTypes") = c('integer', 'integer', '_p_wallet__Balance')
class(`SKY_wallet_NewBalance`) = c("SWIGFunction", class('SKY_wallet_NewBalance'))

# Start of SKY_wallet_NewBalanceFromUxOut

`SKY_wallet_NewBalanceFromUxOut` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_NewBalanceFromUxOut', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_NewBalanceFromUxOut`, 'returnType') = 'integer'
attr(`SKY_wallet_NewBalanceFromUxOut`, "inputTypes") = c('integer', '_p_coin__UxOut', '_p_wallet__Balance')
class(`SKY_wallet_NewBalanceFromUxOut`) = c("SWIGFunction", class('SKY_wallet_NewBalanceFromUxOut'))

# Start of SKY_wallet_Balance_Add

`SKY_wallet_Balance_Add` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_Balance_Add', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Balance_Add`, 'returnType') = 'integer'
attr(`SKY_wallet_Balance_Add`, "inputTypes") = c('_p_wallet__Balance', '_p_wallet__Balance', '_p_wallet__Balance')
class(`SKY_wallet_Balance_Add`) = c("SWIGFunction", class('SKY_wallet_Balance_Add'))

# Start of SKY_wallet_Balance_Sub

`SKY_wallet_Balance_Sub` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_Balance_Sub', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Balance_Sub`, 'returnType') = 'integer'
attr(`SKY_wallet_Balance_Sub`, "inputTypes") = c('_p_wallet__Balance', '_p_wallet__Balance', '_p_wallet__Balance')
class(`SKY_wallet_Balance_Sub`) = c("SWIGFunction", class('SKY_wallet_Balance_Sub'))

# Start of SKY_wallet_Balance_Equals

`SKY_wallet_Balance_Equals` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_wallet_Balance_Equals', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Balance_Equals`, 'returnType') = 'integer'
attr(`SKY_wallet_Balance_Equals`, "inputTypes") = c('_p_wallet__Balance', '_p_wallet__Balance', 'integer')
class(`SKY_wallet_Balance_Equals`) = c("SWIGFunction", class('SKY_wallet_Balance_Equals'))

# Start of SKY_wallet_Balance_IsZero

`SKY_wallet_Balance_IsZero` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_wallet_Balance_IsZero', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Balance_IsZero`, 'returnType') = 'integer'
attr(`SKY_wallet_Balance_IsZero`, "inputTypes") = c('_p_wallet__Balance', 'integer')
class(`SKY_wallet_Balance_IsZero`) = c("SWIGFunction", class('SKY_wallet_Balance_IsZero'))

# Start of SKY_cli_CreateRawTxFromWallet

`SKY_cli_CreateRawTxFromWallet` = function(p0, p1, p2, p3, p4, p5, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  ;.Call('R_swig_SKY_cli_CreateRawTxFromWallet', p0, p1, p2, p3, p4, p5, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_CreateRawTxFromWallet`, 'returnType') = 'integer'
attr(`SKY_cli_CreateRawTxFromWallet`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p__GoString_', '_p__GoString_', '_p_GoSlice', '_p_PasswordReader__Handle', '_p_Transaction__Handle')
class(`SKY_cli_CreateRawTxFromWallet`) = c("SWIGFunction", class('SKY_cli_CreateRawTxFromWallet'))

# Start of SKY_cli_CreateRawTxFromAddress

`SKY_cli_CreateRawTxFromAddress` = function(p0, p1, p2, p3, p4, p5, p6, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  if (inherits(p6, "ExternalReference")) p6 = slot(p6,"ref") 
  ;.Call('R_swig_SKY_cli_CreateRawTxFromAddress', p0, p1, p2, p3, p4, p5, p6, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_CreateRawTxFromAddress`, 'returnType') = 'integer'
attr(`SKY_cli_CreateRawTxFromAddress`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p__GoString_', '_p__GoString_', '_p__GoString_', '_p_GoSlice', '_p_PasswordReader__Handle', '_p_Transaction__Handle')
class(`SKY_cli_CreateRawTxFromAddress`) = c("SWIGFunction", class('SKY_cli_CreateRawTxFromAddress'))

# Start of SKY_cli_CreateRawTx

`SKY_cli_CreateRawTx` = function(p0, p1, p2, p3, p4, p5, p6, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  if (inherits(p6, "ExternalReference")) p6 = slot(p6,"ref") 
  ;.Call('R_swig_SKY_cli_CreateRawTx', p0, p1, p2, p3, p4, p5, p6, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_CreateRawTx`, 'returnType') = 'integer'
attr(`SKY_cli_CreateRawTx`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_Wallet__Handle', '_p_GoSlice', '_p__GoString_', '_p_GoSlice', '_p_GoSlice', '_p_Transaction__Handle')
class(`SKY_cli_CreateRawTx`) = c("SWIGFunction", class('SKY_cli_CreateRawTx'))

# Start of SKY_cli_NewTransaction

`SKY_cli_NewTransaction` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_cli_NewTransaction', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_NewTransaction`, 'returnType') = 'integer'
attr(`SKY_cli_NewTransaction`, "inputTypes") = c('_p_GoSlice', '_p_GoSlice', '_p_GoSlice', '_p_Transaction__Handle')
class(`SKY_cli_NewTransaction`) = c("SWIGFunction", class('SKY_cli_NewTransaction'))

# Start of SKY_iputil_LocalhostIP

`SKY_iputil_LocalhostIP` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_iputil_LocalhostIP', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_iputil_LocalhostIP`, 'returnType') = 'integer'
attr(`SKY_iputil_LocalhostIP`, "inputTypes") = c('_p_GoString_')
class(`SKY_iputil_LocalhostIP`) = c("SWIGFunction", class('SKY_iputil_LocalhostIP'))

# Start of SKY_iputil_IsLocalhost

`SKY_iputil_IsLocalhost` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_iputil_IsLocalhost', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_iputil_IsLocalhost`, 'returnType') = 'integer'
attr(`SKY_iputil_IsLocalhost`, "inputTypes") = c('_p__GoString_', 'integer')
class(`SKY_iputil_IsLocalhost`) = c("SWIGFunction", class('SKY_iputil_IsLocalhost'))

# Start of SKY_iputil_SplitAddr

`SKY_iputil_SplitAddr` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_iputil_SplitAddr', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_iputil_SplitAddr`, 'returnType') = 'integer'
attr(`SKY_iputil_SplitAddr`, "inputTypes") = c('_p__GoString_', '_p_GoString_', 'integer')
class(`SKY_iputil_SplitAddr`) = c("SWIGFunction", class('SKY_iputil_SplitAddr'))

# Start of SKY_coin_UxOut_Hash

`SKY_coin_UxOut_Hash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_UxOut_Hash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxOut_Hash`, 'returnType') = 'integer'
attr(`SKY_coin_UxOut_Hash`, "inputTypes") = c('_p_coin__UxOut', '_p_a_32__GoUint8_')
class(`SKY_coin_UxOut_Hash`) = c("SWIGFunction", class('SKY_coin_UxOut_Hash'))

# Start of SKY_coin_UxOut_SnapshotHash

`SKY_coin_UxOut_SnapshotHash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_UxOut_SnapshotHash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxOut_SnapshotHash`, 'returnType') = 'integer'
attr(`SKY_coin_UxOut_SnapshotHash`, "inputTypes") = c('_p_coin__UxOut', '_p_a_32__GoUint8_')
class(`SKY_coin_UxOut_SnapshotHash`) = c("SWIGFunction", class('SKY_coin_UxOut_SnapshotHash'))

# Start of SKY_coin_UxBody_Hash

`SKY_coin_UxBody_Hash` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_UxBody_Hash', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxBody_Hash`, 'returnType') = 'integer'
attr(`SKY_coin_UxBody_Hash`, "inputTypes") = c('_p_coin__UxBody', '_p_a_32__GoUint8_')
class(`SKY_coin_UxBody_Hash`) = c("SWIGFunction", class('SKY_coin_UxBody_Hash'))

# Start of SKY_coin_UxOut_CoinHours

`SKY_coin_UxOut_CoinHours` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_coin_UxOut_CoinHours', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxOut_CoinHours`, 'returnType') = 'integer'
attr(`SKY_coin_UxOut_CoinHours`, "inputTypes") = c('_p_coin__UxOut', 'integer', 'integer')
class(`SKY_coin_UxOut_CoinHours`) = c("SWIGFunction", class('SKY_coin_UxOut_CoinHours'))

# Start of SKY_coin_UxArray_Hashes

`SKY_coin_UxArray_Hashes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_UxArray_Hashes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Hashes`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Hashes`, "inputTypes") = c('_p_GoSlice_', '_p_GoSlice_')
class(`SKY_coin_UxArray_Hashes`) = c("SWIGFunction", class('SKY_coin_UxArray_Hashes'))

# Start of SKY_coin_UxArray_HasDupes

`SKY_coin_UxArray_HasDupes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_UxArray_HasDupes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_HasDupes`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_HasDupes`, "inputTypes") = c('_p_GoSlice_', 'integer')
class(`SKY_coin_UxArray_HasDupes`) = c("SWIGFunction", class('SKY_coin_UxArray_HasDupes'))

# Start of SKY_coin_UxArray_Sort

`SKY_coin_UxArray_Sort` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_coin_UxArray_Sort', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Sort`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Sort`, "inputTypes") = c('_p_GoSlice_')
class(`SKY_coin_UxArray_Sort`) = c("SWIGFunction", class('SKY_coin_UxArray_Sort'))

# Start of SKY_coin_UxArray_Len

`SKY_coin_UxArray_Len` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_UxArray_Len', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Len`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Len`, "inputTypes") = c('_p_GoSlice_', 'integer')
class(`SKY_coin_UxArray_Len`) = c("SWIGFunction", class('SKY_coin_UxArray_Len'))

# Start of SKY_coin_UxArray_Less

`SKY_coin_UxArray_Less` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  p3 = as.integer(p3);
  ;.Call('R_swig_SKY_coin_UxArray_Less', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Less`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Less`, "inputTypes") = c('_p_GoSlice_', 'integer', 'integer', 'integer')
class(`SKY_coin_UxArray_Less`) = c("SWIGFunction", class('SKY_coin_UxArray_Less'))

# Start of SKY_coin_UxArray_Swap

`SKY_coin_UxArray_Swap` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  ;.Call('R_swig_SKY_coin_UxArray_Swap', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Swap`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Swap`, "inputTypes") = c('_p_GoSlice_', 'integer', 'integer')
class(`SKY_coin_UxArray_Swap`) = c("SWIGFunction", class('SKY_coin_UxArray_Swap'))

# Start of SKY_coin_UxArray_Coins

`SKY_coin_UxArray_Coins` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_UxArray_Coins', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Coins`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Coins`, "inputTypes") = c('_p_GoSlice_', 'integer')
class(`SKY_coin_UxArray_Coins`) = c("SWIGFunction", class('SKY_coin_UxArray_Coins'))

# Start of SKY_coin_UxArray_CoinHours

`SKY_coin_UxArray_CoinHours` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_coin_UxArray_CoinHours', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_CoinHours`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_CoinHours`, "inputTypes") = c('_p_GoSlice_', 'integer', 'integer')
class(`SKY_coin_UxArray_CoinHours`) = c("SWIGFunction", class('SKY_coin_UxArray_CoinHours'))

# Start of SKY_coin_UxArray_Sub

`SKY_coin_UxArray_Sub` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_UxArray_Sub', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Sub`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Sub`, "inputTypes") = c('_p_GoSlice_', '_p_GoSlice_', '_p_GoSlice_')
class(`SKY_coin_UxArray_Sub`) = c("SWIGFunction", class('SKY_coin_UxArray_Sub'))

# Start of SKY_coin_UxArray_Add

`SKY_coin_UxArray_Add` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_UxArray_Add', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_UxArray_Add`, 'returnType') = 'integer'
attr(`SKY_coin_UxArray_Add`, "inputTypes") = c('_p_GoSlice_', '_p_GoSlice_', '_p_GoSlice_')
class(`SKY_coin_UxArray_Add`) = c("SWIGFunction", class('SKY_coin_UxArray_Add'))

# Start of SKY_coin_NewAddressUxOuts

`SKY_coin_NewAddressUxOuts` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_NewAddressUxOuts', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_NewAddressUxOuts`, 'returnType') = 'integer'
attr(`SKY_coin_NewAddressUxOuts`, "inputTypes") = c('_p_GoSlice_', '_p_AddressUxOuts_Handle')
class(`SKY_coin_NewAddressUxOuts`) = c("SWIGFunction", class('SKY_coin_NewAddressUxOuts'))

# Start of SKY_coin_AddressUxOuts_Keys

`SKY_coin_AddressUxOuts_Keys` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_AddressUxOuts_Keys', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_Keys`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_Keys`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_GoSlice_')
class(`SKY_coin_AddressUxOuts_Keys`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_Keys'))

# Start of SKY_coin_AddressUxOuts_Flatten

`SKY_coin_AddressUxOuts_Flatten` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_coin_AddressUxOuts_Flatten', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_Flatten`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_Flatten`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_GoSlice_')
class(`SKY_coin_AddressUxOuts_Flatten`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_Flatten'))

# Start of SKY_coin_AddressUxOuts_Sub

`SKY_coin_AddressUxOuts_Sub` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_AddressUxOuts_Sub', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_Sub`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_Sub`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_AddressUxOuts_Handle', '_p_AddressUxOuts_Handle')
class(`SKY_coin_AddressUxOuts_Sub`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_Sub'))

# Start of SKY_coin_AddressUxOuts_Add

`SKY_coin_AddressUxOuts_Add` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_AddressUxOuts_Add', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_Add`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_Add`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_AddressUxOuts_Handle', '_p_AddressUxOuts_Handle')
class(`SKY_coin_AddressUxOuts_Add`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_Add'))

# Start of SKY_coin_AddressUxOuts_Get

`SKY_coin_AddressUxOuts_Get` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_AddressUxOuts_Get', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_Get`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_Get`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_cipher__Address', '_p_GoSlice_')
class(`SKY_coin_AddressUxOuts_Get`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_Get'))

# Start of SKY_coin_AddressUxOuts_HasKey

`SKY_coin_AddressUxOuts_HasKey` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_coin_AddressUxOuts_HasKey', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_HasKey`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_HasKey`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_cipher__Address', 'integer')
class(`SKY_coin_AddressUxOuts_HasKey`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_HasKey'))

# Start of SKY_coin_AddressUxOuts_GetOutputLength

`SKY_coin_AddressUxOuts_GetOutputLength` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_coin_AddressUxOuts_GetOutputLength', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_GetOutputLength`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_GetOutputLength`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_cipher__Address', 'integer')
class(`SKY_coin_AddressUxOuts_GetOutputLength`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_GetOutputLength'))

# Start of SKY_coin_AddressUxOuts_Length

`SKY_coin_AddressUxOuts_Length` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_coin_AddressUxOuts_Length', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_Length`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_Length`, "inputTypes") = c('_p_AddressUxOuts_Handle', 'integer')
class(`SKY_coin_AddressUxOuts_Length`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_Length'))

# Start of SKY_coin_AddressUxOuts_Set

`SKY_coin_AddressUxOuts_Set` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_coin_AddressUxOuts_Set', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_coin_AddressUxOuts_Set`, 'returnType') = 'integer'
attr(`SKY_coin_AddressUxOuts_Set`, "inputTypes") = c('_p_AddressUxOuts_Handle', '_p_cipher__Address', '_p_GoSlice_')
class(`SKY_coin_AddressUxOuts_Set`) = c("SWIGFunction", class('SKY_coin_AddressUxOuts_Set'))

# Start of SKY_webrpc_NewClient

`SKY_webrpc_NewClient` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_webrpc_NewClient', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_NewClient`, 'returnType') = 'integer'
attr(`SKY_webrpc_NewClient`, "inputTypes") = c('_p__GoString_', '_p_WebRpcClient__Handle')
class(`SKY_webrpc_NewClient`) = c("SWIGFunction", class('SKY_webrpc_NewClient'))

# Start of SKY_webrpc_Client_CSRF

`SKY_webrpc_Client_CSRF` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_CSRF', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_CSRF`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_CSRF`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_GoString_')
class(`SKY_webrpc_Client_CSRF`) = c("SWIGFunction", class('SKY_webrpc_Client_CSRF'))

# Start of SKY_webrpc_Client_InjectTransaction

`SKY_webrpc_Client_InjectTransaction` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_InjectTransaction', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_InjectTransaction`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_InjectTransaction`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_Transaction__Handle', '_p_GoString_')
class(`SKY_webrpc_Client_InjectTransaction`) = c("SWIGFunction", class('SKY_webrpc_Client_InjectTransaction'))

# Start of SKY_webrpc_Client_GetStatus

`SKY_webrpc_Client_GetStatus` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_GetStatus', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_GetStatus`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_GetStatus`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_StatusResult_Handle')
class(`SKY_webrpc_Client_GetStatus`) = c("SWIGFunction", class('SKY_webrpc_Client_GetStatus'))

# Start of SKY_webrpc_Client_GetTransactionByID

`SKY_webrpc_Client_GetTransactionByID` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_GetTransactionByID', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_GetTransactionByID`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_GetTransactionByID`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p__GoString_', '_p_TransactionResult_Handle')
class(`SKY_webrpc_Client_GetTransactionByID`) = c("SWIGFunction", class('SKY_webrpc_Client_GetTransactionByID'))

# Start of SKY_webrpc_Client_GetAddressUxOuts

`SKY_webrpc_Client_GetAddressUxOuts` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_GetAddressUxOuts', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_GetAddressUxOuts`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_GetAddressUxOuts`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_GoSlice', '_p_GoSlice_')
class(`SKY_webrpc_Client_GetAddressUxOuts`) = c("SWIGFunction", class('SKY_webrpc_Client_GetAddressUxOuts'))

# Start of SKY_webrpc_Client_GetBlocksInRange

`SKY_webrpc_Client_GetBlocksInRange` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_GetBlocksInRange', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_GetBlocksInRange`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_GetBlocksInRange`, "inputTypes") = c('_p_WebRpcClient__Handle', 'integer', 'integer', '_p_GoSlice_')
class(`SKY_webrpc_Client_GetBlocksInRange`) = c("SWIGFunction", class('SKY_webrpc_Client_GetBlocksInRange'))

# Start of SKY_webrpc_Client_GetBlocksBySeq

`SKY_webrpc_Client_GetBlocksBySeq` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_GetBlocksBySeq', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_GetBlocksBySeq`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_GetBlocksBySeq`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_GoSlice', '_p_GoSlice_')
class(`SKY_webrpc_Client_GetBlocksBySeq`) = c("SWIGFunction", class('SKY_webrpc_Client_GetBlocksBySeq'))

# Start of SKY_webrpc_Client_GetLastBlocks

`SKY_webrpc_Client_GetLastBlocks` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_webrpc_Client_GetLastBlocks', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_webrpc_Client_GetLastBlocks`, 'returnType') = 'integer'
attr(`SKY_webrpc_Client_GetLastBlocks`, "inputTypes") = c('_p_WebRpcClient__Handle', 'integer', '_p_GoSlice_')
class(`SKY_webrpc_Client_GetLastBlocks`) = c("SWIGFunction", class('SKY_webrpc_Client_GetLastBlocks'))

# Start of SKY_cipher_Ripemd160_Set

`SKY_cipher_Ripemd160_Set` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_Ripemd160_Set', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Ripemd160_Set`, 'returnType') = 'integer'
attr(`SKY_cipher_Ripemd160_Set`, "inputTypes") = c('_p_a_20__GoUint8_', '_p_GoSlice')
class(`SKY_cipher_Ripemd160_Set`) = c("SWIGFunction", class('SKY_cipher_Ripemd160_Set'))

# Start of SKY_cipher_HashRipemd160

`SKY_cipher_HashRipemd160` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_HashRipemd160', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_HashRipemd160`, 'returnType') = 'integer'
attr(`SKY_cipher_HashRipemd160`, "inputTypes") = c('_p_GoSlice', '_p_a_20__GoUint8_')
class(`SKY_cipher_HashRipemd160`) = c("SWIGFunction", class('SKY_cipher_HashRipemd160'))

# Start of SKY_cipher_SHA256_Set

`SKY_cipher_SHA256_Set` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SHA256_Set', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SHA256_Set`, 'returnType') = 'integer'
attr(`SKY_cipher_SHA256_Set`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_GoSlice')
class(`SKY_cipher_SHA256_Set`) = c("SWIGFunction", class('SKY_cipher_SHA256_Set'))

# Start of SKY_cipher_SHA256_Hex

`SKY_cipher_SHA256_Hex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SHA256_Hex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SHA256_Hex`, 'returnType') = 'integer'
attr(`SKY_cipher_SHA256_Hex`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_GoString_')
class(`SKY_cipher_SHA256_Hex`) = c("SWIGFunction", class('SKY_cipher_SHA256_Hex'))

# Start of SKY_cipher_SHA256_Xor

`SKY_cipher_SHA256_Xor` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_SHA256_Xor', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SHA256_Xor`, 'returnType') = 'integer'
attr(`SKY_cipher_SHA256_Xor`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_a_32__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_SHA256_Xor`) = c("SWIGFunction", class('SKY_cipher_SHA256_Xor'))

# Start of SKY_cipher_SumSHA256

`SKY_cipher_SumSHA256` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SumSHA256', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SumSHA256`, 'returnType') = 'integer'
attr(`SKY_cipher_SumSHA256`, "inputTypes") = c('_p_GoSlice', '_p_a_32__GoUint8_')
class(`SKY_cipher_SumSHA256`) = c("SWIGFunction", class('SKY_cipher_SumSHA256'))

# Start of SKY_cipher_SHA256FromHex

`SKY_cipher_SHA256FromHex` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SHA256FromHex', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SHA256FromHex`, 'returnType') = 'integer'
attr(`SKY_cipher_SHA256FromHex`, "inputTypes") = c('_p__GoString_', '_p_a_32__GoUint8_')
class(`SKY_cipher_SHA256FromHex`) = c("SWIGFunction", class('SKY_cipher_SHA256FromHex'))

# Start of SKY_cipher_DoubleSHA256

`SKY_cipher_DoubleSHA256` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_DoubleSHA256', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_DoubleSHA256`, 'returnType') = 'integer'
attr(`SKY_cipher_DoubleSHA256`, "inputTypes") = c('_p_GoSlice', '_p_a_32__GoUint8_')
class(`SKY_cipher_DoubleSHA256`) = c("SWIGFunction", class('SKY_cipher_DoubleSHA256'))

# Start of SKY_cipher_AddSHA256

`SKY_cipher_AddSHA256` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cipher_AddSHA256', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_AddSHA256`, 'returnType') = 'integer'
attr(`SKY_cipher_AddSHA256`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_a_32__GoUint8_', '_p_a_32__GoUint8_')
class(`SKY_cipher_AddSHA256`) = c("SWIGFunction", class('SKY_cipher_AddSHA256'))

# Start of SKY_cipher_Merkle

`SKY_cipher_Merkle` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_Merkle', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_Merkle`, 'returnType') = 'integer'
attr(`SKY_cipher_Merkle`, "inputTypes") = c('_p_GoSlice', '_p_a_32__GoUint8_')
class(`SKY_cipher_Merkle`) = c("SWIGFunction", class('SKY_cipher_Merkle'))

# Start of SKY_cipher_SHA256_Null

`SKY_cipher_SHA256_Null` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_cipher_SHA256_Null', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SHA256_Null`, 'returnType') = 'integer'
attr(`SKY_cipher_SHA256_Null`, "inputTypes") = c('_p_a_32__GoUint8_', 'integer')
class(`SKY_cipher_SHA256_Null`) = c("SWIGFunction", class('SKY_cipher_SHA256_Null'))

# Start of SKY_handle_close

`SKY_handle_close` = function(p0)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_handle_close', p0, PACKAGE='skycoin');
  
}

attr(`SKY_handle_close`, 'returnType') = 'void'
attr(`SKY_handle_close`, "inputTypes") = c('_p_Handle')
class(`SKY_handle_close`) = c("SWIGFunction", class('SKY_handle_close'))

# Start of SKY_handle_copy

`SKY_handle_copy` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_handle_copy', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_handle_copy`, 'returnType') = 'integer'
attr(`SKY_handle_copy`, "inputTypes") = c('_p_Handle', '_p_Handle')
class(`SKY_handle_copy`) = c("SWIGFunction", class('SKY_handle_copy'))

# Start of SKY_httphelper_Address_UnmarshalJSON

`SKY_httphelper_Address_UnmarshalJSON` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_httphelper_Address_UnmarshalJSON', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Address_UnmarshalJSON`, 'returnType') = 'integer'
attr(`SKY_httphelper_Address_UnmarshalJSON`, "inputTypes") = c('_p_httphelper__Address', '_p_GoSlice')
class(`SKY_httphelper_Address_UnmarshalJSON`) = c("SWIGFunction", class('SKY_httphelper_Address_UnmarshalJSON'))

# Start of SKY_httphelper_Address_MarshalJSON

`SKY_httphelper_Address_MarshalJSON` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_httphelper_Address_MarshalJSON', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Address_MarshalJSON`, 'returnType') = 'integer'
attr(`SKY_httphelper_Address_MarshalJSON`, "inputTypes") = c('_p_httphelper__Address', '_p_GoSlice_')
class(`SKY_httphelper_Address_MarshalJSON`) = c("SWIGFunction", class('SKY_httphelper_Address_MarshalJSON'))

# Start of SKY_httphelper_Coins_UnmarshalJSON

`SKY_httphelper_Coins_UnmarshalJSON` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_httphelper_Coins_UnmarshalJSON', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Coins_UnmarshalJSON`, 'returnType') = 'integer'
attr(`SKY_httphelper_Coins_UnmarshalJSON`, "inputTypes") = c('_p_GoUint64_', '_p_GoSlice')
class(`SKY_httphelper_Coins_UnmarshalJSON`) = c("SWIGFunction", class('SKY_httphelper_Coins_UnmarshalJSON'))

# Start of SKY_httphelper_Coins_MarshalJSON

`SKY_httphelper_Coins_MarshalJSON` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_httphelper_Coins_MarshalJSON', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Coins_MarshalJSON`, 'returnType') = 'integer'
attr(`SKY_httphelper_Coins_MarshalJSON`, "inputTypes") = c('_p_GoUint64_', '_p_GoSlice_')
class(`SKY_httphelper_Coins_MarshalJSON`) = c("SWIGFunction", class('SKY_httphelper_Coins_MarshalJSON'))

# Start of SKY_httphelper_Coins_Value

`SKY_httphelper_Coins_Value` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_httphelper_Coins_Value', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Coins_Value`, 'returnType') = 'integer'
attr(`SKY_httphelper_Coins_Value`, "inputTypes") = c('_p_GoUint64_', 'integer')
class(`SKY_httphelper_Coins_Value`) = c("SWIGFunction", class('SKY_httphelper_Coins_Value'))

# Start of SKY_httphelper_Hours_UnmarshalJSON

`SKY_httphelper_Hours_UnmarshalJSON` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_httphelper_Hours_UnmarshalJSON', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Hours_UnmarshalJSON`, 'returnType') = 'integer'
attr(`SKY_httphelper_Hours_UnmarshalJSON`, "inputTypes") = c('_p_GoUint64_', '_p_GoSlice')
class(`SKY_httphelper_Hours_UnmarshalJSON`) = c("SWIGFunction", class('SKY_httphelper_Hours_UnmarshalJSON'))

# Start of SKY_httphelper_Hours_MarshalJSON

`SKY_httphelper_Hours_MarshalJSON` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_httphelper_Hours_MarshalJSON', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Hours_MarshalJSON`, 'returnType') = 'integer'
attr(`SKY_httphelper_Hours_MarshalJSON`, "inputTypes") = c('_p_GoUint64_', '_p_GoSlice_')
class(`SKY_httphelper_Hours_MarshalJSON`) = c("SWIGFunction", class('SKY_httphelper_Hours_MarshalJSON'))

# Start of SKY_httphelper_Hours_Value

`SKY_httphelper_Hours_Value` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_httphelper_Hours_Value', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_httphelper_Hours_Value`, 'returnType') = 'integer'
attr(`SKY_httphelper_Hours_Value`, "inputTypes") = c('_p_GoUint64_', 'integer')
class(`SKY_httphelper_Hours_Value`) = c("SWIGFunction", class('SKY_httphelper_Hours_Value'))

# Start of SKY_wallet_NewReadableEntry

`SKY_wallet_NewReadableEntry` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_NewReadableEntry', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_NewReadableEntry`, 'returnType') = 'integer'
attr(`SKY_wallet_NewReadableEntry`, "inputTypes") = c('_p__GoString_', '_p_wallet__Entry', '_p_ReadableEntry__Handle')
class(`SKY_wallet_NewReadableEntry`) = c("SWIGFunction", class('SKY_wallet_NewReadableEntry'))

# Start of SKY_wallet_LoadReadableWallet

`SKY_wallet_LoadReadableWallet` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_LoadReadableWallet', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_LoadReadableWallet`, 'returnType') = 'integer'
attr(`SKY_wallet_LoadReadableWallet`, "inputTypes") = c('_p__GoString_', '_p_ReadableWallet__Handle')
class(`SKY_wallet_LoadReadableWallet`) = c("SWIGFunction", class('SKY_wallet_LoadReadableWallet'))

# Start of SKY_wallet_ReadableWallet_Save

`SKY_wallet_ReadableWallet_Save` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_ReadableWallet_Save', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_ReadableWallet_Save`, 'returnType') = 'integer'
attr(`SKY_wallet_ReadableWallet_Save`, "inputTypes") = c('_p_ReadableWallet__Handle', '_p__GoString_')
class(`SKY_wallet_ReadableWallet_Save`) = c("SWIGFunction", class('SKY_wallet_ReadableWallet_Save'))

# Start of SKY_wallet_ReadableWallet_Load

`SKY_wallet_ReadableWallet_Load` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_ReadableWallet_Load', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_ReadableWallet_Load`, 'returnType') = 'integer'
attr(`SKY_wallet_ReadableWallet_Load`, "inputTypes") = c('_p_ReadableWallet__Handle', '_p__GoString_')
class(`SKY_wallet_ReadableWallet_Load`) = c("SWIGFunction", class('SKY_wallet_ReadableWallet_Load'))

# Start of SKY_wallet_ReadableWallet_Erase

`SKY_wallet_ReadableWallet_Erase` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_wallet_ReadableWallet_Erase', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_ReadableWallet_Erase`, 'returnType') = 'integer'
attr(`SKY_wallet_ReadableWallet_Erase`, "inputTypes") = c('_p_ReadableWallet__Handle')
class(`SKY_wallet_ReadableWallet_Erase`) = c("SWIGFunction", class('SKY_wallet_ReadableWallet_Erase'))

# Start of SKY_file_InitDataDir

`SKY_file_InitDataDir` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_file_InitDataDir', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_file_InitDataDir`, 'returnType') = 'integer'
attr(`SKY_file_InitDataDir`, "inputTypes") = c('_p__GoString_', '_p_GoString_')
class(`SKY_file_InitDataDir`) = c("SWIGFunction", class('SKY_file_InitDataDir'))

# Start of SKY_file_UserHome

`SKY_file_UserHome` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_file_UserHome', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_file_UserHome`, 'returnType') = 'integer'
attr(`SKY_file_UserHome`, "inputTypes") = c('_p_GoString_')
class(`SKY_file_UserHome`) = c("SWIGFunction", class('SKY_file_UserHome'))

# Start of SKY_file_ResolveResourceDirectory

`SKY_file_ResolveResourceDirectory` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_file_ResolveResourceDirectory', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_file_ResolveResourceDirectory`, 'returnType') = 'integer'
attr(`SKY_file_ResolveResourceDirectory`, "inputTypes") = c('_p__GoString_', '_p_GoString_')
class(`SKY_file_ResolveResourceDirectory`) = c("SWIGFunction", class('SKY_file_ResolveResourceDirectory'))

# Start of SKY_file_DetermineResourcePath

`SKY_file_DetermineResourcePath` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_file_DetermineResourcePath', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_file_DetermineResourcePath`, 'returnType') = 'integer'
attr(`SKY_file_DetermineResourcePath`, "inputTypes") = c('_p__GoString_', '_p__GoString_', '_p__GoString_', '_p_GoString_')
class(`SKY_file_DetermineResourcePath`) = c("SWIGFunction", class('SKY_file_DetermineResourcePath'))

# Start of SKY_base58_Hex2Base58

`SKY_base58_Hex2Base58` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_base58_Hex2Base58', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_base58_Hex2Base58`, 'returnType') = 'integer'
attr(`SKY_base58_Hex2Base58`, "inputTypes") = c('_p_GoSlice', '_p_GoString_')
class(`SKY_base58_Hex2Base58`) = c("SWIGFunction", class('SKY_base58_Hex2Base58'))

# Start of SKY_base58_Encode

`SKY_base58_Encode` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_base58_Encode', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_base58_Encode`, 'returnType') = 'integer'
attr(`SKY_base58_Encode`, "inputTypes") = c('_p_GoSlice', '_p_GoString_')
class(`SKY_base58_Encode`) = c("SWIGFunction", class('SKY_base58_Encode'))

# Start of SKY_base58_Decode

`SKY_base58_Decode` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_base58_Decode', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_base58_Decode`, 'returnType') = 'integer'
attr(`SKY_base58_Decode`, "inputTypes") = c('_p__GoString_', '_p_GoSlice_')
class(`SKY_base58_Decode`) = c("SWIGFunction", class('SKY_base58_Decode'))

# Start of SKY_api_NewClient

`SKY_api_NewClient` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_NewClient', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_NewClient`, 'returnType') = 'integer'
attr(`SKY_api_NewClient`, "inputTypes") = c('_p__GoString_', '_p_Client__Handle')
class(`SKY_api_NewClient`) = c("SWIGFunction", class('SKY_api_NewClient'))

# Start of SKY_api_Client_CSRF

`SKY_api_Client_CSRF` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_CSRF', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_CSRF`, 'returnType') = 'integer'
attr(`SKY_api_Client_CSRF`, "inputTypes") = c('_p_Client__Handle', '_p_GoString_')
class(`SKY_api_Client_CSRF`) = c("SWIGFunction", class('SKY_api_Client_CSRF'))

# Start of SKY_api_Client_Version

`SKY_api_Client_Version` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_Version', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Version`, 'returnType') = 'integer'
attr(`SKY_api_Client_Version`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_Version`) = c("SWIGFunction", class('SKY_api_Client_Version'))

# Start of SKY_api_Client_Outputs

`SKY_api_Client_Outputs` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_Outputs', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Outputs`, 'returnType') = 'integer'
attr(`SKY_api_Client_Outputs`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_Outputs`) = c("SWIGFunction", class('SKY_api_Client_Outputs'))

# Start of SKY_api_Client_OutputsForAddresses

`SKY_api_Client_OutputsForAddresses` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_OutputsForAddresses', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_OutputsForAddresses`, 'returnType') = 'integer'
attr(`SKY_api_Client_OutputsForAddresses`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice', '_p_Handle')
class(`SKY_api_Client_OutputsForAddresses`) = c("SWIGFunction", class('SKY_api_Client_OutputsForAddresses'))

# Start of SKY_api_Client_OutputsForHashes

`SKY_api_Client_OutputsForHashes` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_OutputsForHashes', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_OutputsForHashes`, 'returnType') = 'integer'
attr(`SKY_api_Client_OutputsForHashes`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice', '_p_Handle')
class(`SKY_api_Client_OutputsForHashes`) = c("SWIGFunction", class('SKY_api_Client_OutputsForHashes'))

# Start of SKY_api_Client_CoinSupply

`SKY_api_Client_CoinSupply` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_CoinSupply', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_CoinSupply`, 'returnType') = 'integer'
attr(`SKY_api_Client_CoinSupply`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_CoinSupply`) = c("SWIGFunction", class('SKY_api_Client_CoinSupply'))

# Start of SKY_api_Client_BlockByHash

`SKY_api_Client_BlockByHash` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_BlockByHash', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_BlockByHash`, 'returnType') = 'integer'
attr(`SKY_api_Client_BlockByHash`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_Handle')
class(`SKY_api_Client_BlockByHash`) = c("SWIGFunction", class('SKY_api_Client_BlockByHash'))

# Start of SKY_api_Client_BlockBySeq

`SKY_api_Client_BlockBySeq` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_BlockBySeq', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_BlockBySeq`, 'returnType') = 'integer'
attr(`SKY_api_Client_BlockBySeq`, "inputTypes") = c('_p_Client__Handle', 'integer', '_p_Handle')
class(`SKY_api_Client_BlockBySeq`) = c("SWIGFunction", class('SKY_api_Client_BlockBySeq'))

# Start of SKY_api_Client_Blocks

`SKY_api_Client_Blocks` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_Blocks', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Blocks`, 'returnType') = 'integer'
attr(`SKY_api_Client_Blocks`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice', '_p_Handle')
class(`SKY_api_Client_Blocks`) = c("SWIGFunction", class('SKY_api_Client_Blocks'))

# Start of SKY_api_Client_LastBlocks

`SKY_api_Client_LastBlocks` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_LastBlocks', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_LastBlocks`, 'returnType') = 'integer'
attr(`SKY_api_Client_LastBlocks`, "inputTypes") = c('_p_Client__Handle', 'integer', '_p_Handle')
class(`SKY_api_Client_LastBlocks`) = c("SWIGFunction", class('SKY_api_Client_LastBlocks'))

# Start of SKY_api_Client_BlockchainMetadata

`SKY_api_Client_BlockchainMetadata` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_BlockchainMetadata', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_BlockchainMetadata`, 'returnType') = 'integer'
attr(`SKY_api_Client_BlockchainMetadata`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_BlockchainMetadata`) = c("SWIGFunction", class('SKY_api_Client_BlockchainMetadata'))

# Start of SKY_api_Client_BlockchainProgress

`SKY_api_Client_BlockchainProgress` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_BlockchainProgress', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_BlockchainProgress`, 'returnType') = 'integer'
attr(`SKY_api_Client_BlockchainProgress`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_BlockchainProgress`) = c("SWIGFunction", class('SKY_api_Client_BlockchainProgress'))

# Start of SKY_api_Client_Balance

`SKY_api_Client_Balance` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_Balance', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Balance`, 'returnType') = 'integer'
attr(`SKY_api_Client_Balance`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice', '_p_wallet__BalancePair')
class(`SKY_api_Client_Balance`) = c("SWIGFunction", class('SKY_api_Client_Balance'))

# Start of SKY_api_Client_UxOut

`SKY_api_Client_UxOut` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_UxOut', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_UxOut`, 'returnType') = 'integer'
attr(`SKY_api_Client_UxOut`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_Handle')
class(`SKY_api_Client_UxOut`) = c("SWIGFunction", class('SKY_api_Client_UxOut'))

# Start of SKY_api_Client_AddressUxOuts

`SKY_api_Client_AddressUxOuts` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_AddressUxOuts', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_AddressUxOuts`, 'returnType') = 'integer'
attr(`SKY_api_Client_AddressUxOuts`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_Handle')
class(`SKY_api_Client_AddressUxOuts`) = c("SWIGFunction", class('SKY_api_Client_AddressUxOuts'))

# Start of SKY_api_Client_Wallet

`SKY_api_Client_Wallet` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_Wallet', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Wallet`, 'returnType') = 'integer'
attr(`SKY_api_Client_Wallet`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_WalletResponse__Handle')
class(`SKY_api_Client_Wallet`) = c("SWIGFunction", class('SKY_api_Client_Wallet'))

# Start of SKY_api_Client_Wallets

`SKY_api_Client_Wallets` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_Wallets', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Wallets`, 'returnType') = 'integer'
attr(`SKY_api_Client_Wallets`, "inputTypes") = c('_p_Client__Handle', '_p_Wallets__Handle')
class(`SKY_api_Client_Wallets`) = c("SWIGFunction", class('SKY_api_Client_Wallets'))

# Start of SKY_api_Client_CreateUnencryptedWallet

`SKY_api_Client_CreateUnencryptedWallet` = function(p0, p1, p2, p3, p4, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  p3 = as.integer(p3);
  
  if(length(p3) > 1) {
    warning("using only the first element of p3");
  };
  
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  ;.Call('R_swig_SKY_api_Client_CreateUnencryptedWallet', p0, p1, p2, p3, p4, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_CreateUnencryptedWallet`, 'returnType') = 'integer'
attr(`SKY_api_Client_CreateUnencryptedWallet`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p__GoString_', 'integer', '_p_WalletResponse__Handle')
class(`SKY_api_Client_CreateUnencryptedWallet`) = c("SWIGFunction", class('SKY_api_Client_CreateUnencryptedWallet'))

# Start of SKY_api_Client_CreateEncryptedWallet

`SKY_api_Client_CreateEncryptedWallet` = function(p0, p1, p2, p3, p4, p5, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  p4 = as.integer(p4);
  
  if(length(p4) > 1) {
    warning("using only the first element of p4");
  };
  
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  ;.Call('R_swig_SKY_api_Client_CreateEncryptedWallet', p0, p1, p2, p3, p4, p5, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_CreateEncryptedWallet`, 'returnType') = 'integer'
attr(`SKY_api_Client_CreateEncryptedWallet`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p__GoString_', '_p__GoString_', 'integer', '_p_WalletResponse__Handle')
class(`SKY_api_Client_CreateEncryptedWallet`) = c("SWIGFunction", class('SKY_api_Client_CreateEncryptedWallet'))

# Start of SKY_api_Client_NewWalletAddress

`SKY_api_Client_NewWalletAddress` = function(p0, p1, p2, p3, p4, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  ;.Call('R_swig_SKY_api_Client_NewWalletAddress', p0, p1, p2, p3, p4, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_NewWalletAddress`, 'returnType') = 'integer'
attr(`SKY_api_Client_NewWalletAddress`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', 'integer', '_p__GoString_', '_p_Strings__Handle')
class(`SKY_api_Client_NewWalletAddress`) = c("SWIGFunction", class('SKY_api_Client_NewWalletAddress'))

# Start of SKY_api_Client_WalletBalance

`SKY_api_Client_WalletBalance` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_WalletBalance', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_WalletBalance`, 'returnType') = 'integer'
attr(`SKY_api_Client_WalletBalance`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_wallet__BalancePair')
class(`SKY_api_Client_WalletBalance`) = c("SWIGFunction", class('SKY_api_Client_WalletBalance'))

# Start of SKY_api_Client_Spend

`SKY_api_Client_Spend` = function(p0, p1, p2, p3, p4, p5, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  p3 = as.integer(p3);
  
  if(length(p3) > 1) {
    warning("using only the first element of p3");
  };
  
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  ;.Call('R_swig_SKY_api_Client_Spend', p0, p1, p2, p3, p4, p5, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Spend`, 'returnType') = 'integer'
attr(`SKY_api_Client_Spend`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p__GoString_', 'integer', '_p__GoString_', '_p_SpendResult_Handle')
class(`SKY_api_Client_Spend`) = c("SWIGFunction", class('SKY_api_Client_Spend'))

# Start of SKY_api_Client_CreateTransaction

`SKY_api_Client_CreateTransaction` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_CreateTransaction', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_CreateTransaction`, 'returnType') = 'integer'
attr(`SKY_api_Client_CreateTransaction`, "inputTypes") = c('_p_Client__Handle', '_p_Handle', '_p_CreateTransactionResponse__Handle')
class(`SKY_api_Client_CreateTransaction`) = c("SWIGFunction", class('SKY_api_Client_CreateTransaction'))

# Start of SKY_api_Client_UpdateWallet

`SKY_api_Client_UpdateWallet` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_UpdateWallet', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_UpdateWallet`, 'returnType') = 'integer'
attr(`SKY_api_Client_UpdateWallet`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p__GoString_')
class(`SKY_api_Client_UpdateWallet`) = c("SWIGFunction", class('SKY_api_Client_UpdateWallet'))

# Start of SKY_api_Client_WalletFolderName

`SKY_api_Client_WalletFolderName` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_WalletFolderName', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_WalletFolderName`, 'returnType') = 'integer'
attr(`SKY_api_Client_WalletFolderName`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_WalletFolderName`) = c("SWIGFunction", class('SKY_api_Client_WalletFolderName'))

# Start of SKY_api_Client_NewSeed

`SKY_api_Client_NewSeed` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_NewSeed', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_NewSeed`, 'returnType') = 'integer'
attr(`SKY_api_Client_NewSeed`, "inputTypes") = c('_p_Client__Handle', 'integer', '_p_GoString_')
class(`SKY_api_Client_NewSeed`) = c("SWIGFunction", class('SKY_api_Client_NewSeed'))

# Start of SKY_api_Client_WalletSeed

`SKY_api_Client_WalletSeed` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_api_Client_WalletSeed', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_WalletSeed`, 'returnType') = 'integer'
attr(`SKY_api_Client_WalletSeed`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p__GoString_', '_p_GoString_')
class(`SKY_api_Client_WalletSeed`) = c("SWIGFunction", class('SKY_api_Client_WalletSeed'))

# Start of SKY_api_Client_NetworkConnection

`SKY_api_Client_NetworkConnection` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_NetworkConnection', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_NetworkConnection`, 'returnType') = 'integer'
attr(`SKY_api_Client_NetworkConnection`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_Handle')
class(`SKY_api_Client_NetworkConnection`) = c("SWIGFunction", class('SKY_api_Client_NetworkConnection'))

# Start of SKY_api_Client_NetworkConnections

`SKY_api_Client_NetworkConnections` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_NetworkConnections', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_NetworkConnections`, 'returnType') = 'integer'
attr(`SKY_api_Client_NetworkConnections`, "inputTypes") = c('_p_Client__Handle', '_p_api__NetworkConnectionsFilter', '_p_Handle')
class(`SKY_api_Client_NetworkConnections`) = c("SWIGFunction", class('SKY_api_Client_NetworkConnections'))

# Start of SKY_api_Client_NetworkDefaultPeers

`SKY_api_Client_NetworkDefaultPeers` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_NetworkDefaultPeers', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_NetworkDefaultPeers`, 'returnType') = 'integer'
attr(`SKY_api_Client_NetworkDefaultPeers`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice_')
class(`SKY_api_Client_NetworkDefaultPeers`) = c("SWIGFunction", class('SKY_api_Client_NetworkDefaultPeers'))

# Start of SKY_api_Client_NetworkTrustedPeers

`SKY_api_Client_NetworkTrustedPeers` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_NetworkTrustedPeers', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_NetworkTrustedPeers`, 'returnType') = 'integer'
attr(`SKY_api_Client_NetworkTrustedPeers`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice_')
class(`SKY_api_Client_NetworkTrustedPeers`) = c("SWIGFunction", class('SKY_api_Client_NetworkTrustedPeers'))

# Start of SKY_api_Client_NetworkExchangedPeers

`SKY_api_Client_NetworkExchangedPeers` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_NetworkExchangedPeers', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_NetworkExchangedPeers`, 'returnType') = 'integer'
attr(`SKY_api_Client_NetworkExchangedPeers`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice_')
class(`SKY_api_Client_NetworkExchangedPeers`) = c("SWIGFunction", class('SKY_api_Client_NetworkExchangedPeers'))

# Start of SKY_api_Client_PendingTransactions

`SKY_api_Client_PendingTransactions` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_PendingTransactions', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_PendingTransactions`, 'returnType') = 'integer'
attr(`SKY_api_Client_PendingTransactions`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_PendingTransactions`) = c("SWIGFunction", class('SKY_api_Client_PendingTransactions'))

# Start of SKY_api_Client_Transaction

`SKY_api_Client_Transaction` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_Transaction', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Transaction`, 'returnType') = 'integer'
attr(`SKY_api_Client_Transaction`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_Handle')
class(`SKY_api_Client_Transaction`) = c("SWIGFunction", class('SKY_api_Client_Transaction'))

# Start of SKY_api_Client_Transactions

`SKY_api_Client_Transactions` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_Transactions', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Transactions`, 'returnType') = 'integer'
attr(`SKY_api_Client_Transactions`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice', '_p_Handle')
class(`SKY_api_Client_Transactions`) = c("SWIGFunction", class('SKY_api_Client_Transactions'))

# Start of SKY_api_Client_ConfirmedTransactions

`SKY_api_Client_ConfirmedTransactions` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_ConfirmedTransactions', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_ConfirmedTransactions`, 'returnType') = 'integer'
attr(`SKY_api_Client_ConfirmedTransactions`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice', '_p_Handle')
class(`SKY_api_Client_ConfirmedTransactions`) = c("SWIGFunction", class('SKY_api_Client_ConfirmedTransactions'))

# Start of SKY_api_Client_UnconfirmedTransactions

`SKY_api_Client_UnconfirmedTransactions` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_UnconfirmedTransactions', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_UnconfirmedTransactions`, 'returnType') = 'integer'
attr(`SKY_api_Client_UnconfirmedTransactions`, "inputTypes") = c('_p_Client__Handle', '_p_GoSlice', '_p_Handle')
class(`SKY_api_Client_UnconfirmedTransactions`) = c("SWIGFunction", class('SKY_api_Client_UnconfirmedTransactions'))

# Start of SKY_api_Client_InjectTransaction

`SKY_api_Client_InjectTransaction` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_InjectTransaction', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_InjectTransaction`, 'returnType') = 'integer'
attr(`SKY_api_Client_InjectTransaction`, "inputTypes") = c('_p_Client__Handle', '_p_Transaction__Handle', '_p_GoString_')
class(`SKY_api_Client_InjectTransaction`) = c("SWIGFunction", class('SKY_api_Client_InjectTransaction'))

# Start of SKY_api_Client_ResendUnconfirmedTransactions

`SKY_api_Client_ResendUnconfirmedTransactions` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_ResendUnconfirmedTransactions', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_ResendUnconfirmedTransactions`, 'returnType') = 'integer'
attr(`SKY_api_Client_ResendUnconfirmedTransactions`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_ResendUnconfirmedTransactions`) = c("SWIGFunction", class('SKY_api_Client_ResendUnconfirmedTransactions'))

# Start of SKY_api_Client_RawTransaction

`SKY_api_Client_RawTransaction` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_RawTransaction', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_RawTransaction`, 'returnType') = 'integer'
attr(`SKY_api_Client_RawTransaction`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_GoString_')
class(`SKY_api_Client_RawTransaction`) = c("SWIGFunction", class('SKY_api_Client_RawTransaction'))

# Start of SKY_api_Client_AddressTransactions

`SKY_api_Client_AddressTransactions` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_AddressTransactions', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_AddressTransactions`, 'returnType') = 'integer'
attr(`SKY_api_Client_AddressTransactions`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p_Handle')
class(`SKY_api_Client_AddressTransactions`) = c("SWIGFunction", class('SKY_api_Client_AddressTransactions'))

# Start of SKY_api_Client_Richlist

`SKY_api_Client_Richlist` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_api_Client_Richlist', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Richlist`, 'returnType') = 'integer'
attr(`SKY_api_Client_Richlist`, "inputTypes") = c('_p_Client__Handle', '_p_api__RichlistParams', '_p_Handle')
class(`SKY_api_Client_Richlist`) = c("SWIGFunction", class('SKY_api_Client_Richlist'))

# Start of SKY_api_Client_AddressCount

`SKY_api_Client_AddressCount` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_api_Client_AddressCount', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_AddressCount`, 'returnType') = 'integer'
attr(`SKY_api_Client_AddressCount`, "inputTypes") = c('_p_Client__Handle', 'integer')
class(`SKY_api_Client_AddressCount`) = c("SWIGFunction", class('SKY_api_Client_AddressCount'))

# Start of SKY_api_Client_UnloadWallet

`SKY_api_Client_UnloadWallet` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_UnloadWallet', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_UnloadWallet`, 'returnType') = 'integer'
attr(`SKY_api_Client_UnloadWallet`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_')
class(`SKY_api_Client_UnloadWallet`) = c("SWIGFunction", class('SKY_api_Client_UnloadWallet'))

# Start of SKY_api_Client_Health

`SKY_api_Client_Health` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_api_Client_Health', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_Health`, 'returnType') = 'integer'
attr(`SKY_api_Client_Health`, "inputTypes") = c('_p_Client__Handle', '_p_Handle')
class(`SKY_api_Client_Health`) = c("SWIGFunction", class('SKY_api_Client_Health'))

# Start of SKY_api_Client_EncryptWallet

`SKY_api_Client_EncryptWallet` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_api_Client_EncryptWallet', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_EncryptWallet`, 'returnType') = 'integer'
attr(`SKY_api_Client_EncryptWallet`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p__GoString_', '_p_WalletResponse__Handle')
class(`SKY_api_Client_EncryptWallet`) = c("SWIGFunction", class('SKY_api_Client_EncryptWallet'))

# Start of SKY_api_Client_DecryptWallet

`SKY_api_Client_DecryptWallet` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_api_Client_DecryptWallet', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_api_Client_DecryptWallet`, 'returnType') = 'integer'
attr(`SKY_api_Client_DecryptWallet`, "inputTypes") = c('_p_Client__Handle', '_p__GoString_', '_p__GoString_', '_p_WalletResponse__Handle')
class(`SKY_api_Client_DecryptWallet`) = c("SWIGFunction", class('SKY_api_Client_DecryptWallet'))

# Start of SKY_wallet_NewError

`SKY_wallet_NewError` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_wallet_NewError', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_NewError`, 'returnType') = 'integer'
attr(`SKY_wallet_NewError`, "inputTypes") = c('_p_GoInterface')
class(`SKY_wallet_NewError`) = c("SWIGFunction", class('SKY_wallet_NewError'))

# Start of SKY_wallet_NewWallet

`SKY_wallet_NewWallet` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_NewWallet', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_NewWallet`, 'returnType') = 'integer'
attr(`SKY_wallet_NewWallet`, "inputTypes") = c('_p__GoString_', '_p_Options__Handle', '_p_Wallet__Handle')
class(`SKY_wallet_NewWallet`) = c("SWIGFunction", class('SKY_wallet_NewWallet'))

# Start of SKY_wallet_Wallet_Lock

`SKY_wallet_Wallet_Lock` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Lock', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Lock`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Lock`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoSlice', '_p__GoString_')
class(`SKY_wallet_Wallet_Lock`) = c("SWIGFunction", class('SKY_wallet_Wallet_Lock'))

# Start of SKY_wallet_Wallet_Unlock

`SKY_wallet_Wallet_Unlock` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Unlock', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Unlock`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Unlock`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoSlice', '_p_Wallet__Handle')
class(`SKY_wallet_Wallet_Unlock`) = c("SWIGFunction", class('SKY_wallet_Wallet_Unlock'))

# Start of SKY_wallet_Load

`SKY_wallet_Load` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Load', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Load`, 'returnType') = 'integer'
attr(`SKY_wallet_Load`, "inputTypes") = c('_p__GoString_', '_p_Wallet__Handle')
class(`SKY_wallet_Load`) = c("SWIGFunction", class('SKY_wallet_Load'))

# Start of SKY_wallet_Wallet_Save

`SKY_wallet_Wallet_Save` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Save', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Save`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Save`, "inputTypes") = c('_p_Wallet__Handle', '_p__GoString_')
class(`SKY_wallet_Wallet_Save`) = c("SWIGFunction", class('SKY_wallet_Wallet_Save'))

# Start of SKY_wallet_Wallet_Validate

`SKY_wallet_Wallet_Validate` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Validate', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Validate`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Validate`, "inputTypes") = c('_p_Wallet__Handle')
class(`SKY_wallet_Wallet_Validate`) = c("SWIGFunction", class('SKY_wallet_Wallet_Validate'))

# Start of SKY_wallet_Wallet_Type

`SKY_wallet_Wallet_Type` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Type', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Type`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Type`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoString_')
class(`SKY_wallet_Wallet_Type`) = c("SWIGFunction", class('SKY_wallet_Wallet_Type'))

# Start of SKY_wallet_Wallet_Version

`SKY_wallet_Wallet_Version` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Version', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Version`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Version`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoString_')
class(`SKY_wallet_Wallet_Version`) = c("SWIGFunction", class('SKY_wallet_Wallet_Version'))

# Start of SKY_wallet_Wallet_Filename

`SKY_wallet_Wallet_Filename` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Filename', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Filename`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Filename`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoString_')
class(`SKY_wallet_Wallet_Filename`) = c("SWIGFunction", class('SKY_wallet_Wallet_Filename'))

# Start of SKY_wallet_Wallet_Label

`SKY_wallet_Wallet_Label` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_Label', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_Label`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_Label`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoString_')
class(`SKY_wallet_Wallet_Label`) = c("SWIGFunction", class('SKY_wallet_Wallet_Label'))

# Start of SKY_wallet_Wallet_IsEncrypted

`SKY_wallet_Wallet_IsEncrypted` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_wallet_Wallet_IsEncrypted', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_IsEncrypted`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_IsEncrypted`, "inputTypes") = c('_p_Wallet__Handle', 'integer')
class(`SKY_wallet_Wallet_IsEncrypted`) = c("SWIGFunction", class('SKY_wallet_Wallet_IsEncrypted'))

# Start of SKY_wallet_Wallet_GenerateAddresses

`SKY_wallet_Wallet_GenerateAddresses` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_GenerateAddresses', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_GenerateAddresses`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_GenerateAddresses`, "inputTypes") = c('_p_Wallet__Handle', 'integer', '_p_GoSlice_')
class(`SKY_wallet_Wallet_GenerateAddresses`) = c("SWIGFunction", class('SKY_wallet_Wallet_GenerateAddresses'))

# Start of SKY_wallet_Wallet_GetAddresses

`SKY_wallet_Wallet_GetAddresses` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_GetAddresses', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_GetAddresses`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_GetAddresses`, "inputTypes") = c('_p_Wallet__Handle', '_p_GoSlice_')
class(`SKY_wallet_Wallet_GetAddresses`) = c("SWIGFunction", class('SKY_wallet_Wallet_GetAddresses'))

# Start of SKY_wallet_Wallet_GetEntry

`SKY_wallet_Wallet_GetEntry` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  p3 = as.integer(p3);
  ;.Call('R_swig_SKY_wallet_Wallet_GetEntry', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_GetEntry`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_GetEntry`, "inputTypes") = c('_p_Wallet__Handle', '_p_cipher__Address', '_p_wallet__Entry', 'integer')
class(`SKY_wallet_Wallet_GetEntry`) = c("SWIGFunction", class('SKY_wallet_Wallet_GetEntry'))

# Start of SKY_wallet_Wallet_AddEntry

`SKY_wallet_Wallet_AddEntry` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_wallet_Wallet_AddEntry', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_Wallet_AddEntry`, 'returnType') = 'integer'
attr(`SKY_wallet_Wallet_AddEntry`, "inputTypes") = c('_p_Wallet__Handle', '_p_wallet__Entry')
class(`SKY_wallet_Wallet_AddEntry`) = c("SWIGFunction", class('SKY_wallet_Wallet_AddEntry'))

# Start of SKY_wallet_DistributeSpendHours

`SKY_wallet_DistributeSpendHours` = function(p0, p1, p2, p3, p4, p5, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  p3 = as.integer(p3);
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  p5 = as.integer(p5);
  ;.Call('R_swig_SKY_wallet_DistributeSpendHours', p0, p1, p2, p3, p4, p5, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_DistributeSpendHours`, 'returnType') = 'integer'
attr(`SKY_wallet_DistributeSpendHours`, "inputTypes") = c('integer', 'integer', 'integer', 'integer', '_p_GoSlice_', 'integer')
class(`SKY_wallet_DistributeSpendHours`) = c("SWIGFunction", class('SKY_wallet_DistributeSpendHours'))

# Start of SKY_wallet_DistributeCoinHoursProportional

`SKY_wallet_DistributeCoinHoursProportional` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_DistributeCoinHoursProportional', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_DistributeCoinHoursProportional`, 'returnType') = 'integer'
attr(`SKY_wallet_DistributeCoinHoursProportional`, "inputTypes") = c('_p_GoSlice', 'integer', '_p_GoSlice_')
class(`SKY_wallet_DistributeCoinHoursProportional`) = c("SWIGFunction", class('SKY_wallet_DistributeCoinHoursProportional'))

# Start of SKY_wallet_NewUxBalances

`SKY_wallet_NewUxBalances` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_NewUxBalances', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_NewUxBalances`, 'returnType') = 'integer'
attr(`SKY_wallet_NewUxBalances`, "inputTypes") = c('integer', '_p_GoSlice_', '_p_GoSlice_')
class(`SKY_wallet_NewUxBalances`) = c("SWIGFunction", class('SKY_wallet_NewUxBalances'))

# Start of SKY_wallet_NewUxBalance

`SKY_wallet_NewUxBalance` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_wallet_NewUxBalance', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_NewUxBalance`, 'returnType') = 'integer'
attr(`SKY_wallet_NewUxBalance`, "inputTypes") = c('integer', '_p_coin__UxOut', '_p_wallet__UxBalance')
class(`SKY_wallet_NewUxBalance`) = c("SWIGFunction", class('SKY_wallet_NewUxBalance'))

# Start of SKY_wallet_ChooseSpendsMinimizeUxOuts

`SKY_wallet_ChooseSpendsMinimizeUxOuts` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_wallet_ChooseSpendsMinimizeUxOuts', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_ChooseSpendsMinimizeUxOuts`, 'returnType') = 'integer'
attr(`SKY_wallet_ChooseSpendsMinimizeUxOuts`, "inputTypes") = c('_p_GoSlice', 'integer', 'integer', '_p_GoSlice_')
class(`SKY_wallet_ChooseSpendsMinimizeUxOuts`) = c("SWIGFunction", class('SKY_wallet_ChooseSpendsMinimizeUxOuts'))

# Start of SKY_wallet_ChooseSpendsMaximizeUxOuts

`SKY_wallet_ChooseSpendsMaximizeUxOuts` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  if (inherits(p3, "ExternalReference")) p3 = slot(p3,"ref") 
  ;.Call('R_swig_SKY_wallet_ChooseSpendsMaximizeUxOuts', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_ChooseSpendsMaximizeUxOuts`, 'returnType') = 'integer'
attr(`SKY_wallet_ChooseSpendsMaximizeUxOuts`, "inputTypes") = c('_p_GoSlice', 'integer', 'integer', '_p_GoSlice_')
class(`SKY_wallet_ChooseSpendsMaximizeUxOuts`) = c("SWIGFunction", class('SKY_wallet_ChooseSpendsMaximizeUxOuts'))

# Start of SKY_cli_CLI_Run

`SKY_cli_CLI_Run` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cli_CLI_Run', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_CLI_Run`, 'returnType') = 'integer'
attr(`SKY_cli_CLI_Run`, "inputTypes") = c('_p_CLI__Handle')
class(`SKY_cli_CLI_Run`) = c("SWIGFunction", class('SKY_cli_CLI_Run'))

# Start of SKY_cli_Config_GetCoin

`SKY_cli_Config_GetCoin` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_Config_GetCoin', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_Config_GetCoin`, 'returnType') = 'integer'
attr(`SKY_cli_Config_GetCoin`, "inputTypes") = c('_p_Config__Handle', '_p_GoString_')
class(`SKY_cli_Config_GetCoin`) = c("SWIGFunction", class('SKY_cli_Config_GetCoin'))

# Start of SKY_cli_Config_GetRPCAddress

`SKY_cli_Config_GetRPCAddress` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_Config_GetRPCAddress', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_Config_GetRPCAddress`, 'returnType') = 'integer'
attr(`SKY_cli_Config_GetRPCAddress`, "inputTypes") = c('_p_Config__Handle', '_p_GoString_')
class(`SKY_cli_Config_GetRPCAddress`) = c("SWIGFunction", class('SKY_cli_Config_GetRPCAddress'))

# Start of SKY_cli_Getenv

`SKY_cli_Getenv` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_Getenv', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_Getenv`, 'returnType') = 'integer'
attr(`SKY_cli_Getenv`, "inputTypes") = c('_p__GoString_', '_p_GoString_')
class(`SKY_cli_Getenv`) = c("SWIGFunction", class('SKY_cli_Getenv'))

# Start of SKY_cli_Setenv

`SKY_cli_Setenv` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cli_Setenv', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_Setenv`, 'returnType') = 'integer'
attr(`SKY_cli_Setenv`, "inputTypes") = c('_p__GoString_', '_p__GoString_')
class(`SKY_cli_Setenv`) = c("SWIGFunction", class('SKY_cli_Setenv'))

# Start of SKY_fee_VerifyTransactionFee

`SKY_fee_VerifyTransactionFee` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  ;.Call('R_swig_SKY_fee_VerifyTransactionFee', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_fee_VerifyTransactionFee`, 'returnType') = 'integer'
attr(`SKY_fee_VerifyTransactionFee`, "inputTypes") = c('_p_Transaction__Handle', 'integer', 'integer')
class(`SKY_fee_VerifyTransactionFee`) = c("SWIGFunction", class('SKY_fee_VerifyTransactionFee'))

# Start of SKY_fee_VerifyTransactionFeeForHours

`SKY_fee_VerifyTransactionFeeForHours` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  
  if(length(p2) > 1) {
    warning("using only the first element of p2");
  };
  
  ;.Call('R_swig_SKY_fee_VerifyTransactionFeeForHours', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_fee_VerifyTransactionFeeForHours`, 'returnType') = 'integer'
attr(`SKY_fee_VerifyTransactionFeeForHours`, "inputTypes") = c('integer', 'integer', 'integer')
class(`SKY_fee_VerifyTransactionFeeForHours`) = c("SWIGFunction", class('SKY_fee_VerifyTransactionFeeForHours'))

# Start of SKY_fee_RequiredFee

`SKY_fee_RequiredFee` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_fee_RequiredFee', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_fee_RequiredFee`, 'returnType') = 'integer'
attr(`SKY_fee_RequiredFee`, "inputTypes") = c('integer', 'integer', 'integer')
class(`SKY_fee_RequiredFee`) = c("SWIGFunction", class('SKY_fee_RequiredFee'))

# Start of SKY_fee_RemainingHours

`SKY_fee_RemainingHours` = function(p0, p1, p2, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  p2 = as.integer(p2);
  ;.Call('R_swig_SKY_fee_RemainingHours', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_fee_RemainingHours`, 'returnType') = 'integer'
attr(`SKY_fee_RemainingHours`, "inputTypes") = c('integer', 'integer', 'integer')
class(`SKY_fee_RemainingHours`) = c("SWIGFunction", class('SKY_fee_RemainingHours'))

# Start of SKY_fee_TransactionFee

`SKY_fee_TransactionFee` = function(p0, p1, p2, p3, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  
  if(length(p1) > 1) {
    warning("using only the first element of p1");
  };
  
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  p3 = as.integer(p3);
  ;.Call('R_swig_SKY_fee_TransactionFee', p0, p1, p2, p3, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_fee_TransactionFee`, 'returnType') = 'integer'
attr(`SKY_fee_TransactionFee`, "inputTypes") = c('_p_Transaction__Handle', 'integer', '_p_GoSlice_', 'integer')
class(`SKY_fee_TransactionFee`) = c("SWIGFunction", class('SKY_fee_TransactionFee'))

# Start of SKY_params_GetDistributionAddresses

`SKY_params_GetDistributionAddresses` = function(p0)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_params_GetDistributionAddresses', p0, PACKAGE='skycoin');
  
}

attr(`SKY_params_GetDistributionAddresses`, 'returnType') = 'void'
attr(`SKY_params_GetDistributionAddresses`, "inputTypes") = c('_p_GoSlice_')
class(`SKY_params_GetDistributionAddresses`) = c("SWIGFunction", class('SKY_params_GetDistributionAddresses'))

# Start of SKY_params_GetUnlockedDistributionAddresses

`SKY_params_GetUnlockedDistributionAddresses` = function(p0)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_params_GetUnlockedDistributionAddresses', p0, PACKAGE='skycoin');
  
}

attr(`SKY_params_GetUnlockedDistributionAddresses`, 'returnType') = 'void'
attr(`SKY_params_GetUnlockedDistributionAddresses`, "inputTypes") = c('_p_GoSlice_')
class(`SKY_params_GetUnlockedDistributionAddresses`) = c("SWIGFunction", class('SKY_params_GetUnlockedDistributionAddresses'))

# Start of SKY_params_GetLockedDistributionAddresses

`SKY_params_GetLockedDistributionAddresses` = function(p0)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_params_GetLockedDistributionAddresses', p0, PACKAGE='skycoin');
  
}

attr(`SKY_params_GetLockedDistributionAddresses`, 'returnType') = 'void'
attr(`SKY_params_GetLockedDistributionAddresses`, "inputTypes") = c('_p_GoSlice_')
class(`SKY_params_GetLockedDistributionAddresses`) = c("SWIGFunction", class('SKY_params_GetLockedDistributionAddresses'))

# Start of SKY_cli_GetWalletOutputsFromFile

`SKY_cli_GetWalletOutputsFromFile` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cli_GetWalletOutputsFromFile', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_GetWalletOutputsFromFile`, 'returnType') = 'integer'
attr(`SKY_cli_GetWalletOutputsFromFile`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p__GoString_', '_p_ReadableUnspentOutputsSummary_Handle')
class(`SKY_cli_GetWalletOutputsFromFile`) = c("SWIGFunction", class('SKY_cli_GetWalletOutputsFromFile'))

# Start of SKY_cli_GetWalletOutputs

`SKY_cli_GetWalletOutputs` = function(p0, p1, p2, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  ;.Call('R_swig_SKY_cli_GetWalletOutputs', p0, p1, p2, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cli_GetWalletOutputs`, 'returnType') = 'integer'
attr(`SKY_cli_GetWalletOutputs`, "inputTypes") = c('_p_WebRpcClient__Handle', '_p_Wallet__Handle', '_p_ReadableUnspentOutputsSummary_Handle')
class(`SKY_cli_GetWalletOutputs`) = c("SWIGFunction", class('SKY_cli_GetWalletOutputs'))

# Start of SKY_cipher_DecodeBase58BitcoinAddress

`SKY_cipher_DecodeBase58BitcoinAddress` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_DecodeBase58BitcoinAddress', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_DecodeBase58BitcoinAddress`, 'returnType') = 'integer'
attr(`SKY_cipher_DecodeBase58BitcoinAddress`, "inputTypes") = c('_p__GoString_', '_p_cipher__BitcoinAddress')
class(`SKY_cipher_DecodeBase58BitcoinAddress`) = c("SWIGFunction", class('SKY_cipher_DecodeBase58BitcoinAddress'))

# Start of SKY_cipher_BitcoinAddressFromPubKey

`SKY_cipher_BitcoinAddressFromPubKey` = function(p0, p1)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddressFromPubKey', p0, p1, PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddressFromPubKey`, 'returnType') = 'void'
attr(`SKY_cipher_BitcoinAddressFromPubKey`, "inputTypes") = c('_p_a_33__GoUint8_', '_p_cipher__BitcoinAddress')
class(`SKY_cipher_BitcoinAddressFromPubKey`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddressFromPubKey'))

# Start of SKY_cipher_BitcoinAddressFromSecKey

`SKY_cipher_BitcoinAddressFromSecKey` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddressFromSecKey', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddressFromSecKey`, 'returnType') = 'integer'
attr(`SKY_cipher_BitcoinAddressFromSecKey`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_cipher__BitcoinAddress')
class(`SKY_cipher_BitcoinAddressFromSecKey`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddressFromSecKey'))

# Start of SKY_cipher_BitcoinWalletImportFormatFromSeckey

`SKY_cipher_BitcoinWalletImportFormatFromSeckey` = function(p0, p1)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinWalletImportFormatFromSeckey', p0, p1, PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinWalletImportFormatFromSeckey`, 'returnType') = 'void'
attr(`SKY_cipher_BitcoinWalletImportFormatFromSeckey`, "inputTypes") = c('_p_a_32__GoUint8_', '_p_GoString_')
class(`SKY_cipher_BitcoinWalletImportFormatFromSeckey`) = c("SWIGFunction", class('SKY_cipher_BitcoinWalletImportFormatFromSeckey'))

# Start of SKY_cipher_BitcoinAddressFromBytes

`SKY_cipher_BitcoinAddressFromBytes` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddressFromBytes', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddressFromBytes`, 'returnType') = 'integer'
attr(`SKY_cipher_BitcoinAddressFromBytes`, "inputTypes") = c('_p_GoSlice', '_p_cipher__BitcoinAddress')
class(`SKY_cipher_BitcoinAddressFromBytes`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddressFromBytes'))

# Start of SKY_cipher_SecKeyFromBitcoinWalletImportFormat

`SKY_cipher_SecKeyFromBitcoinWalletImportFormat` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_SecKeyFromBitcoinWalletImportFormat', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_SecKeyFromBitcoinWalletImportFormat`, 'returnType') = 'integer'
attr(`SKY_cipher_SecKeyFromBitcoinWalletImportFormat`, "inputTypes") = c('_p__GoString_', '_p_a_32__GoUint8_')
class(`SKY_cipher_SecKeyFromBitcoinWalletImportFormat`) = c("SWIGFunction", class('SKY_cipher_SecKeyFromBitcoinWalletImportFormat'))

# Start of SKY_cipher_BitcoinAddress_Null

`SKY_cipher_BitcoinAddress_Null` = function(p0, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddress_Null', p0, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddress_Null`, 'returnType') = 'integer'
attr(`SKY_cipher_BitcoinAddress_Null`, "inputTypes") = c('_p_cipher__BitcoinAddress')
class(`SKY_cipher_BitcoinAddress_Null`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddress_Null'))

# Start of SKY_cipher_BitcoinAddress_Bytes

`SKY_cipher_BitcoinAddress_Bytes` = function(p0, p1)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddress_Bytes', p0, p1, PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddress_Bytes`, 'returnType') = 'void'
attr(`SKY_cipher_BitcoinAddress_Bytes`, "inputTypes") = c('_p_cipher__BitcoinAddress', '_p_GoSlice_')
class(`SKY_cipher_BitcoinAddress_Bytes`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddress_Bytes'))

# Start of SKY_cipher_BitcoinAddress_Verify

`SKY_cipher_BitcoinAddress_Verify` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddress_Verify', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddress_Verify`, 'returnType') = 'integer'
attr(`SKY_cipher_BitcoinAddress_Verify`, "inputTypes") = c('_p_cipher__BitcoinAddress', '_p_a_33__GoUint8_')
class(`SKY_cipher_BitcoinAddress_Verify`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddress_Verify'))

# Start of SKY_cipher_BitcoinAddress_String

`SKY_cipher_BitcoinAddress_String` = function(p0, p1)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddress_String', p0, p1, PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddress_String`, 'returnType') = 'void'
attr(`SKY_cipher_BitcoinAddress_String`, "inputTypes") = c('_p_cipher__BitcoinAddress', '_p_GoString_')
class(`SKY_cipher_BitcoinAddress_String`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddress_String'))

# Start of SKY_cipher_BitcoinAddress_Checksum

`SKY_cipher_BitcoinAddress_Checksum` = function(p0, p1)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_cipher_BitcoinAddress_Checksum', p0, p1, PACKAGE='skycoin');
  
}

attr(`SKY_cipher_BitcoinAddress_Checksum`, 'returnType') = 'void'
attr(`SKY_cipher_BitcoinAddress_Checksum`, "inputTypes") = c('_p_cipher__BitcoinAddress', '_p_a_4__GoUint8_')
class(`SKY_cipher_BitcoinAddress_Checksum`) = c("SWIGFunction", class('SKY_cipher_BitcoinAddress_Checksum'))

# Start of SKY_wallet_CreateOptionsHandle

`SKY_wallet_CreateOptionsHandle` = function(p0, p1, p2, p3, p4, p5, p6, p7, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  if (inherits(p2, "ExternalReference")) p2 = slot(p2,"ref") 
  p3 = as.integer(p3);
  
  if(length(p3) > 1) {
    warning("using only the first element of p3");
  };
  
  if (inherits(p4, "ExternalReference")) p4 = slot(p4,"ref") 
  if (inherits(p5, "ExternalReference")) p5 = slot(p5,"ref") 
  p6 = as.integer(p6);
  
  if(length(p6) > 1) {
    warning("using only the first element of p6");
  };
  
  if (inherits(p7, "ExternalReference")) p7 = slot(p7,"ref") 
  ;.Call('R_swig_SKY_wallet_CreateOptionsHandle', p0, p1, p2, p3, p4, p5, p6, p7, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_wallet_CreateOptionsHandle`, 'returnType') = 'integer'
attr(`SKY_wallet_CreateOptionsHandle`, "inputTypes") = c('_p__GoString_', '_p__GoString_', '_p__GoString_', 'integer', '_p__GoString_', '_p__GoString_', 'integer', '_p_Options__Handle')
class(`SKY_wallet_CreateOptionsHandle`) = c("SWIGFunction", class('SKY_wallet_CreateOptionsHandle'))

# Start of SKY_droplet_FromString

`SKY_droplet_FromString` = function(p0, p1, .copy = FALSE)
{
  if (inherits(p0, "ExternalReference")) p0 = slot(p0,"ref") 
  p1 = as.integer(p1);
  ;.Call('R_swig_SKY_droplet_FromString', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_droplet_FromString`, 'returnType') = 'integer'
attr(`SKY_droplet_FromString`, "inputTypes") = c('_p__GoString_', 'integer')
class(`SKY_droplet_FromString`) = c("SWIGFunction", class('SKY_droplet_FromString'))

# Start of SKY_droplet_ToString

`SKY_droplet_ToString` = function(p0, p1, .copy = FALSE)
{
  p0 = as.integer(p0);
  
  if(length(p0) > 1) {
    warning("using only the first element of p0");
  };
  
  if (inherits(p1, "ExternalReference")) p1 = slot(p1,"ref") 
  ;.Call('R_swig_SKY_droplet_ToString', p0, p1, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`SKY_droplet_ToString`, 'returnType') = 'integer'
attr(`SKY_droplet_ToString`, "inputTypes") = c('integer', '_p_GoString_')
class(`SKY_droplet_ToString`) = c("SWIGFunction", class('SKY_droplet_ToString'))

# Start of api__RichlistParams_N_set

`api__RichlistParams_N_set` = function(self, s_N)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_N = as.integer(s_N);
  
  if(length(s_N) > 1) {
    warning("using only the first element of s_N");
  };
  
  ;.Call('R_swig_api__RichlistParams_N_set', self, s_N, PACKAGE='skycoin');
  
}

attr(`api__RichlistParams_N_set`, 'returnType') = 'void'
attr(`api__RichlistParams_N_set`, "inputTypes") = c('_p_api__RichlistParams', 'integer')
class(`api__RichlistParams_N_set`) = c("SWIGFunction", class('api__RichlistParams_N_set'))

# Start of api__RichlistParams_N_get

`api__RichlistParams_N_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_api__RichlistParams_N_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`api__RichlistParams_N_get`, 'returnType') = 'integer'
attr(`api__RichlistParams_N_get`, "inputTypes") = c('_p_api__RichlistParams')
class(`api__RichlistParams_N_get`) = c("SWIGFunction", class('api__RichlistParams_N_get'))

# Start of api__RichlistParams_IncludeDistribution_set

`api__RichlistParams_IncludeDistribution_set` = function(self, s_IncludeDistribution)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_IncludeDistribution = as.integer(s_IncludeDistribution);
  
  if(length(s_IncludeDistribution) > 1) {
    warning("using only the first element of s_IncludeDistribution");
  };
  
  ;.Call('R_swig_api__RichlistParams_IncludeDistribution_set', self, s_IncludeDistribution, PACKAGE='skycoin');
  
}

attr(`api__RichlistParams_IncludeDistribution_set`, 'returnType') = 'void'
attr(`api__RichlistParams_IncludeDistribution_set`, "inputTypes") = c('_p_api__RichlistParams', 'integer')
class(`api__RichlistParams_IncludeDistribution_set`) = c("SWIGFunction", class('api__RichlistParams_IncludeDistribution_set'))

# Start of api__RichlistParams_IncludeDistribution_get

`api__RichlistParams_IncludeDistribution_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_api__RichlistParams_IncludeDistribution_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`api__RichlistParams_IncludeDistribution_get`, 'returnType') = 'integer'
attr(`api__RichlistParams_IncludeDistribution_get`, "inputTypes") = c('_p_api__RichlistParams')
class(`api__RichlistParams_IncludeDistribution_get`) = c("SWIGFunction", class('api__RichlistParams_IncludeDistribution_get'))

# Start of new_api__RichlistParams

`api__RichlistParams` = function()
{
  ;ans = .Call('R_swig_new_api__RichlistParams', PACKAGE='skycoin');
  ans <- new("_p_api__RichlistParams", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_api__RichlistParams)
  ans
  
}

attr(`api__RichlistParams`, 'returnType') = '_p_api__RichlistParams'
class(`api__RichlistParams`) = c("SWIGFunction", class('api__RichlistParams'))

# Start of delete_api__RichlistParams

`delete_api__RichlistParams` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_api__RichlistParams', self, PACKAGE='skycoin');
  
}

attr(`delete_api__RichlistParams`, 'returnType') = 'void'
attr(`delete_api__RichlistParams`, "inputTypes") = c('_p_api__RichlistParams')
class(`delete_api__RichlistParams`) = c("SWIGFunction", class('delete_api__RichlistParams'))

# Start of accessor method for api__RichlistParams
setMethod('$', '_p_api__RichlistParams', function(x, name)

{
  accessorFuns = list('N' = api__RichlistParams_N_get, 'IncludeDistribution' = api__RichlistParams_IncludeDistribution_get);
  vaccessors = c('N', 'IncludeDistribution');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for api__RichlistParams
# Start of accessor method for api__RichlistParams
setMethod('$<-', '_p_api__RichlistParams', function(x, name, value)

{
  accessorFuns = list('N' = api__RichlistParams_N_set, 'IncludeDistribution' = api__RichlistParams_IncludeDistribution_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_api__RichlistParams', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('N' = api__RichlistParams_N_set, 'IncludeDistribution' = api__RichlistParams_IncludeDistribution_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for api__RichlistParams
setMethod('delete', '_p_api__RichlistParams', function(obj) {delete_api__RichlistParams(obj)})
# Start definition of copy functions & methods for api__RichlistParams
CopyToR_api__RichlistParams = function(value, obj = new("api__RichlistParams"))
{
  obj@N = value$N;
  obj@IncludeDistribution = value$IncludeDistribution;
  obj;
}



CopyToC_api__RichlistParams = function(value, obj)
{
  obj$N = value@N;
  obj$IncludeDistribution = value@IncludeDistribution;
  obj
}



# Start definition of copy methods for api__RichlistParams
setMethod('copyToR', '_p_api__RichlistParams', CopyToR_api__RichlistParams);
setMethod('copyToC', 'api__RichlistParams', CopyToC_api__RichlistParams);

# End definition of copy methods for api__RichlistParams
# End definition of copy functions & methods for api__RichlistParams
# Start of api__NetworkConnectionsFilter_States_set

`api__NetworkConnectionsFilter_States_set` = function(self, s_States)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_States, "ExternalReference")) s_States = slot(s_States,"ref") 
  ;.Call('R_swig_api__NetworkConnectionsFilter_States_set', self, s_States, PACKAGE='skycoin');
  
}

attr(`api__NetworkConnectionsFilter_States_set`, 'returnType') = 'void'
attr(`api__NetworkConnectionsFilter_States_set`, "inputTypes") = c('_p_api__NetworkConnectionsFilter', '_p_GoString_')
class(`api__NetworkConnectionsFilter_States_set`) = c("SWIGFunction", class('api__NetworkConnectionsFilter_States_set'))

# Start of api__NetworkConnectionsFilter_States_get

`api__NetworkConnectionsFilter_States_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_api__NetworkConnectionsFilter_States_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoString_", ref=ans);
  
  ans
  
}

attr(`api__NetworkConnectionsFilter_States_get`, 'returnType') = '_p_GoString_'
attr(`api__NetworkConnectionsFilter_States_get`, "inputTypes") = c('_p_api__NetworkConnectionsFilter')
class(`api__NetworkConnectionsFilter_States_get`) = c("SWIGFunction", class('api__NetworkConnectionsFilter_States_get'))

# Start of api__NetworkConnectionsFilter_Direction_set

`api__NetworkConnectionsFilter_Direction_set` = function(self, s_Direction)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Direction, "ExternalReference")) s_Direction = slot(s_Direction,"ref") 
  ;.Call('R_swig_api__NetworkConnectionsFilter_Direction_set', self, s_Direction, PACKAGE='skycoin');
  
}

attr(`api__NetworkConnectionsFilter_Direction_set`, 'returnType') = 'void'
attr(`api__NetworkConnectionsFilter_Direction_set`, "inputTypes") = c('_p_api__NetworkConnectionsFilter', '_p_GoString_')
class(`api__NetworkConnectionsFilter_Direction_set`) = c("SWIGFunction", class('api__NetworkConnectionsFilter_Direction_set'))

# Start of api__NetworkConnectionsFilter_Direction_get

`api__NetworkConnectionsFilter_Direction_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_api__NetworkConnectionsFilter_Direction_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoString_", ref=ans);
  
  ans
  
}

attr(`api__NetworkConnectionsFilter_Direction_get`, 'returnType') = '_p_GoString_'
attr(`api__NetworkConnectionsFilter_Direction_get`, "inputTypes") = c('_p_api__NetworkConnectionsFilter')
class(`api__NetworkConnectionsFilter_Direction_get`) = c("SWIGFunction", class('api__NetworkConnectionsFilter_Direction_get'))

# Start of new_api__NetworkConnectionsFilter

`api__NetworkConnectionsFilter` = function()
{
  ;ans = .Call('R_swig_new_api__NetworkConnectionsFilter', PACKAGE='skycoin');
  ans <- new("_p_api__NetworkConnectionsFilter", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_api__NetworkConnectionsFilter)
  ans
  
}

attr(`api__NetworkConnectionsFilter`, 'returnType') = '_p_api__NetworkConnectionsFilter'
class(`api__NetworkConnectionsFilter`) = c("SWIGFunction", class('api__NetworkConnectionsFilter'))

# Start of delete_api__NetworkConnectionsFilter

`delete_api__NetworkConnectionsFilter` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_api__NetworkConnectionsFilter', self, PACKAGE='skycoin');
  
}

attr(`delete_api__NetworkConnectionsFilter`, 'returnType') = 'void'
attr(`delete_api__NetworkConnectionsFilter`, "inputTypes") = c('_p_api__NetworkConnectionsFilter')
class(`delete_api__NetworkConnectionsFilter`) = c("SWIGFunction", class('delete_api__NetworkConnectionsFilter'))

# Start of accessor method for api__NetworkConnectionsFilter
setMethod('$', '_p_api__NetworkConnectionsFilter', function(x, name)

{
  accessorFuns = list('States' = api__NetworkConnectionsFilter_States_get, 'Direction' = api__NetworkConnectionsFilter_Direction_get);
  vaccessors = c('States', 'Direction');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for api__NetworkConnectionsFilter
# Start of accessor method for api__NetworkConnectionsFilter
setMethod('$<-', '_p_api__NetworkConnectionsFilter', function(x, name, value)

{
  accessorFuns = list('States' = api__NetworkConnectionsFilter_States_set, 'Direction' = api__NetworkConnectionsFilter_Direction_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_api__NetworkConnectionsFilter', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('States' = api__NetworkConnectionsFilter_States_set, 'Direction' = api__NetworkConnectionsFilter_Direction_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for api__NetworkConnectionsFilter
setMethod('delete', '_p_api__NetworkConnectionsFilter', function(obj) {delete_api__NetworkConnectionsFilter(obj)})
# Start definition of copy functions & methods for api__NetworkConnectionsFilter
CopyToR_api__NetworkConnectionsFilter = function(value, obj = new("api__NetworkConnectionsFilter"))
{
  obj;
}



CopyToC_api__NetworkConnectionsFilter = function(value, obj)
{
  obj
}



# Start definition of copy methods for api__NetworkConnectionsFilter
setMethod('copyToR', '_p_api__NetworkConnectionsFilter', CopyToR_api__NetworkConnectionsFilter);
setMethod('copyToC', 'api__NetworkConnectionsFilter', CopyToC_api__NetworkConnectionsFilter);

# End definition of copy methods for api__NetworkConnectionsFilter
# End definition of copy functions & methods for api__NetworkConnectionsFilter
# Start of cipher__Address_isEqual

`cipher__Address_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher__Address_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher__Address_isEqual`, 'returnType') = 'integer'
attr(`cipher__Address_isEqual`, "inputTypes") = c('_p_cipher__Address', '_p_cipher__Address')
class(`cipher__Address_isEqual`) = c("SWIGFunction", class('cipher__Address_isEqual'))

# Start of cipher__Address_Version_set

`cipher__Address_Version_set` = function(self, s_Version)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Version = as.integer(s_Version);
  
  if(length(s_Version) > 1) {
    warning("using only the first element of s_Version");
  };
  
  ;.Call('R_swig_cipher__Address_Version_set', self, s_Version, PACKAGE='skycoin');
  
}

attr(`cipher__Address_Version_set`, 'returnType') = 'void'
attr(`cipher__Address_Version_set`, "inputTypes") = c('_p_cipher__Address', 'integer')
class(`cipher__Address_Version_set`) = c("SWIGFunction", class('cipher__Address_Version_set'))

# Start of cipher__Address_Version_get

`cipher__Address_Version_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher__Address_Version_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher__Address_Version_get`, 'returnType') = 'integer'
attr(`cipher__Address_Version_get`, "inputTypes") = c('_p_cipher__Address')
class(`cipher__Address_Version_get`) = c("SWIGFunction", class('cipher__Address_Version_get'))

# Start of cipher__Address_Key_set

`cipher__Address_Key_set` = function(self, s_Key)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_Key))
  assert(all(sapply(s_Key, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_Key) >= 20)
  
  ;.Call('R_swig_cipher__Address_Key_set', self, s_Key, PACKAGE='skycoin');
  
}

attr(`cipher__Address_Key_set`, 'returnType') = 'void'
attr(`cipher__Address_Key_set`, "inputTypes") = c('_p_cipher__Address', '_p_GoUint8_')
class(`cipher__Address_Key_set`) = c("SWIGFunction", class('cipher__Address_Key_set'))

# Start of cipher__Address_Key_get

`cipher__Address_Key_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher__Address_Key_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`cipher__Address_Key_get`, 'returnType') = '_p_GoUint8_'
attr(`cipher__Address_Key_get`, "inputTypes") = c('_p_cipher__Address')
class(`cipher__Address_Key_get`) = c("SWIGFunction", class('cipher__Address_Key_get'))

# Start of new_cipher__Address

`cipher__Address` = function()
{
  ;ans = .Call('R_swig_new_cipher__Address', PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher__Address)
  ans
  
}

attr(`cipher__Address`, 'returnType') = '_p_cipher__Address'
class(`cipher__Address`) = c("SWIGFunction", class('cipher__Address'))

# Start of delete_cipher__Address

`delete_cipher__Address` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher__Address', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher__Address`, 'returnType') = 'void'
attr(`delete_cipher__Address`, "inputTypes") = c('_p_cipher__Address')
class(`delete_cipher__Address`) = c("SWIGFunction", class('delete_cipher__Address'))

# Start of accessor method for cipher__Address
setMethod('$', '_p_cipher__Address', function(x, name)

{
  accessorFuns = list('isEqual' = cipher__Address_isEqual, 'Version' = cipher__Address_Version_get, 'Key' = cipher__Address_Key_get);
  vaccessors = c('Version', 'Key');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher__Address
# Start of accessor method for cipher__Address
setMethod('$<-', '_p_cipher__Address', function(x, name, value)

{
  accessorFuns = list('Version' = cipher__Address_Version_set, 'Key' = cipher__Address_Key_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher__Address', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Version' = cipher__Address_Version_set, 'Key' = cipher__Address_Key_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher__Address
setMethod('delete', '_p_cipher__Address', function(obj) {delete_cipher__Address(obj)})
# Start definition of copy functions & methods for cipher__Address
CopyToR_cipher__Address = function(value, obj = new("cipher__Address"))
{
  obj@Version = value$Version;
  obj;
}



CopyToC_cipher__Address = function(value, obj)
{
  obj$Version = value@Version;
  obj
}



# Start definition of copy methods for cipher__Address
setMethod('copyToR', '_p_cipher__Address', CopyToR_cipher__Address);
setMethod('copyToC', 'cipher__Address', CopyToC_cipher__Address);

# End definition of copy methods for cipher__Address
# End definition of copy functions & methods for cipher__Address
# Start of cipher__BitcoinAddress_isEqual

`cipher__BitcoinAddress_isEqual` = function(self, a, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(a, "ExternalReference")) a = slot(a,"ref") 
  ;.Call('R_swig_cipher__BitcoinAddress_isEqual', self, a, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher__BitcoinAddress_isEqual`, 'returnType') = 'integer'
attr(`cipher__BitcoinAddress_isEqual`, "inputTypes") = c('_p_cipher__BitcoinAddress', '_p_cipher__BitcoinAddress')
class(`cipher__BitcoinAddress_isEqual`) = c("SWIGFunction", class('cipher__BitcoinAddress_isEqual'))

# Start of cipher__BitcoinAddress_Version_set

`cipher__BitcoinAddress_Version_set` = function(self, s_Version)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Version = as.integer(s_Version);
  
  if(length(s_Version) > 1) {
    warning("using only the first element of s_Version");
  };
  
  ;.Call('R_swig_cipher__BitcoinAddress_Version_set', self, s_Version, PACKAGE='skycoin');
  
}

attr(`cipher__BitcoinAddress_Version_set`, 'returnType') = 'void'
attr(`cipher__BitcoinAddress_Version_set`, "inputTypes") = c('_p_cipher__BitcoinAddress', 'integer')
class(`cipher__BitcoinAddress_Version_set`) = c("SWIGFunction", class('cipher__BitcoinAddress_Version_set'))

# Start of cipher__BitcoinAddress_Version_get

`cipher__BitcoinAddress_Version_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cipher__BitcoinAddress_Version_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cipher__BitcoinAddress_Version_get`, 'returnType') = 'integer'
attr(`cipher__BitcoinAddress_Version_get`, "inputTypes") = c('_p_cipher__BitcoinAddress')
class(`cipher__BitcoinAddress_Version_get`) = c("SWIGFunction", class('cipher__BitcoinAddress_Version_get'))

# Start of cipher__BitcoinAddress_Key_set

`cipher__BitcoinAddress_Key_set` = function(self, s_Key)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_Key))
  assert(all(sapply(s_Key, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_Key) >= 20)
  
  ;.Call('R_swig_cipher__BitcoinAddress_Key_set', self, s_Key, PACKAGE='skycoin');
  
}

attr(`cipher__BitcoinAddress_Key_set`, 'returnType') = 'void'
attr(`cipher__BitcoinAddress_Key_set`, "inputTypes") = c('_p_cipher__BitcoinAddress', '_p_GoUint8_')
class(`cipher__BitcoinAddress_Key_set`) = c("SWIGFunction", class('cipher__BitcoinAddress_Key_set'))

# Start of cipher__BitcoinAddress_Key_get

`cipher__BitcoinAddress_Key_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cipher__BitcoinAddress_Key_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`cipher__BitcoinAddress_Key_get`, 'returnType') = '_p_GoUint8_'
attr(`cipher__BitcoinAddress_Key_get`, "inputTypes") = c('_p_cipher__BitcoinAddress')
class(`cipher__BitcoinAddress_Key_get`) = c("SWIGFunction", class('cipher__BitcoinAddress_Key_get'))

# Start of new_cipher__BitcoinAddress

`cipher__BitcoinAddress` = function()
{
  ;ans = .Call('R_swig_new_cipher__BitcoinAddress', PACKAGE='skycoin');
  ans <- new("_p_cipher__BitcoinAddress", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cipher__BitcoinAddress)
  ans
  
}

attr(`cipher__BitcoinAddress`, 'returnType') = '_p_cipher__BitcoinAddress'
class(`cipher__BitcoinAddress`) = c("SWIGFunction", class('cipher__BitcoinAddress'))

# Start of delete_cipher__BitcoinAddress

`delete_cipher__BitcoinAddress` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cipher__BitcoinAddress', self, PACKAGE='skycoin');
  
}

attr(`delete_cipher__BitcoinAddress`, 'returnType') = 'void'
attr(`delete_cipher__BitcoinAddress`, "inputTypes") = c('_p_cipher__BitcoinAddress')
class(`delete_cipher__BitcoinAddress`) = c("SWIGFunction", class('delete_cipher__BitcoinAddress'))

# Start of accessor method for cipher__BitcoinAddress
setMethod('$', '_p_cipher__BitcoinAddress', function(x, name)

{
  accessorFuns = list('isEqual' = cipher__BitcoinAddress_isEqual, 'Version' = cipher__BitcoinAddress_Version_get, 'Key' = cipher__BitcoinAddress_Key_get);
  vaccessors = c('Version', 'Key');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cipher__BitcoinAddress
# Start of accessor method for cipher__BitcoinAddress
setMethod('$<-', '_p_cipher__BitcoinAddress', function(x, name, value)

{
  accessorFuns = list('Version' = cipher__BitcoinAddress_Version_set, 'Key' = cipher__BitcoinAddress_Key_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cipher__BitcoinAddress', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Version' = cipher__BitcoinAddress_Version_set, 'Key' = cipher__BitcoinAddress_Key_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cipher__BitcoinAddress
setMethod('delete', '_p_cipher__BitcoinAddress', function(obj) {delete_cipher__BitcoinAddress(obj)})
# Start definition of copy functions & methods for cipher__BitcoinAddress
CopyToR_cipher__BitcoinAddress = function(value, obj = new("cipher__BitcoinAddress"))
{
  obj@Version = value$Version;
  obj;
}



CopyToC_cipher__BitcoinAddress = function(value, obj)
{
  obj$Version = value@Version;
  obj
}



# Start definition of copy methods for cipher__BitcoinAddress
setMethod('copyToR', '_p_cipher__BitcoinAddress', CopyToR_cipher__BitcoinAddress);
setMethod('copyToC', 'cipher__BitcoinAddress', CopyToC_cipher__BitcoinAddress);

# End definition of copy methods for cipher__BitcoinAddress
# End definition of copy functions & methods for cipher__BitcoinAddress
# Start of encrypt__ScryptChacha20poly1305_N_set

`encrypt__ScryptChacha20poly1305_N_set` = function(self, s_N)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_N = as.integer(s_N);
  
  if(length(s_N) > 1) {
    warning("using only the first element of s_N");
  };
  
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_N_set', self, s_N, PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_N_set`, 'returnType') = 'void'
attr(`encrypt__ScryptChacha20poly1305_N_set`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305', 'integer')
class(`encrypt__ScryptChacha20poly1305_N_set`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_N_set'))

# Start of encrypt__ScryptChacha20poly1305_N_get

`encrypt__ScryptChacha20poly1305_N_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_N_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_N_get`, 'returnType') = 'integer'
attr(`encrypt__ScryptChacha20poly1305_N_get`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305')
class(`encrypt__ScryptChacha20poly1305_N_get`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_N_get'))

# Start of encrypt__ScryptChacha20poly1305_R_set

`encrypt__ScryptChacha20poly1305_R_set` = function(self, s_R)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_R = as.integer(s_R);
  
  if(length(s_R) > 1) {
    warning("using only the first element of s_R");
  };
  
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_R_set', self, s_R, PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_R_set`, 'returnType') = 'void'
attr(`encrypt__ScryptChacha20poly1305_R_set`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305', 'integer')
class(`encrypt__ScryptChacha20poly1305_R_set`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_R_set'))

# Start of encrypt__ScryptChacha20poly1305_R_get

`encrypt__ScryptChacha20poly1305_R_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_R_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_R_get`, 'returnType') = 'integer'
attr(`encrypt__ScryptChacha20poly1305_R_get`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305')
class(`encrypt__ScryptChacha20poly1305_R_get`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_R_get'))

# Start of encrypt__ScryptChacha20poly1305_P_set

`encrypt__ScryptChacha20poly1305_P_set` = function(self, s_P)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_P = as.integer(s_P);
  
  if(length(s_P) > 1) {
    warning("using only the first element of s_P");
  };
  
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_P_set', self, s_P, PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_P_set`, 'returnType') = 'void'
attr(`encrypt__ScryptChacha20poly1305_P_set`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305', 'integer')
class(`encrypt__ScryptChacha20poly1305_P_set`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_P_set'))

# Start of encrypt__ScryptChacha20poly1305_P_get

`encrypt__ScryptChacha20poly1305_P_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_P_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_P_get`, 'returnType') = 'integer'
attr(`encrypt__ScryptChacha20poly1305_P_get`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305')
class(`encrypt__ScryptChacha20poly1305_P_get`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_P_get'))

# Start of encrypt__ScryptChacha20poly1305_KeyLen_set

`encrypt__ScryptChacha20poly1305_KeyLen_set` = function(self, s_KeyLen)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_KeyLen = as.integer(s_KeyLen);
  
  if(length(s_KeyLen) > 1) {
    warning("using only the first element of s_KeyLen");
  };
  
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_KeyLen_set', self, s_KeyLen, PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_KeyLen_set`, 'returnType') = 'void'
attr(`encrypt__ScryptChacha20poly1305_KeyLen_set`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305', 'integer')
class(`encrypt__ScryptChacha20poly1305_KeyLen_set`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_KeyLen_set'))

# Start of encrypt__ScryptChacha20poly1305_KeyLen_get

`encrypt__ScryptChacha20poly1305_KeyLen_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_encrypt__ScryptChacha20poly1305_KeyLen_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`encrypt__ScryptChacha20poly1305_KeyLen_get`, 'returnType') = 'integer'
attr(`encrypt__ScryptChacha20poly1305_KeyLen_get`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305')
class(`encrypt__ScryptChacha20poly1305_KeyLen_get`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305_KeyLen_get'))

# Start of new_encrypt__ScryptChacha20poly1305

`encrypt__ScryptChacha20poly1305` = function()
{
  ;ans = .Call('R_swig_new_encrypt__ScryptChacha20poly1305', PACKAGE='skycoin');
  ans <- new("_p_encrypt__ScryptChacha20poly1305", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_encrypt__ScryptChacha20poly1305)
  ans
  
}

attr(`encrypt__ScryptChacha20poly1305`, 'returnType') = '_p_encrypt__ScryptChacha20poly1305'
class(`encrypt__ScryptChacha20poly1305`) = c("SWIGFunction", class('encrypt__ScryptChacha20poly1305'))

# Start of delete_encrypt__ScryptChacha20poly1305

`delete_encrypt__ScryptChacha20poly1305` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_encrypt__ScryptChacha20poly1305', self, PACKAGE='skycoin');
  
}

attr(`delete_encrypt__ScryptChacha20poly1305`, 'returnType') = 'void'
attr(`delete_encrypt__ScryptChacha20poly1305`, "inputTypes") = c('_p_encrypt__ScryptChacha20poly1305')
class(`delete_encrypt__ScryptChacha20poly1305`) = c("SWIGFunction", class('delete_encrypt__ScryptChacha20poly1305'))

# Start of accessor method for encrypt__ScryptChacha20poly1305
setMethod('$', '_p_encrypt__ScryptChacha20poly1305', function(x, name)

{
  accessorFuns = list('N' = encrypt__ScryptChacha20poly1305_N_get, 'R' = encrypt__ScryptChacha20poly1305_R_get, 'P' = encrypt__ScryptChacha20poly1305_P_get, 'KeyLen' = encrypt__ScryptChacha20poly1305_KeyLen_get);
  vaccessors = c('N', 'R', 'P', 'KeyLen');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for encrypt__ScryptChacha20poly1305
# Start of accessor method for encrypt__ScryptChacha20poly1305
setMethod('$<-', '_p_encrypt__ScryptChacha20poly1305', function(x, name, value)

{
  accessorFuns = list('N' = encrypt__ScryptChacha20poly1305_N_set, 'R' = encrypt__ScryptChacha20poly1305_R_set, 'P' = encrypt__ScryptChacha20poly1305_P_set, 'KeyLen' = encrypt__ScryptChacha20poly1305_KeyLen_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_encrypt__ScryptChacha20poly1305', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('N' = encrypt__ScryptChacha20poly1305_N_set, 'R' = encrypt__ScryptChacha20poly1305_R_set, 'P' = encrypt__ScryptChacha20poly1305_P_set, 'KeyLen' = encrypt__ScryptChacha20poly1305_KeyLen_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for encrypt__ScryptChacha20poly1305
setMethod('delete', '_p_encrypt__ScryptChacha20poly1305', function(obj) {delete_encrypt__ScryptChacha20poly1305(obj)})
# Start definition of copy functions & methods for encrypt__ScryptChacha20poly1305
CopyToR_encrypt__ScryptChacha20poly1305 = function(value, obj = new("encrypt__ScryptChacha20poly1305"))
{
  obj@N = value$N;
  obj@R = value$R;
  obj@P = value$P;
  obj@KeyLen = value$KeyLen;
  obj;
}



CopyToC_encrypt__ScryptChacha20poly1305 = function(value, obj)
{
  obj$N = value@N;
  obj$R = value@R;
  obj$P = value@P;
  obj$KeyLen = value@KeyLen;
  obj
}



# Start definition of copy methods for encrypt__ScryptChacha20poly1305
setMethod('copyToR', '_p_encrypt__ScryptChacha20poly1305', CopyToR_encrypt__ScryptChacha20poly1305);
setMethod('copyToC', 'encrypt__ScryptChacha20poly1305', CopyToC_encrypt__ScryptChacha20poly1305);

# End definition of copy methods for encrypt__ScryptChacha20poly1305
# End definition of copy functions & methods for encrypt__ScryptChacha20poly1305
# Start of secp256k1go__Field_n_set

`secp256k1go__Field_n_set` = function(self, s_n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_n))
  assert(all(sapply(s_n, class) == "_p_GoUint32_"));
  
  
#  assert(length(s_n) >= 10)
  
  ;.Call('R_swig_secp256k1go__Field_n_set', self, s_n, PACKAGE='skycoin');
  
}

attr(`secp256k1go__Field_n_set`, 'returnType') = 'void'
attr(`secp256k1go__Field_n_set`, "inputTypes") = c('_p_secp256k1go__Field', '_p_GoUint32_')
class(`secp256k1go__Field_n_set`) = c("SWIGFunction", class('secp256k1go__Field_n_set'))

# Start of secp256k1go__Field_n_get

`secp256k1go__Field_n_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_secp256k1go__Field_n_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint32_", ref=ans) ;
  
  ans
  
}

attr(`secp256k1go__Field_n_get`, 'returnType') = '_p_GoUint32_'
attr(`secp256k1go__Field_n_get`, "inputTypes") = c('_p_secp256k1go__Field')
class(`secp256k1go__Field_n_get`) = c("SWIGFunction", class('secp256k1go__Field_n_get'))

# Start of new_secp256k1go__Field

`secp256k1go__Field` = function()
{
  ;ans = .Call('R_swig_new_secp256k1go__Field', PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__Field", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_secp256k1go__Field)
  ans
  
}

attr(`secp256k1go__Field`, 'returnType') = '_p_secp256k1go__Field'
class(`secp256k1go__Field`) = c("SWIGFunction", class('secp256k1go__Field'))

# Start of delete_secp256k1go__Field

`delete_secp256k1go__Field` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_secp256k1go__Field', self, PACKAGE='skycoin');
  
}

attr(`delete_secp256k1go__Field`, 'returnType') = 'void'
attr(`delete_secp256k1go__Field`, "inputTypes") = c('_p_secp256k1go__Field')
class(`delete_secp256k1go__Field`) = c("SWIGFunction", class('delete_secp256k1go__Field'))

# Start of accessor method for secp256k1go__Field
setMethod('$', '_p_secp256k1go__Field', function(x, name)

{
  accessorFuns = list('n' = secp256k1go__Field_n_get);
  vaccessors = c('n');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for secp256k1go__Field
# Start of accessor method for secp256k1go__Field
setMethod('$<-', '_p_secp256k1go__Field', function(x, name, value)

{
  accessorFuns = list('n' = secp256k1go__Field_n_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_secp256k1go__Field', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('n' = secp256k1go__Field_n_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for secp256k1go__Field
setMethod('delete', '_p_secp256k1go__Field', function(obj) {delete_secp256k1go__Field(obj)})
# Start definition of copy functions & methods for secp256k1go__Field
CopyToR_secp256k1go__Field = function(value, obj = new("secp256k1go__Field"))
{
  obj@n = value$n;
  obj;
}



CopyToC_secp256k1go__Field = function(value, obj)
{
  obj$n = value@n;
  obj
}



# Start definition of copy methods for secp256k1go__Field
setMethod('copyToR', '_p_secp256k1go__Field', CopyToR_secp256k1go__Field);
setMethod('copyToC', 'secp256k1go__Field', CopyToC_secp256k1go__Field);

# End definition of copy methods for secp256k1go__Field
# End definition of copy functions & methods for secp256k1go__Field
# Start of secp256k1go__XY_X_set

`secp256k1go__XY_X_set` = function(self, s_X)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_X, "ExternalReference")) s_X = slot(s_X,"ref") 
  ;.Call('R_swig_secp256k1go__XY_X_set', self, s_X, PACKAGE='skycoin');
  
}

attr(`secp256k1go__XY_X_set`, 'returnType') = 'void'
attr(`secp256k1go__XY_X_set`, "inputTypes") = c('_p_secp256k1go__XY', '_p_secp256k1go__Field')
class(`secp256k1go__XY_X_set`) = c("SWIGFunction", class('secp256k1go__XY_X_set'))

# Start of secp256k1go__XY_X_get

`secp256k1go__XY_X_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_secp256k1go__XY_X_get', self, PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__Field", ref=ans) ;
  
  ans
  
}

attr(`secp256k1go__XY_X_get`, 'returnType') = '_p_secp256k1go__Field'
attr(`secp256k1go__XY_X_get`, "inputTypes") = c('_p_secp256k1go__XY')
class(`secp256k1go__XY_X_get`) = c("SWIGFunction", class('secp256k1go__XY_X_get'))

# Start of secp256k1go__XY_Y_set

`secp256k1go__XY_Y_set` = function(self, s_Y)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Y, "ExternalReference")) s_Y = slot(s_Y,"ref") 
  ;.Call('R_swig_secp256k1go__XY_Y_set', self, s_Y, PACKAGE='skycoin');
  
}

attr(`secp256k1go__XY_Y_set`, 'returnType') = 'void'
attr(`secp256k1go__XY_Y_set`, "inputTypes") = c('_p_secp256k1go__XY', '_p_secp256k1go__Field')
class(`secp256k1go__XY_Y_set`) = c("SWIGFunction", class('secp256k1go__XY_Y_set'))

# Start of secp256k1go__XY_Y_get

`secp256k1go__XY_Y_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_secp256k1go__XY_Y_get', self, PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__Field", ref=ans) ;
  
  ans
  
}

attr(`secp256k1go__XY_Y_get`, 'returnType') = '_p_secp256k1go__Field'
attr(`secp256k1go__XY_Y_get`, "inputTypes") = c('_p_secp256k1go__XY')
class(`secp256k1go__XY_Y_get`) = c("SWIGFunction", class('secp256k1go__XY_Y_get'))

# Start of secp256k1go__XY_Infinity_set

`secp256k1go__XY_Infinity_set` = function(self, s_Infinity)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Infinity = as.integer(s_Infinity);
  
  if(length(s_Infinity) > 1) {
    warning("using only the first element of s_Infinity");
  };
  
  ;.Call('R_swig_secp256k1go__XY_Infinity_set', self, s_Infinity, PACKAGE='skycoin');
  
}

attr(`secp256k1go__XY_Infinity_set`, 'returnType') = 'void'
attr(`secp256k1go__XY_Infinity_set`, "inputTypes") = c('_p_secp256k1go__XY', 'integer')
class(`secp256k1go__XY_Infinity_set`) = c("SWIGFunction", class('secp256k1go__XY_Infinity_set'))

# Start of secp256k1go__XY_Infinity_get

`secp256k1go__XY_Infinity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_secp256k1go__XY_Infinity_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`secp256k1go__XY_Infinity_get`, 'returnType') = 'integer'
attr(`secp256k1go__XY_Infinity_get`, "inputTypes") = c('_p_secp256k1go__XY')
class(`secp256k1go__XY_Infinity_get`) = c("SWIGFunction", class('secp256k1go__XY_Infinity_get'))

# Start of new_secp256k1go__XY

`secp256k1go__XY` = function()
{
  ;ans = .Call('R_swig_new_secp256k1go__XY', PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__XY", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_secp256k1go__XY)
  ans
  
}

attr(`secp256k1go__XY`, 'returnType') = '_p_secp256k1go__XY'
class(`secp256k1go__XY`) = c("SWIGFunction", class('secp256k1go__XY'))

# Start of delete_secp256k1go__XY

`delete_secp256k1go__XY` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_secp256k1go__XY', self, PACKAGE='skycoin');
  
}

attr(`delete_secp256k1go__XY`, 'returnType') = 'void'
attr(`delete_secp256k1go__XY`, "inputTypes") = c('_p_secp256k1go__XY')
class(`delete_secp256k1go__XY`) = c("SWIGFunction", class('delete_secp256k1go__XY'))

# Start of accessor method for secp256k1go__XY
setMethod('$', '_p_secp256k1go__XY', function(x, name)

{
  accessorFuns = list('X' = secp256k1go__XY_X_get, 'Y' = secp256k1go__XY_Y_get, 'Infinity' = secp256k1go__XY_Infinity_get);
  vaccessors = c('X', 'Y', 'Infinity');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for secp256k1go__XY
# Start of accessor method for secp256k1go__XY
setMethod('$<-', '_p_secp256k1go__XY', function(x, name, value)

{
  accessorFuns = list('X' = secp256k1go__XY_X_set, 'Y' = secp256k1go__XY_Y_set, 'Infinity' = secp256k1go__XY_Infinity_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_secp256k1go__XY', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('X' = secp256k1go__XY_X_set, 'Y' = secp256k1go__XY_Y_set, 'Infinity' = secp256k1go__XY_Infinity_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for secp256k1go__XY
setMethod('delete', '_p_secp256k1go__XY', function(obj) {delete_secp256k1go__XY(obj)})
# Start definition of copy functions & methods for secp256k1go__XY
CopyToR_secp256k1go__XY = function(value, obj = new("secp256k1go__XY"))
{
  obj@Infinity = value$Infinity;
  obj;
}



CopyToC_secp256k1go__XY = function(value, obj)
{
  obj$Infinity = value@Infinity;
  obj
}



# Start definition of copy methods for secp256k1go__XY
setMethod('copyToR', '_p_secp256k1go__XY', CopyToR_secp256k1go__XY);
setMethod('copyToC', 'secp256k1go__XY', CopyToC_secp256k1go__XY);

# End definition of copy methods for secp256k1go__XY
# End definition of copy functions & methods for secp256k1go__XY
# Start of secp256k1go__XYZ_X_set

`secp256k1go__XYZ_X_set` = function(self, s_X)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_X, "ExternalReference")) s_X = slot(s_X,"ref") 
  ;.Call('R_swig_secp256k1go__XYZ_X_set', self, s_X, PACKAGE='skycoin');
  
}

attr(`secp256k1go__XYZ_X_set`, 'returnType') = 'void'
attr(`secp256k1go__XYZ_X_set`, "inputTypes") = c('_p_secp256k1go__XYZ', '_p_secp256k1go__Field')
class(`secp256k1go__XYZ_X_set`) = c("SWIGFunction", class('secp256k1go__XYZ_X_set'))

# Start of secp256k1go__XYZ_X_get

`secp256k1go__XYZ_X_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_secp256k1go__XYZ_X_get', self, PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__Field", ref=ans) ;
  
  ans
  
}

attr(`secp256k1go__XYZ_X_get`, 'returnType') = '_p_secp256k1go__Field'
attr(`secp256k1go__XYZ_X_get`, "inputTypes") = c('_p_secp256k1go__XYZ')
class(`secp256k1go__XYZ_X_get`) = c("SWIGFunction", class('secp256k1go__XYZ_X_get'))

# Start of secp256k1go__XYZ_Y_set

`secp256k1go__XYZ_Y_set` = function(self, s_Y)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Y, "ExternalReference")) s_Y = slot(s_Y,"ref") 
  ;.Call('R_swig_secp256k1go__XYZ_Y_set', self, s_Y, PACKAGE='skycoin');
  
}

attr(`secp256k1go__XYZ_Y_set`, 'returnType') = 'void'
attr(`secp256k1go__XYZ_Y_set`, "inputTypes") = c('_p_secp256k1go__XYZ', '_p_secp256k1go__Field')
class(`secp256k1go__XYZ_Y_set`) = c("SWIGFunction", class('secp256k1go__XYZ_Y_set'))

# Start of secp256k1go__XYZ_Y_get

`secp256k1go__XYZ_Y_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_secp256k1go__XYZ_Y_get', self, PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__Field", ref=ans) ;
  
  ans
  
}

attr(`secp256k1go__XYZ_Y_get`, 'returnType') = '_p_secp256k1go__Field'
attr(`secp256k1go__XYZ_Y_get`, "inputTypes") = c('_p_secp256k1go__XYZ')
class(`secp256k1go__XYZ_Y_get`) = c("SWIGFunction", class('secp256k1go__XYZ_Y_get'))

# Start of secp256k1go__XYZ_Z_set

`secp256k1go__XYZ_Z_set` = function(self, s_Z)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Z, "ExternalReference")) s_Z = slot(s_Z,"ref") 
  ;.Call('R_swig_secp256k1go__XYZ_Z_set', self, s_Z, PACKAGE='skycoin');
  
}

attr(`secp256k1go__XYZ_Z_set`, 'returnType') = 'void'
attr(`secp256k1go__XYZ_Z_set`, "inputTypes") = c('_p_secp256k1go__XYZ', '_p_secp256k1go__Field')
class(`secp256k1go__XYZ_Z_set`) = c("SWIGFunction", class('secp256k1go__XYZ_Z_set'))

# Start of secp256k1go__XYZ_Z_get

`secp256k1go__XYZ_Z_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_secp256k1go__XYZ_Z_get', self, PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__Field", ref=ans) ;
  
  ans
  
}

attr(`secp256k1go__XYZ_Z_get`, 'returnType') = '_p_secp256k1go__Field'
attr(`secp256k1go__XYZ_Z_get`, "inputTypes") = c('_p_secp256k1go__XYZ')
class(`secp256k1go__XYZ_Z_get`) = c("SWIGFunction", class('secp256k1go__XYZ_Z_get'))

# Start of secp256k1go__XYZ_Infinity_set

`secp256k1go__XYZ_Infinity_set` = function(self, s_Infinity)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Infinity = as.integer(s_Infinity);
  
  if(length(s_Infinity) > 1) {
    warning("using only the first element of s_Infinity");
  };
  
  ;.Call('R_swig_secp256k1go__XYZ_Infinity_set', self, s_Infinity, PACKAGE='skycoin');
  
}

attr(`secp256k1go__XYZ_Infinity_set`, 'returnType') = 'void'
attr(`secp256k1go__XYZ_Infinity_set`, "inputTypes") = c('_p_secp256k1go__XYZ', 'integer')
class(`secp256k1go__XYZ_Infinity_set`) = c("SWIGFunction", class('secp256k1go__XYZ_Infinity_set'))

# Start of secp256k1go__XYZ_Infinity_get

`secp256k1go__XYZ_Infinity_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_secp256k1go__XYZ_Infinity_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`secp256k1go__XYZ_Infinity_get`, 'returnType') = 'integer'
attr(`secp256k1go__XYZ_Infinity_get`, "inputTypes") = c('_p_secp256k1go__XYZ')
class(`secp256k1go__XYZ_Infinity_get`) = c("SWIGFunction", class('secp256k1go__XYZ_Infinity_get'))

# Start of new_secp256k1go__XYZ

`secp256k1go__XYZ` = function()
{
  ;ans = .Call('R_swig_new_secp256k1go__XYZ', PACKAGE='skycoin');
  ans <- new("_p_secp256k1go__XYZ", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_secp256k1go__XYZ)
  ans
  
}

attr(`secp256k1go__XYZ`, 'returnType') = '_p_secp256k1go__XYZ'
class(`secp256k1go__XYZ`) = c("SWIGFunction", class('secp256k1go__XYZ'))

# Start of delete_secp256k1go__XYZ

`delete_secp256k1go__XYZ` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_secp256k1go__XYZ', self, PACKAGE='skycoin');
  
}

attr(`delete_secp256k1go__XYZ`, 'returnType') = 'void'
attr(`delete_secp256k1go__XYZ`, "inputTypes") = c('_p_secp256k1go__XYZ')
class(`delete_secp256k1go__XYZ`) = c("SWIGFunction", class('delete_secp256k1go__XYZ'))

# Start of accessor method for secp256k1go__XYZ
setMethod('$', '_p_secp256k1go__XYZ', function(x, name)

{
  accessorFuns = list('X' = secp256k1go__XYZ_X_get, 'Y' = secp256k1go__XYZ_Y_get, 'Z' = secp256k1go__XYZ_Z_get, 'Infinity' = secp256k1go__XYZ_Infinity_get);
  vaccessors = c('X', 'Y', 'Z', 'Infinity');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for secp256k1go__XYZ
# Start of accessor method for secp256k1go__XYZ
setMethod('$<-', '_p_secp256k1go__XYZ', function(x, name, value)

{
  accessorFuns = list('X' = secp256k1go__XYZ_X_set, 'Y' = secp256k1go__XYZ_Y_set, 'Z' = secp256k1go__XYZ_Z_set, 'Infinity' = secp256k1go__XYZ_Infinity_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_secp256k1go__XYZ', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('X' = secp256k1go__XYZ_X_set, 'Y' = secp256k1go__XYZ_Y_set, 'Z' = secp256k1go__XYZ_Z_set, 'Infinity' = secp256k1go__XYZ_Infinity_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for secp256k1go__XYZ
setMethod('delete', '_p_secp256k1go__XYZ', function(obj) {delete_secp256k1go__XYZ(obj)})
# Start definition of copy functions & methods for secp256k1go__XYZ
CopyToR_secp256k1go__XYZ = function(value, obj = new("secp256k1go__XYZ"))
{
  obj@Infinity = value$Infinity;
  obj;
}



CopyToC_secp256k1go__XYZ = function(value, obj)
{
  obj$Infinity = value@Infinity;
  obj
}



# Start definition of copy methods for secp256k1go__XYZ
setMethod('copyToR', '_p_secp256k1go__XYZ', CopyToR_secp256k1go__XYZ);
setMethod('copyToC', 'secp256k1go__XYZ', CopyToC_secp256k1go__XYZ);

# End definition of copy methods for secp256k1go__XYZ
# End definition of copy functions & methods for secp256k1go__XYZ
# Start of cli__SendAmount_Addr_set

`cli__SendAmount_Addr_set` = function(self, s_Addr)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Addr, "ExternalReference")) s_Addr = slot(s_Addr,"ref") 
  ;.Call('R_swig_cli__SendAmount_Addr_set', self, s_Addr, PACKAGE='skycoin');
  
}

attr(`cli__SendAmount_Addr_set`, 'returnType') = 'void'
attr(`cli__SendAmount_Addr_set`, "inputTypes") = c('_p_cli__SendAmount', '_p_GoString_')
class(`cli__SendAmount_Addr_set`) = c("SWIGFunction", class('cli__SendAmount_Addr_set'))

# Start of cli__SendAmount_Addr_get

`cli__SendAmount_Addr_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_cli__SendAmount_Addr_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoString_", ref=ans);
  
  ans
  
}

attr(`cli__SendAmount_Addr_get`, 'returnType') = '_p_GoString_'
attr(`cli__SendAmount_Addr_get`, "inputTypes") = c('_p_cli__SendAmount')
class(`cli__SendAmount_Addr_get`) = c("SWIGFunction", class('cli__SendAmount_Addr_get'))

# Start of cli__SendAmount_Coins_set

`cli__SendAmount_Coins_set` = function(self, s_Coins)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Coins = as.integer(s_Coins);
  
  if(length(s_Coins) > 1) {
    warning("using only the first element of s_Coins");
  };
  
  ;.Call('R_swig_cli__SendAmount_Coins_set', self, s_Coins, PACKAGE='skycoin');
  
}

attr(`cli__SendAmount_Coins_set`, 'returnType') = 'void'
attr(`cli__SendAmount_Coins_set`, "inputTypes") = c('_p_cli__SendAmount', 'integer')
class(`cli__SendAmount_Coins_set`) = c("SWIGFunction", class('cli__SendAmount_Coins_set'))

# Start of cli__SendAmount_Coins_get

`cli__SendAmount_Coins_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_cli__SendAmount_Coins_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`cli__SendAmount_Coins_get`, 'returnType') = 'integer'
attr(`cli__SendAmount_Coins_get`, "inputTypes") = c('_p_cli__SendAmount')
class(`cli__SendAmount_Coins_get`) = c("SWIGFunction", class('cli__SendAmount_Coins_get'))

# Start of new_cli__SendAmount

`cli__SendAmount` = function()
{
  ;ans = .Call('R_swig_new_cli__SendAmount', PACKAGE='skycoin');
  ans <- new("_p_cli__SendAmount", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_cli__SendAmount)
  ans
  
}

attr(`cli__SendAmount`, 'returnType') = '_p_cli__SendAmount'
class(`cli__SendAmount`) = c("SWIGFunction", class('cli__SendAmount'))

# Start of delete_cli__SendAmount

`delete_cli__SendAmount` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_cli__SendAmount', self, PACKAGE='skycoin');
  
}

attr(`delete_cli__SendAmount`, 'returnType') = 'void'
attr(`delete_cli__SendAmount`, "inputTypes") = c('_p_cli__SendAmount')
class(`delete_cli__SendAmount`) = c("SWIGFunction", class('delete_cli__SendAmount'))

# Start of accessor method for cli__SendAmount
setMethod('$', '_p_cli__SendAmount', function(x, name)

{
  accessorFuns = list('Addr' = cli__SendAmount_Addr_get, 'Coins' = cli__SendAmount_Coins_get);
  vaccessors = c('Addr', 'Coins');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for cli__SendAmount
# Start of accessor method for cli__SendAmount
setMethod('$<-', '_p_cli__SendAmount', function(x, name, value)

{
  accessorFuns = list('Addr' = cli__SendAmount_Addr_set, 'Coins' = cli__SendAmount_Coins_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_cli__SendAmount', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Addr' = cli__SendAmount_Addr_set, 'Coins' = cli__SendAmount_Coins_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for cli__SendAmount
setMethod('delete', '_p_cli__SendAmount', function(obj) {delete_cli__SendAmount(obj)})
# Start definition of copy functions & methods for cli__SendAmount
CopyToR_cli__SendAmount = function(value, obj = new("cli__SendAmount"))
{
  obj@Coins = value$Coins;
  obj;
}



CopyToC_cli__SendAmount = function(value, obj)
{
  obj$Coins = value@Coins;
  obj
}



# Start definition of copy methods for cli__SendAmount
setMethod('copyToR', '_p_cli__SendAmount', CopyToR_cli__SendAmount);
setMethod('copyToC', 'cli__SendAmount', CopyToC_cli__SendAmount);

# End definition of copy methods for cli__SendAmount
# End definition of copy functions & methods for cli__SendAmount
# Start of coin__Transaction_isEqual

`coin__Transaction_isEqual` = function(self, t, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(t, "ExternalReference")) t = slot(t,"ref") 
  ;.Call('R_swig_coin__Transaction_isEqual', self, t, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__Transaction_isEqual`, 'returnType') = 'integer'
attr(`coin__Transaction_isEqual`, "inputTypes") = c('_p_coin__Transaction', '_p_coin__Transaction')
class(`coin__Transaction_isEqual`) = c("SWIGFunction", class('coin__Transaction_isEqual'))

# Start of coin__Transaction_GetInnerHash

`coin__Transaction_GetInnerHash` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__Transaction_GetInnerHash', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_cipher_SHA256", ref=ans);
  
  ans
  
}

attr(`coin__Transaction_GetInnerHash`, 'returnType') = '_p_cipher_SHA256'
attr(`coin__Transaction_GetInnerHash`, "inputTypes") = c('_p_coin__Transaction')
class(`coin__Transaction_GetInnerHash`) = c("SWIGFunction", class('coin__Transaction_GetInnerHash'))

# Start of coin__Transaction_Length_set

`coin__Transaction_Length_set` = function(self, s_Length)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Length = as.integer(s_Length);
  
  if(length(s_Length) > 1) {
    warning("using only the first element of s_Length");
  };
  
  ;.Call('R_swig_coin__Transaction_Length_set', self, s_Length, PACKAGE='skycoin');
  
}

attr(`coin__Transaction_Length_set`, 'returnType') = 'void'
attr(`coin__Transaction_Length_set`, "inputTypes") = c('_p_coin__Transaction', 'integer')
class(`coin__Transaction_Length_set`) = c("SWIGFunction", class('coin__Transaction_Length_set'))

# Start of coin__Transaction_Length_get

`coin__Transaction_Length_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__Transaction_Length_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__Transaction_Length_get`, 'returnType') = 'integer'
attr(`coin__Transaction_Length_get`, "inputTypes") = c('_p_coin__Transaction')
class(`coin__Transaction_Length_get`) = c("SWIGFunction", class('coin__Transaction_Length_get'))

# Start of coin__Transaction_Type_set

`coin__Transaction_Type_set` = function(self, s_Type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Type = as.integer(s_Type);
  
  if(length(s_Type) > 1) {
    warning("using only the first element of s_Type");
  };
  
  ;.Call('R_swig_coin__Transaction_Type_set', self, s_Type, PACKAGE='skycoin');
  
}

attr(`coin__Transaction_Type_set`, 'returnType') = 'void'
attr(`coin__Transaction_Type_set`, "inputTypes") = c('_p_coin__Transaction', 'integer')
class(`coin__Transaction_Type_set`) = c("SWIGFunction", class('coin__Transaction_Type_set'))

# Start of coin__Transaction_Type_get

`coin__Transaction_Type_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__Transaction_Type_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__Transaction_Type_get`, 'returnType') = 'integer'
attr(`coin__Transaction_Type_get`, "inputTypes") = c('_p_coin__Transaction')
class(`coin__Transaction_Type_get`) = c("SWIGFunction", class('coin__Transaction_Type_get'))

# Start of coin__Transaction_InnerHash_set

`coin__Transaction_InnerHash_set` = function(self, s_InnerHash)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_InnerHash))
  assert(all(sapply(s_InnerHash, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_InnerHash) >= 32)
  
  ;.Call('R_swig_coin__Transaction_InnerHash_set', self, s_InnerHash, PACKAGE='skycoin');
  
}

attr(`coin__Transaction_InnerHash_set`, 'returnType') = 'void'
attr(`coin__Transaction_InnerHash_set`, "inputTypes") = c('_p_coin__Transaction', '_p_GoUint8_')
class(`coin__Transaction_InnerHash_set`) = c("SWIGFunction", class('coin__Transaction_InnerHash_set'))

# Start of coin__Transaction_InnerHash_get

`coin__Transaction_InnerHash_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__Transaction_InnerHash_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`coin__Transaction_InnerHash_get`, 'returnType') = '_p_GoUint8_'
attr(`coin__Transaction_InnerHash_get`, "inputTypes") = c('_p_coin__Transaction')
class(`coin__Transaction_InnerHash_get`) = c("SWIGFunction", class('coin__Transaction_InnerHash_get'))

# Start of coin__Transaction_Sigs_set

`coin__Transaction_Sigs_set` = function(self, s_Sigs)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Sigs, "ExternalReference")) s_Sigs = slot(s_Sigs,"ref") 
  ;.Call('R_swig_coin__Transaction_Sigs_set', self, s_Sigs, PACKAGE='skycoin');
  
}

attr(`coin__Transaction_Sigs_set`, 'returnType') = 'void'
attr(`coin__Transaction_Sigs_set`, "inputTypes") = c('_p_coin__Transaction', '_p_GoSlice_')
class(`coin__Transaction_Sigs_set`) = c("SWIGFunction", class('coin__Transaction_Sigs_set'))

# Start of coin__Transaction_Sigs_get

`coin__Transaction_Sigs_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__Transaction_Sigs_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoSlice_", ref=ans);
  
  ans
  
}

attr(`coin__Transaction_Sigs_get`, 'returnType') = '_p_GoSlice_'
attr(`coin__Transaction_Sigs_get`, "inputTypes") = c('_p_coin__Transaction')
class(`coin__Transaction_Sigs_get`) = c("SWIGFunction", class('coin__Transaction_Sigs_get'))

# Start of coin__Transaction_In_set

`coin__Transaction_In_set` = function(self, s_In)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_In, "ExternalReference")) s_In = slot(s_In,"ref") 
  ;.Call('R_swig_coin__Transaction_In_set', self, s_In, PACKAGE='skycoin');
  
}

attr(`coin__Transaction_In_set`, 'returnType') = 'void'
attr(`coin__Transaction_In_set`, "inputTypes") = c('_p_coin__Transaction', '_p_GoSlice_')
class(`coin__Transaction_In_set`) = c("SWIGFunction", class('coin__Transaction_In_set'))

# Start of coin__Transaction_In_get

`coin__Transaction_In_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__Transaction_In_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoSlice_", ref=ans);
  
  ans
  
}

attr(`coin__Transaction_In_get`, 'returnType') = '_p_GoSlice_'
attr(`coin__Transaction_In_get`, "inputTypes") = c('_p_coin__Transaction')
class(`coin__Transaction_In_get`) = c("SWIGFunction", class('coin__Transaction_In_get'))

# Start of coin__Transaction_Out_set

`coin__Transaction_Out_set` = function(self, s_Out)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Out, "ExternalReference")) s_Out = slot(s_Out,"ref") 
  ;.Call('R_swig_coin__Transaction_Out_set', self, s_Out, PACKAGE='skycoin');
  
}

attr(`coin__Transaction_Out_set`, 'returnType') = 'void'
attr(`coin__Transaction_Out_set`, "inputTypes") = c('_p_coin__Transaction', '_p_GoSlice_')
class(`coin__Transaction_Out_set`) = c("SWIGFunction", class('coin__Transaction_Out_set'))

# Start of coin__Transaction_Out_get

`coin__Transaction_Out_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__Transaction_Out_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoSlice_", ref=ans);
  
  ans
  
}

attr(`coin__Transaction_Out_get`, 'returnType') = '_p_GoSlice_'
attr(`coin__Transaction_Out_get`, "inputTypes") = c('_p_coin__Transaction')
class(`coin__Transaction_Out_get`) = c("SWIGFunction", class('coin__Transaction_Out_get'))

# Start of new_coin__Transaction

`coin__Transaction` = function()
{
  ;ans = .Call('R_swig_new_coin__Transaction', PACKAGE='skycoin');
  ans <- new("_p_coin__Transaction", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__Transaction)
  ans
  
}

attr(`coin__Transaction`, 'returnType') = '_p_coin__Transaction'
class(`coin__Transaction`) = c("SWIGFunction", class('coin__Transaction'))

# Start of delete_coin__Transaction

`delete_coin__Transaction` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__Transaction', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__Transaction`, 'returnType') = 'void'
attr(`delete_coin__Transaction`, "inputTypes") = c('_p_coin__Transaction')
class(`delete_coin__Transaction`) = c("SWIGFunction", class('delete_coin__Transaction'))

# Start of accessor method for coin__Transaction
setMethod('$', '_p_coin__Transaction', function(x, name)

{
  accessorFuns = list('isEqual' = coin__Transaction_isEqual, 'GetInnerHash' = coin__Transaction_GetInnerHash, 'Length' = coin__Transaction_Length_get, 'Type' = coin__Transaction_Type_get, 'InnerHash' = coin__Transaction_InnerHash_get, 'Sigs' = coin__Transaction_Sigs_get, 'In' = coin__Transaction_In_get, 'Out' = coin__Transaction_Out_get);
  vaccessors = c('Length', 'Type', 'InnerHash', 'Sigs', 'In', 'Out');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__Transaction
# Start of accessor method for coin__Transaction
setMethod('$<-', '_p_coin__Transaction', function(x, name, value)

{
  accessorFuns = list('Length' = coin__Transaction_Length_set, 'Type' = coin__Transaction_Type_set, 'InnerHash' = coin__Transaction_InnerHash_set, 'Sigs' = coin__Transaction_Sigs_set, 'In' = coin__Transaction_In_set, 'Out' = coin__Transaction_Out_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__Transaction', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Length' = coin__Transaction_Length_set, 'Type' = coin__Transaction_Type_set, 'InnerHash' = coin__Transaction_InnerHash_set, 'Sigs' = coin__Transaction_Sigs_set, 'In' = coin__Transaction_In_set, 'Out' = coin__Transaction_Out_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__Transaction
setMethod('delete', '_p_coin__Transaction', function(obj) {delete_coin__Transaction(obj)})
# Start definition of copy functions & methods for coin__Transaction
CopyToR_coin__Transaction = function(value, obj = new("coin__Transaction"))
{
  obj@Length = value$Length;
  obj@Type = value$Type;
  obj;
}



CopyToC_coin__Transaction = function(value, obj)
{
  obj$Length = value@Length;
  obj$Type = value@Type;
  obj
}



# Start definition of copy methods for coin__Transaction
setMethod('copyToR', '_p_coin__Transaction', CopyToR_coin__Transaction);
setMethod('copyToC', 'coin__Transaction', CopyToC_coin__Transaction);

# End definition of copy methods for coin__Transaction
# End definition of copy functions & methods for coin__Transaction
# Start of coin__TransactionOutput_isEqual

`coin__TransactionOutput_isEqual` = function(self, t, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(t, "ExternalReference")) t = slot(t,"ref") 
  ;.Call('R_swig_coin__TransactionOutput_isEqual', self, t, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__TransactionOutput_isEqual`, 'returnType') = 'integer'
attr(`coin__TransactionOutput_isEqual`, "inputTypes") = c('_p_coin__TransactionOutput', '_p_coin__TransactionOutput')
class(`coin__TransactionOutput_isEqual`) = c("SWIGFunction", class('coin__TransactionOutput_isEqual'))

# Start of coin__TransactionOutput_Address_set

`coin__TransactionOutput_Address_set` = function(self, s_Address)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Address, "ExternalReference")) s_Address = slot(s_Address,"ref") 
  ;.Call('R_swig_coin__TransactionOutput_Address_set', self, s_Address, PACKAGE='skycoin');
  
}

attr(`coin__TransactionOutput_Address_set`, 'returnType') = 'void'
attr(`coin__TransactionOutput_Address_set`, "inputTypes") = c('_p_coin__TransactionOutput', '_p_cipher__Address')
class(`coin__TransactionOutput_Address_set`) = c("SWIGFunction", class('coin__TransactionOutput_Address_set'))

# Start of coin__TransactionOutput_Address_get

`coin__TransactionOutput_Address_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__TransactionOutput_Address_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  ans
  
}

attr(`coin__TransactionOutput_Address_get`, 'returnType') = '_p_cipher__Address'
attr(`coin__TransactionOutput_Address_get`, "inputTypes") = c('_p_coin__TransactionOutput')
class(`coin__TransactionOutput_Address_get`) = c("SWIGFunction", class('coin__TransactionOutput_Address_get'))

# Start of coin__TransactionOutput_Coins_set

`coin__TransactionOutput_Coins_set` = function(self, s_Coins)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Coins = as.integer(s_Coins);
  
  if(length(s_Coins) > 1) {
    warning("using only the first element of s_Coins");
  };
  
  ;.Call('R_swig_coin__TransactionOutput_Coins_set', self, s_Coins, PACKAGE='skycoin');
  
}

attr(`coin__TransactionOutput_Coins_set`, 'returnType') = 'void'
attr(`coin__TransactionOutput_Coins_set`, "inputTypes") = c('_p_coin__TransactionOutput', 'integer')
class(`coin__TransactionOutput_Coins_set`) = c("SWIGFunction", class('coin__TransactionOutput_Coins_set'))

# Start of coin__TransactionOutput_Coins_get

`coin__TransactionOutput_Coins_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__TransactionOutput_Coins_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__TransactionOutput_Coins_get`, 'returnType') = 'integer'
attr(`coin__TransactionOutput_Coins_get`, "inputTypes") = c('_p_coin__TransactionOutput')
class(`coin__TransactionOutput_Coins_get`) = c("SWIGFunction", class('coin__TransactionOutput_Coins_get'))

# Start of coin__TransactionOutput_Hours_set

`coin__TransactionOutput_Hours_set` = function(self, s_Hours)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Hours = as.integer(s_Hours);
  
  if(length(s_Hours) > 1) {
    warning("using only the first element of s_Hours");
  };
  
  ;.Call('R_swig_coin__TransactionOutput_Hours_set', self, s_Hours, PACKAGE='skycoin');
  
}

attr(`coin__TransactionOutput_Hours_set`, 'returnType') = 'void'
attr(`coin__TransactionOutput_Hours_set`, "inputTypes") = c('_p_coin__TransactionOutput', 'integer')
class(`coin__TransactionOutput_Hours_set`) = c("SWIGFunction", class('coin__TransactionOutput_Hours_set'))

# Start of coin__TransactionOutput_Hours_get

`coin__TransactionOutput_Hours_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__TransactionOutput_Hours_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__TransactionOutput_Hours_get`, 'returnType') = 'integer'
attr(`coin__TransactionOutput_Hours_get`, "inputTypes") = c('_p_coin__TransactionOutput')
class(`coin__TransactionOutput_Hours_get`) = c("SWIGFunction", class('coin__TransactionOutput_Hours_get'))

# Start of new_coin__TransactionOutput

`coin__TransactionOutput` = function()
{
  ;ans = .Call('R_swig_new_coin__TransactionOutput', PACKAGE='skycoin');
  ans <- new("_p_coin__TransactionOutput", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__TransactionOutput)
  ans
  
}

attr(`coin__TransactionOutput`, 'returnType') = '_p_coin__TransactionOutput'
class(`coin__TransactionOutput`) = c("SWIGFunction", class('coin__TransactionOutput'))

# Start of delete_coin__TransactionOutput

`delete_coin__TransactionOutput` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__TransactionOutput', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__TransactionOutput`, 'returnType') = 'void'
attr(`delete_coin__TransactionOutput`, "inputTypes") = c('_p_coin__TransactionOutput')
class(`delete_coin__TransactionOutput`) = c("SWIGFunction", class('delete_coin__TransactionOutput'))

# Start of accessor method for coin__TransactionOutput
setMethod('$', '_p_coin__TransactionOutput', function(x, name)

{
  accessorFuns = list('isEqual' = coin__TransactionOutput_isEqual, 'Address' = coin__TransactionOutput_Address_get, 'Coins' = coin__TransactionOutput_Coins_get, 'Hours' = coin__TransactionOutput_Hours_get);
  vaccessors = c('Address', 'Coins', 'Hours');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__TransactionOutput
# Start of accessor method for coin__TransactionOutput
setMethod('$<-', '_p_coin__TransactionOutput', function(x, name, value)

{
  accessorFuns = list('Address' = coin__TransactionOutput_Address_set, 'Coins' = coin__TransactionOutput_Coins_set, 'Hours' = coin__TransactionOutput_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__TransactionOutput', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Address' = coin__TransactionOutput_Address_set, 'Coins' = coin__TransactionOutput_Coins_set, 'Hours' = coin__TransactionOutput_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__TransactionOutput
setMethod('delete', '_p_coin__TransactionOutput', function(obj) {delete_coin__TransactionOutput(obj)})
# Start definition of copy functions & methods for coin__TransactionOutput
CopyToR_coin__TransactionOutput = function(value, obj = new("coin__TransactionOutput"))
{
  obj@Coins = value$Coins;
  obj@Hours = value$Hours;
  obj;
}



CopyToC_coin__TransactionOutput = function(value, obj)
{
  obj$Coins = value@Coins;
  obj$Hours = value@Hours;
  obj
}



# Start definition of copy methods for coin__TransactionOutput
setMethod('copyToR', '_p_coin__TransactionOutput', CopyToR_coin__TransactionOutput);
setMethod('copyToC', 'coin__TransactionOutput', CopyToC_coin__TransactionOutput);

# End definition of copy methods for coin__TransactionOutput
# End definition of copy functions & methods for coin__TransactionOutput
# Start of coin__BlockHeader_isEqual

`coin__BlockHeader_isEqual` = function(self, bh, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(bh, "ExternalReference")) bh = slot(bh,"ref") 
  ;.Call('R_swig_coin__BlockHeader_isEqual', self, bh, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_isEqual`, 'returnType') = 'integer'
attr(`coin__BlockHeader_isEqual`, "inputTypes") = c('_p_coin__BlockHeader', '_p_coin__BlockHeader')
class(`coin__BlockHeader_isEqual`) = c("SWIGFunction", class('coin__BlockHeader_isEqual'))

# Start of coin__BlockHeader_Version_set

`coin__BlockHeader_Version_set` = function(self, s_Version)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Version = as.integer(s_Version);
  
  if(length(s_Version) > 1) {
    warning("using only the first element of s_Version");
  };
  
  ;.Call('R_swig_coin__BlockHeader_Version_set', self, s_Version, PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_Version_set`, 'returnType') = 'void'
attr(`coin__BlockHeader_Version_set`, "inputTypes") = c('_p_coin__BlockHeader', 'integer')
class(`coin__BlockHeader_Version_set`) = c("SWIGFunction", class('coin__BlockHeader_Version_set'))

# Start of coin__BlockHeader_Version_get

`coin__BlockHeader_Version_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__BlockHeader_Version_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_Version_get`, 'returnType') = 'integer'
attr(`coin__BlockHeader_Version_get`, "inputTypes") = c('_p_coin__BlockHeader')
class(`coin__BlockHeader_Version_get`) = c("SWIGFunction", class('coin__BlockHeader_Version_get'))

# Start of coin__BlockHeader_Time_set

`coin__BlockHeader_Time_set` = function(self, s_Time)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Time = as.integer(s_Time);
  
  if(length(s_Time) > 1) {
    warning("using only the first element of s_Time");
  };
  
  ;.Call('R_swig_coin__BlockHeader_Time_set', self, s_Time, PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_Time_set`, 'returnType') = 'void'
attr(`coin__BlockHeader_Time_set`, "inputTypes") = c('_p_coin__BlockHeader', 'integer')
class(`coin__BlockHeader_Time_set`) = c("SWIGFunction", class('coin__BlockHeader_Time_set'))

# Start of coin__BlockHeader_Time_get

`coin__BlockHeader_Time_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__BlockHeader_Time_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_Time_get`, 'returnType') = 'integer'
attr(`coin__BlockHeader_Time_get`, "inputTypes") = c('_p_coin__BlockHeader')
class(`coin__BlockHeader_Time_get`) = c("SWIGFunction", class('coin__BlockHeader_Time_get'))

# Start of coin__BlockHeader_BkSeq_set

`coin__BlockHeader_BkSeq_set` = function(self, s_BkSeq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_BkSeq = as.integer(s_BkSeq);
  
  if(length(s_BkSeq) > 1) {
    warning("using only the first element of s_BkSeq");
  };
  
  ;.Call('R_swig_coin__BlockHeader_BkSeq_set', self, s_BkSeq, PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_BkSeq_set`, 'returnType') = 'void'
attr(`coin__BlockHeader_BkSeq_set`, "inputTypes") = c('_p_coin__BlockHeader', 'integer')
class(`coin__BlockHeader_BkSeq_set`) = c("SWIGFunction", class('coin__BlockHeader_BkSeq_set'))

# Start of coin__BlockHeader_BkSeq_get

`coin__BlockHeader_BkSeq_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__BlockHeader_BkSeq_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_BkSeq_get`, 'returnType') = 'integer'
attr(`coin__BlockHeader_BkSeq_get`, "inputTypes") = c('_p_coin__BlockHeader')
class(`coin__BlockHeader_BkSeq_get`) = c("SWIGFunction", class('coin__BlockHeader_BkSeq_get'))

# Start of coin__BlockHeader_Fee_set

`coin__BlockHeader_Fee_set` = function(self, s_Fee)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Fee = as.integer(s_Fee);
  
  if(length(s_Fee) > 1) {
    warning("using only the first element of s_Fee");
  };
  
  ;.Call('R_swig_coin__BlockHeader_Fee_set', self, s_Fee, PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_Fee_set`, 'returnType') = 'void'
attr(`coin__BlockHeader_Fee_set`, "inputTypes") = c('_p_coin__BlockHeader', 'integer')
class(`coin__BlockHeader_Fee_set`) = c("SWIGFunction", class('coin__BlockHeader_Fee_set'))

# Start of coin__BlockHeader_Fee_get

`coin__BlockHeader_Fee_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__BlockHeader_Fee_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_Fee_get`, 'returnType') = 'integer'
attr(`coin__BlockHeader_Fee_get`, "inputTypes") = c('_p_coin__BlockHeader')
class(`coin__BlockHeader_Fee_get`) = c("SWIGFunction", class('coin__BlockHeader_Fee_get'))

# Start of coin__BlockHeader_PrevHash_set

`coin__BlockHeader_PrevHash_set` = function(self, s_PrevHash)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_PrevHash))
  assert(all(sapply(s_PrevHash, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_PrevHash) >= 32)
  
  ;.Call('R_swig_coin__BlockHeader_PrevHash_set', self, s_PrevHash, PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_PrevHash_set`, 'returnType') = 'void'
attr(`coin__BlockHeader_PrevHash_set`, "inputTypes") = c('_p_coin__BlockHeader', '_p_GoUint8_')
class(`coin__BlockHeader_PrevHash_set`) = c("SWIGFunction", class('coin__BlockHeader_PrevHash_set'))

# Start of coin__BlockHeader_PrevHash_get

`coin__BlockHeader_PrevHash_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__BlockHeader_PrevHash_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`coin__BlockHeader_PrevHash_get`, 'returnType') = '_p_GoUint8_'
attr(`coin__BlockHeader_PrevHash_get`, "inputTypes") = c('_p_coin__BlockHeader')
class(`coin__BlockHeader_PrevHash_get`) = c("SWIGFunction", class('coin__BlockHeader_PrevHash_get'))

# Start of coin__BlockHeader_BodyHash_set

`coin__BlockHeader_BodyHash_set` = function(self, s_BodyHash)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_BodyHash))
  assert(all(sapply(s_BodyHash, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_BodyHash) >= 32)
  
  ;.Call('R_swig_coin__BlockHeader_BodyHash_set', self, s_BodyHash, PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_BodyHash_set`, 'returnType') = 'void'
attr(`coin__BlockHeader_BodyHash_set`, "inputTypes") = c('_p_coin__BlockHeader', '_p_GoUint8_')
class(`coin__BlockHeader_BodyHash_set`) = c("SWIGFunction", class('coin__BlockHeader_BodyHash_set'))

# Start of coin__BlockHeader_BodyHash_get

`coin__BlockHeader_BodyHash_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__BlockHeader_BodyHash_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`coin__BlockHeader_BodyHash_get`, 'returnType') = '_p_GoUint8_'
attr(`coin__BlockHeader_BodyHash_get`, "inputTypes") = c('_p_coin__BlockHeader')
class(`coin__BlockHeader_BodyHash_get`) = c("SWIGFunction", class('coin__BlockHeader_BodyHash_get'))

# Start of coin__BlockHeader_UxHash_set

`coin__BlockHeader_UxHash_set` = function(self, s_UxHash)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_UxHash))
  assert(all(sapply(s_UxHash, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_UxHash) >= 32)
  
  ;.Call('R_swig_coin__BlockHeader_UxHash_set', self, s_UxHash, PACKAGE='skycoin');
  
}

attr(`coin__BlockHeader_UxHash_set`, 'returnType') = 'void'
attr(`coin__BlockHeader_UxHash_set`, "inputTypes") = c('_p_coin__BlockHeader', '_p_GoUint8_')
class(`coin__BlockHeader_UxHash_set`) = c("SWIGFunction", class('coin__BlockHeader_UxHash_set'))

# Start of coin__BlockHeader_UxHash_get

`coin__BlockHeader_UxHash_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__BlockHeader_UxHash_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`coin__BlockHeader_UxHash_get`, 'returnType') = '_p_GoUint8_'
attr(`coin__BlockHeader_UxHash_get`, "inputTypes") = c('_p_coin__BlockHeader')
class(`coin__BlockHeader_UxHash_get`) = c("SWIGFunction", class('coin__BlockHeader_UxHash_get'))

# Start of new_coin__BlockHeader

`coin__BlockHeader` = function()
{
  ;ans = .Call('R_swig_new_coin__BlockHeader', PACKAGE='skycoin');
  ans <- new("_p_coin__BlockHeader", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__BlockHeader)
  ans
  
}

attr(`coin__BlockHeader`, 'returnType') = '_p_coin__BlockHeader'
class(`coin__BlockHeader`) = c("SWIGFunction", class('coin__BlockHeader'))

# Start of delete_coin__BlockHeader

`delete_coin__BlockHeader` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__BlockHeader', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__BlockHeader`, 'returnType') = 'void'
attr(`delete_coin__BlockHeader`, "inputTypes") = c('_p_coin__BlockHeader')
class(`delete_coin__BlockHeader`) = c("SWIGFunction", class('delete_coin__BlockHeader'))

# Start of accessor method for coin__BlockHeader
setMethod('$', '_p_coin__BlockHeader', function(x, name)

{
  accessorFuns = list('isEqual' = coin__BlockHeader_isEqual, 'Version' = coin__BlockHeader_Version_get, 'Time' = coin__BlockHeader_Time_get, 'BkSeq' = coin__BlockHeader_BkSeq_get, 'Fee' = coin__BlockHeader_Fee_get, 'PrevHash' = coin__BlockHeader_PrevHash_get, 'BodyHash' = coin__BlockHeader_BodyHash_get, 'UxHash' = coin__BlockHeader_UxHash_get);
  vaccessors = c('Version', 'Time', 'BkSeq', 'Fee', 'PrevHash', 'BodyHash', 'UxHash');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__BlockHeader
# Start of accessor method for coin__BlockHeader
setMethod('$<-', '_p_coin__BlockHeader', function(x, name, value)

{
  accessorFuns = list('Version' = coin__BlockHeader_Version_set, 'Time' = coin__BlockHeader_Time_set, 'BkSeq' = coin__BlockHeader_BkSeq_set, 'Fee' = coin__BlockHeader_Fee_set, 'PrevHash' = coin__BlockHeader_PrevHash_set, 'BodyHash' = coin__BlockHeader_BodyHash_set, 'UxHash' = coin__BlockHeader_UxHash_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__BlockHeader', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Version' = coin__BlockHeader_Version_set, 'Time' = coin__BlockHeader_Time_set, 'BkSeq' = coin__BlockHeader_BkSeq_set, 'Fee' = coin__BlockHeader_Fee_set, 'PrevHash' = coin__BlockHeader_PrevHash_set, 'BodyHash' = coin__BlockHeader_BodyHash_set, 'UxHash' = coin__BlockHeader_UxHash_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__BlockHeader
setMethod('delete', '_p_coin__BlockHeader', function(obj) {delete_coin__BlockHeader(obj)})
# Start definition of copy functions & methods for coin__BlockHeader
CopyToR_coin__BlockHeader = function(value, obj = new("coin__BlockHeader"))
{
  obj@Version = value$Version;
  obj@Time = value$Time;
  obj@BkSeq = value$BkSeq;
  obj@Fee = value$Fee;
  obj;
}



CopyToC_coin__BlockHeader = function(value, obj)
{
  obj$Version = value@Version;
  obj$Time = value@Time;
  obj$BkSeq = value@BkSeq;
  obj$Fee = value@Fee;
  obj
}



# Start definition of copy methods for coin__BlockHeader
setMethod('copyToR', '_p_coin__BlockHeader', CopyToR_coin__BlockHeader);
setMethod('copyToC', 'coin__BlockHeader', CopyToC_coin__BlockHeader);

# End definition of copy methods for coin__BlockHeader
# End definition of copy functions & methods for coin__BlockHeader
# Start of coin__BlockBody_isEqual

`coin__BlockBody_isEqual` = function(self, b, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(b, "ExternalReference")) b = slot(b,"ref") 
  ;.Call('R_swig_coin__BlockBody_isEqual', self, b, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__BlockBody_isEqual`, 'returnType') = 'integer'
attr(`coin__BlockBody_isEqual`, "inputTypes") = c('_p_coin__BlockBody', '_p_coin__BlockBody')
class(`coin__BlockBody_isEqual`) = c("SWIGFunction", class('coin__BlockBody_isEqual'))

# Start of coin__BlockBody_Transactions_set

`coin__BlockBody_Transactions_set` = function(self, s_Transactions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Transactions, "ExternalReference")) s_Transactions = slot(s_Transactions,"ref") 
  ;.Call('R_swig_coin__BlockBody_Transactions_set', self, s_Transactions, PACKAGE='skycoin');
  
}

attr(`coin__BlockBody_Transactions_set`, 'returnType') = 'void'
attr(`coin__BlockBody_Transactions_set`, "inputTypes") = c('_p_coin__BlockBody', '_p_GoSlice_')
class(`coin__BlockBody_Transactions_set`) = c("SWIGFunction", class('coin__BlockBody_Transactions_set'))

# Start of coin__BlockBody_Transactions_get

`coin__BlockBody_Transactions_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__BlockBody_Transactions_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoSlice_", ref=ans);
  
  ans
  
}

attr(`coin__BlockBody_Transactions_get`, 'returnType') = '_p_GoSlice_'
attr(`coin__BlockBody_Transactions_get`, "inputTypes") = c('_p_coin__BlockBody')
class(`coin__BlockBody_Transactions_get`) = c("SWIGFunction", class('coin__BlockBody_Transactions_get'))

# Start of new_coin__BlockBody

`coin__BlockBody` = function()
{
  ;ans = .Call('R_swig_new_coin__BlockBody', PACKAGE='skycoin');
  ans <- new("_p_coin__BlockBody", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__BlockBody)
  ans
  
}

attr(`coin__BlockBody`, 'returnType') = '_p_coin__BlockBody'
class(`coin__BlockBody`) = c("SWIGFunction", class('coin__BlockBody'))

# Start of delete_coin__BlockBody

`delete_coin__BlockBody` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__BlockBody', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__BlockBody`, 'returnType') = 'void'
attr(`delete_coin__BlockBody`, "inputTypes") = c('_p_coin__BlockBody')
class(`delete_coin__BlockBody`) = c("SWIGFunction", class('delete_coin__BlockBody'))

# Start of accessor method for coin__BlockBody
setMethod('$', '_p_coin__BlockBody', function(x, name)

{
  accessorFuns = list('isEqual' = coin__BlockBody_isEqual, 'Transactions' = coin__BlockBody_Transactions_get);
  vaccessors = c('Transactions');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__BlockBody
# Start of accessor method for coin__BlockBody
setMethod('$<-', '_p_coin__BlockBody', function(x, name, value)

{
  accessorFuns = list('Transactions' = coin__BlockBody_Transactions_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__BlockBody', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Transactions' = coin__BlockBody_Transactions_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__BlockBody
setMethod('delete', '_p_coin__BlockBody', function(obj) {delete_coin__BlockBody(obj)})
# Start definition of copy functions & methods for coin__BlockBody
CopyToR_coin__BlockBody = function(value, obj = new("coin__BlockBody"))
{
  obj;
}



CopyToC_coin__BlockBody = function(value, obj)
{
  obj
}



# Start definition of copy methods for coin__BlockBody
setMethod('copyToR', '_p_coin__BlockBody', CopyToR_coin__BlockBody);
setMethod('copyToC', 'coin__BlockBody', CopyToC_coin__BlockBody);

# End definition of copy methods for coin__BlockBody
# End definition of copy functions & methods for coin__BlockBody
# Start of coin__Block_Head_set

`coin__Block_Head_set` = function(self, s_Head)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Head, "ExternalReference")) s_Head = slot(s_Head,"ref") 
  ;.Call('R_swig_coin__Block_Head_set', self, s_Head, PACKAGE='skycoin');
  
}

attr(`coin__Block_Head_set`, 'returnType') = 'void'
attr(`coin__Block_Head_set`, "inputTypes") = c('_p_coin__Block', '_p_coin__BlockHeader')
class(`coin__Block_Head_set`) = c("SWIGFunction", class('coin__Block_Head_set'))

# Start of coin__Block_Head_get

`coin__Block_Head_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__Block_Head_get', self, PACKAGE='skycoin');
  ans <- new("_p_coin__BlockHeader", ref=ans) ;
  
  ans
  
}

attr(`coin__Block_Head_get`, 'returnType') = '_p_coin__BlockHeader'
attr(`coin__Block_Head_get`, "inputTypes") = c('_p_coin__Block')
class(`coin__Block_Head_get`) = c("SWIGFunction", class('coin__Block_Head_get'))

# Start of coin__Block_Body_set

`coin__Block_Body_set` = function(self, s_Body)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Body, "ExternalReference")) s_Body = slot(s_Body,"ref") 
  ;.Call('R_swig_coin__Block_Body_set', self, s_Body, PACKAGE='skycoin');
  
}

attr(`coin__Block_Body_set`, 'returnType') = 'void'
attr(`coin__Block_Body_set`, "inputTypes") = c('_p_coin__Block', '_p_coin__BlockBody')
class(`coin__Block_Body_set`) = c("SWIGFunction", class('coin__Block_Body_set'))

# Start of coin__Block_Body_get

`coin__Block_Body_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__Block_Body_get', self, PACKAGE='skycoin');
  ans <- new("_p_coin__BlockBody", ref=ans) ;
  
  ans
  
}

attr(`coin__Block_Body_get`, 'returnType') = '_p_coin__BlockBody'
attr(`coin__Block_Body_get`, "inputTypes") = c('_p_coin__Block')
class(`coin__Block_Body_get`) = c("SWIGFunction", class('coin__Block_Body_get'))

# Start of new_coin__Block

`coin__Block` = function()
{
  ;ans = .Call('R_swig_new_coin__Block', PACKAGE='skycoin');
  ans <- new("_p_coin__Block", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__Block)
  ans
  
}

attr(`coin__Block`, 'returnType') = '_p_coin__Block'
class(`coin__Block`) = c("SWIGFunction", class('coin__Block'))

# Start of delete_coin__Block

`delete_coin__Block` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__Block', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__Block`, 'returnType') = 'void'
attr(`delete_coin__Block`, "inputTypes") = c('_p_coin__Block')
class(`delete_coin__Block`) = c("SWIGFunction", class('delete_coin__Block'))

# Start of accessor method for coin__Block
setMethod('$', '_p_coin__Block', function(x, name)

{
  accessorFuns = list('Head' = coin__Block_Head_get, 'Body' = coin__Block_Body_get);
  vaccessors = c('Head', 'Body');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__Block
# Start of accessor method for coin__Block
setMethod('$<-', '_p_coin__Block', function(x, name, value)

{
  accessorFuns = list('Head' = coin__Block_Head_set, 'Body' = coin__Block_Body_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__Block', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Head' = coin__Block_Head_set, 'Body' = coin__Block_Body_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__Block
setMethod('delete', '_p_coin__Block', function(obj) {delete_coin__Block(obj)})
# Start definition of copy functions & methods for coin__Block
CopyToR_coin__Block = function(value, obj = new("coin__Block"))
{
  obj;
}



CopyToC_coin__Block = function(value, obj)
{
  obj
}



# Start definition of copy methods for coin__Block
setMethod('copyToR', '_p_coin__Block', CopyToR_coin__Block);
setMethod('copyToC', 'coin__Block', CopyToC_coin__Block);

# End definition of copy methods for coin__Block
# End definition of copy functions & methods for coin__Block
# Start of coin__SignedBlock__unnamed_set

`coin__SignedBlock__unnamed_set` = function(self, s_unnamed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_unnamed, "ExternalReference")) s_unnamed = slot(s_unnamed,"ref") 
  ;.Call('R_swig_coin__SignedBlock__unnamed_set', self, s_unnamed, PACKAGE='skycoin');
  
}

attr(`coin__SignedBlock__unnamed_set`, 'returnType') = 'void'
attr(`coin__SignedBlock__unnamed_set`, "inputTypes") = c('_p_coin__SignedBlock', '_p_coin__Block')
class(`coin__SignedBlock__unnamed_set`) = c("SWIGFunction", class('coin__SignedBlock__unnamed_set'))

# Start of coin__SignedBlock__unnamed_get

`coin__SignedBlock__unnamed_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__SignedBlock__unnamed_get', self, PACKAGE='skycoin');
  ans <- new("_p_coin__Block", ref=ans) ;
  
  ans
  
}

attr(`coin__SignedBlock__unnamed_get`, 'returnType') = '_p_coin__Block'
attr(`coin__SignedBlock__unnamed_get`, "inputTypes") = c('_p_coin__SignedBlock')
class(`coin__SignedBlock__unnamed_get`) = c("SWIGFunction", class('coin__SignedBlock__unnamed_get'))

# Start of coin__SignedBlock_Sig_set

`coin__SignedBlock_Sig_set` = function(self, s_Sig)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_Sig))
  assert(all(sapply(s_Sig, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_Sig) >= 65)
  
  ;.Call('R_swig_coin__SignedBlock_Sig_set', self, s_Sig, PACKAGE='skycoin');
  
}

attr(`coin__SignedBlock_Sig_set`, 'returnType') = 'void'
attr(`coin__SignedBlock_Sig_set`, "inputTypes") = c('_p_coin__SignedBlock', '_p_GoUint8_')
class(`coin__SignedBlock_Sig_set`) = c("SWIGFunction", class('coin__SignedBlock_Sig_set'))

# Start of coin__SignedBlock_Sig_get

`coin__SignedBlock_Sig_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__SignedBlock_Sig_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`coin__SignedBlock_Sig_get`, 'returnType') = '_p_GoUint8_'
attr(`coin__SignedBlock_Sig_get`, "inputTypes") = c('_p_coin__SignedBlock')
class(`coin__SignedBlock_Sig_get`) = c("SWIGFunction", class('coin__SignedBlock_Sig_get'))

# Start of new_coin__SignedBlock

`coin__SignedBlock` = function()
{
  ;ans = .Call('R_swig_new_coin__SignedBlock', PACKAGE='skycoin');
  ans <- new("_p_coin__SignedBlock", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__SignedBlock)
  ans
  
}

attr(`coin__SignedBlock`, 'returnType') = '_p_coin__SignedBlock'
class(`coin__SignedBlock`) = c("SWIGFunction", class('coin__SignedBlock'))

# Start of delete_coin__SignedBlock

`delete_coin__SignedBlock` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__SignedBlock', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__SignedBlock`, 'returnType') = 'void'
attr(`delete_coin__SignedBlock`, "inputTypes") = c('_p_coin__SignedBlock')
class(`delete_coin__SignedBlock`) = c("SWIGFunction", class('delete_coin__SignedBlock'))

# Start of accessor method for coin__SignedBlock
setMethod('$', '_p_coin__SignedBlock', function(x, name)

{
  accessorFuns = list('_unnamed' = coin__SignedBlock__unnamed_get, 'Sig' = coin__SignedBlock_Sig_get);
  vaccessors = c('_unnamed', 'Sig');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__SignedBlock
# Start of accessor method for coin__SignedBlock
setMethod('$<-', '_p_coin__SignedBlock', function(x, name, value)

{
  accessorFuns = list('_unnamed' = coin__SignedBlock__unnamed_set, 'Sig' = coin__SignedBlock_Sig_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__SignedBlock', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('_unnamed' = coin__SignedBlock__unnamed_set, 'Sig' = coin__SignedBlock_Sig_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__SignedBlock
setMethod('delete', '_p_coin__SignedBlock', function(obj) {delete_coin__SignedBlock(obj)})
# Start definition of copy functions & methods for coin__SignedBlock
CopyToR_coin__SignedBlock = function(value, obj = new("coin__SignedBlock"))
{
  obj;
}



CopyToC_coin__SignedBlock = function(value, obj)
{
  obj
}



# Start definition of copy methods for coin__SignedBlock
setMethod('copyToR', '_p_coin__SignedBlock', CopyToR_coin__SignedBlock);
setMethod('copyToC', 'coin__SignedBlock', CopyToC_coin__SignedBlock);

# End definition of copy methods for coin__SignedBlock
# End definition of copy functions & methods for coin__SignedBlock
# Start of coin__UxHead_Time_set

`coin__UxHead_Time_set` = function(self, s_Time)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Time = as.integer(s_Time);
  
  if(length(s_Time) > 1) {
    warning("using only the first element of s_Time");
  };
  
  ;.Call('R_swig_coin__UxHead_Time_set', self, s_Time, PACKAGE='skycoin');
  
}

attr(`coin__UxHead_Time_set`, 'returnType') = 'void'
attr(`coin__UxHead_Time_set`, "inputTypes") = c('_p_coin__UxHead', 'integer')
class(`coin__UxHead_Time_set`) = c("SWIGFunction", class('coin__UxHead_Time_set'))

# Start of coin__UxHead_Time_get

`coin__UxHead_Time_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__UxHead_Time_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__UxHead_Time_get`, 'returnType') = 'integer'
attr(`coin__UxHead_Time_get`, "inputTypes") = c('_p_coin__UxHead')
class(`coin__UxHead_Time_get`) = c("SWIGFunction", class('coin__UxHead_Time_get'))

# Start of coin__UxHead_BkSeq_set

`coin__UxHead_BkSeq_set` = function(self, s_BkSeq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_BkSeq = as.integer(s_BkSeq);
  
  if(length(s_BkSeq) > 1) {
    warning("using only the first element of s_BkSeq");
  };
  
  ;.Call('R_swig_coin__UxHead_BkSeq_set', self, s_BkSeq, PACKAGE='skycoin');
  
}

attr(`coin__UxHead_BkSeq_set`, 'returnType') = 'void'
attr(`coin__UxHead_BkSeq_set`, "inputTypes") = c('_p_coin__UxHead', 'integer')
class(`coin__UxHead_BkSeq_set`) = c("SWIGFunction", class('coin__UxHead_BkSeq_set'))

# Start of coin__UxHead_BkSeq_get

`coin__UxHead_BkSeq_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__UxHead_BkSeq_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__UxHead_BkSeq_get`, 'returnType') = 'integer'
attr(`coin__UxHead_BkSeq_get`, "inputTypes") = c('_p_coin__UxHead')
class(`coin__UxHead_BkSeq_get`) = c("SWIGFunction", class('coin__UxHead_BkSeq_get'))

# Start of new_coin__UxHead

`coin__UxHead` = function()
{
  ;ans = .Call('R_swig_new_coin__UxHead', PACKAGE='skycoin');
  ans <- new("_p_coin__UxHead", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__UxHead)
  ans
  
}

attr(`coin__UxHead`, 'returnType') = '_p_coin__UxHead'
class(`coin__UxHead`) = c("SWIGFunction", class('coin__UxHead'))

# Start of delete_coin__UxHead

`delete_coin__UxHead` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__UxHead', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__UxHead`, 'returnType') = 'void'
attr(`delete_coin__UxHead`, "inputTypes") = c('_p_coin__UxHead')
class(`delete_coin__UxHead`) = c("SWIGFunction", class('delete_coin__UxHead'))

# Start of accessor method for coin__UxHead
setMethod('$', '_p_coin__UxHead', function(x, name)

{
  accessorFuns = list('Time' = coin__UxHead_Time_get, 'BkSeq' = coin__UxHead_BkSeq_get);
  vaccessors = c('Time', 'BkSeq');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__UxHead
# Start of accessor method for coin__UxHead
setMethod('$<-', '_p_coin__UxHead', function(x, name, value)

{
  accessorFuns = list('Time' = coin__UxHead_Time_set, 'BkSeq' = coin__UxHead_BkSeq_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__UxHead', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Time' = coin__UxHead_Time_set, 'BkSeq' = coin__UxHead_BkSeq_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__UxHead
setMethod('delete', '_p_coin__UxHead', function(obj) {delete_coin__UxHead(obj)})
# Start definition of copy functions & methods for coin__UxHead
CopyToR_coin__UxHead = function(value, obj = new("coin__UxHead"))
{
  obj@Time = value$Time;
  obj@BkSeq = value$BkSeq;
  obj;
}



CopyToC_coin__UxHead = function(value, obj)
{
  obj$Time = value@Time;
  obj$BkSeq = value@BkSeq;
  obj
}



# Start definition of copy methods for coin__UxHead
setMethod('copyToR', '_p_coin__UxHead', CopyToR_coin__UxHead);
setMethod('copyToC', 'coin__UxHead', CopyToC_coin__UxHead);

# End definition of copy methods for coin__UxHead
# End definition of copy functions & methods for coin__UxHead
# Start of coin__UxBody_SetSrcTransaction

`coin__UxBody_SetSrcTransaction` = function(self, o)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(o, "ExternalReference")) o = slot(o,"ref") 
  ;.Call('R_swig_coin__UxBody_SetSrcTransaction', self, o, PACKAGE='skycoin');
  
}

attr(`coin__UxBody_SetSrcTransaction`, 'returnType') = 'void'
attr(`coin__UxBody_SetSrcTransaction`, "inputTypes") = c('_p_coin__UxBody', '_p_cipher_SHA256')
class(`coin__UxBody_SetSrcTransaction`) = c("SWIGFunction", class('coin__UxBody_SetSrcTransaction'))

# Start of coin__UxBody_SrcTransaction_set

`coin__UxBody_SrcTransaction_set` = function(self, s_SrcTransaction)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_SrcTransaction))
  assert(all(sapply(s_SrcTransaction, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_SrcTransaction) >= 32)
  
  ;.Call('R_swig_coin__UxBody_SrcTransaction_set', self, s_SrcTransaction, PACKAGE='skycoin');
  
}

attr(`coin__UxBody_SrcTransaction_set`, 'returnType') = 'void'
attr(`coin__UxBody_SrcTransaction_set`, "inputTypes") = c('_p_coin__UxBody', '_p_GoUint8_')
class(`coin__UxBody_SrcTransaction_set`) = c("SWIGFunction", class('coin__UxBody_SrcTransaction_set'))

# Start of coin__UxBody_SrcTransaction_get

`coin__UxBody_SrcTransaction_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__UxBody_SrcTransaction_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`coin__UxBody_SrcTransaction_get`, 'returnType') = '_p_GoUint8_'
attr(`coin__UxBody_SrcTransaction_get`, "inputTypes") = c('_p_coin__UxBody')
class(`coin__UxBody_SrcTransaction_get`) = c("SWIGFunction", class('coin__UxBody_SrcTransaction_get'))

# Start of coin__UxBody_Address_set

`coin__UxBody_Address_set` = function(self, s_Address)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Address, "ExternalReference")) s_Address = slot(s_Address,"ref") 
  ;.Call('R_swig_coin__UxBody_Address_set', self, s_Address, PACKAGE='skycoin');
  
}

attr(`coin__UxBody_Address_set`, 'returnType') = 'void'
attr(`coin__UxBody_Address_set`, "inputTypes") = c('_p_coin__UxBody', '_p_cipher__Address')
class(`coin__UxBody_Address_set`) = c("SWIGFunction", class('coin__UxBody_Address_set'))

# Start of coin__UxBody_Address_get

`coin__UxBody_Address_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__UxBody_Address_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  ans
  
}

attr(`coin__UxBody_Address_get`, 'returnType') = '_p_cipher__Address'
attr(`coin__UxBody_Address_get`, "inputTypes") = c('_p_coin__UxBody')
class(`coin__UxBody_Address_get`) = c("SWIGFunction", class('coin__UxBody_Address_get'))

# Start of coin__UxBody_Coins_set

`coin__UxBody_Coins_set` = function(self, s_Coins)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Coins = as.integer(s_Coins);
  
  if(length(s_Coins) > 1) {
    warning("using only the first element of s_Coins");
  };
  
  ;.Call('R_swig_coin__UxBody_Coins_set', self, s_Coins, PACKAGE='skycoin');
  
}

attr(`coin__UxBody_Coins_set`, 'returnType') = 'void'
attr(`coin__UxBody_Coins_set`, "inputTypes") = c('_p_coin__UxBody', 'integer')
class(`coin__UxBody_Coins_set`) = c("SWIGFunction", class('coin__UxBody_Coins_set'))

# Start of coin__UxBody_Coins_get

`coin__UxBody_Coins_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__UxBody_Coins_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__UxBody_Coins_get`, 'returnType') = 'integer'
attr(`coin__UxBody_Coins_get`, "inputTypes") = c('_p_coin__UxBody')
class(`coin__UxBody_Coins_get`) = c("SWIGFunction", class('coin__UxBody_Coins_get'))

# Start of coin__UxBody_Hours_set

`coin__UxBody_Hours_set` = function(self, s_Hours)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Hours = as.integer(s_Hours);
  
  if(length(s_Hours) > 1) {
    warning("using only the first element of s_Hours");
  };
  
  ;.Call('R_swig_coin__UxBody_Hours_set', self, s_Hours, PACKAGE='skycoin');
  
}

attr(`coin__UxBody_Hours_set`, 'returnType') = 'void'
attr(`coin__UxBody_Hours_set`, "inputTypes") = c('_p_coin__UxBody', 'integer')
class(`coin__UxBody_Hours_set`) = c("SWIGFunction", class('coin__UxBody_Hours_set'))

# Start of coin__UxBody_Hours_get

`coin__UxBody_Hours_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_coin__UxBody_Hours_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__UxBody_Hours_get`, 'returnType') = 'integer'
attr(`coin__UxBody_Hours_get`, "inputTypes") = c('_p_coin__UxBody')
class(`coin__UxBody_Hours_get`) = c("SWIGFunction", class('coin__UxBody_Hours_get'))

# Start of new_coin__UxBody

`coin__UxBody` = function()
{
  ;ans = .Call('R_swig_new_coin__UxBody', PACKAGE='skycoin');
  ans <- new("_p_coin__UxBody", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__UxBody)
  ans
  
}

attr(`coin__UxBody`, 'returnType') = '_p_coin__UxBody'
class(`coin__UxBody`) = c("SWIGFunction", class('coin__UxBody'))

# Start of delete_coin__UxBody

`delete_coin__UxBody` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__UxBody', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__UxBody`, 'returnType') = 'void'
attr(`delete_coin__UxBody`, "inputTypes") = c('_p_coin__UxBody')
class(`delete_coin__UxBody`) = c("SWIGFunction", class('delete_coin__UxBody'))

# Start of accessor method for coin__UxBody
setMethod('$', '_p_coin__UxBody', function(x, name)

{
  accessorFuns = list('SetSrcTransaction' = coin__UxBody_SetSrcTransaction, 'SrcTransaction' = coin__UxBody_SrcTransaction_get, 'Address' = coin__UxBody_Address_get, 'Coins' = coin__UxBody_Coins_get, 'Hours' = coin__UxBody_Hours_get);
  vaccessors = c('SrcTransaction', 'Address', 'Coins', 'Hours');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__UxBody
# Start of accessor method for coin__UxBody
setMethod('$<-', '_p_coin__UxBody', function(x, name, value)

{
  accessorFuns = list('SrcTransaction' = coin__UxBody_SrcTransaction_set, 'Address' = coin__UxBody_Address_set, 'Coins' = coin__UxBody_Coins_set, 'Hours' = coin__UxBody_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__UxBody', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('SrcTransaction' = coin__UxBody_SrcTransaction_set, 'Address' = coin__UxBody_Address_set, 'Coins' = coin__UxBody_Coins_set, 'Hours' = coin__UxBody_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__UxBody
setMethod('delete', '_p_coin__UxBody', function(obj) {delete_coin__UxBody(obj)})
# Start definition of copy functions & methods for coin__UxBody
CopyToR_coin__UxBody = function(value, obj = new("coin__UxBody"))
{
  obj@Coins = value$Coins;
  obj@Hours = value$Hours;
  obj;
}



CopyToC_coin__UxBody = function(value, obj)
{
  obj$Coins = value@Coins;
  obj$Hours = value@Hours;
  obj
}



# Start definition of copy methods for coin__UxBody
setMethod('copyToR', '_p_coin__UxBody', CopyToR_coin__UxBody);
setMethod('copyToC', 'coin__UxBody', CopyToC_coin__UxBody);

# End definition of copy methods for coin__UxBody
# End definition of copy functions & methods for coin__UxBody
# Start of coin__UxOut_isEqual

`coin__UxOut_isEqual` = function(self, u, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(u, "ExternalReference")) u = slot(u,"ref") 
  ;.Call('R_swig_coin__UxOut_isEqual', self, u, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`coin__UxOut_isEqual`, 'returnType') = 'integer'
attr(`coin__UxOut_isEqual`, "inputTypes") = c('_p_coin__UxOut', '_p_coin__UxOut')
class(`coin__UxOut_isEqual`) = c("SWIGFunction", class('coin__UxOut_isEqual'))

# Start of coin__UxOut_Head_set

`coin__UxOut_Head_set` = function(self, s_Head)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Head, "ExternalReference")) s_Head = slot(s_Head,"ref") 
  ;.Call('R_swig_coin__UxOut_Head_set', self, s_Head, PACKAGE='skycoin');
  
}

attr(`coin__UxOut_Head_set`, 'returnType') = 'void'
attr(`coin__UxOut_Head_set`, "inputTypes") = c('_p_coin__UxOut', '_p_coin__UxHead')
class(`coin__UxOut_Head_set`) = c("SWIGFunction", class('coin__UxOut_Head_set'))

# Start of coin__UxOut_Head_get

`coin__UxOut_Head_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__UxOut_Head_get', self, PACKAGE='skycoin');
  ans <- new("_p_coin__UxHead", ref=ans) ;
  
  ans
  
}

attr(`coin__UxOut_Head_get`, 'returnType') = '_p_coin__UxHead'
attr(`coin__UxOut_Head_get`, "inputTypes") = c('_p_coin__UxOut')
class(`coin__UxOut_Head_get`) = c("SWIGFunction", class('coin__UxOut_Head_get'))

# Start of coin__UxOut_Body_set

`coin__UxOut_Body_set` = function(self, s_Body)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Body, "ExternalReference")) s_Body = slot(s_Body,"ref") 
  ;.Call('R_swig_coin__UxOut_Body_set', self, s_Body, PACKAGE='skycoin');
  
}

attr(`coin__UxOut_Body_set`, 'returnType') = 'void'
attr(`coin__UxOut_Body_set`, "inputTypes") = c('_p_coin__UxOut', '_p_coin__UxBody')
class(`coin__UxOut_Body_set`) = c("SWIGFunction", class('coin__UxOut_Body_set'))

# Start of coin__UxOut_Body_get

`coin__UxOut_Body_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_coin__UxOut_Body_get', self, PACKAGE='skycoin');
  ans <- new("_p_coin__UxBody", ref=ans) ;
  
  ans
  
}

attr(`coin__UxOut_Body_get`, 'returnType') = '_p_coin__UxBody'
attr(`coin__UxOut_Body_get`, "inputTypes") = c('_p_coin__UxOut')
class(`coin__UxOut_Body_get`) = c("SWIGFunction", class('coin__UxOut_Body_get'))

# Start of new_coin__UxOut

`coin__UxOut` = function()
{
  ;ans = .Call('R_swig_new_coin__UxOut', PACKAGE='skycoin');
  ans <- new("_p_coin__UxOut", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_coin__UxOut)
  ans
  
}

attr(`coin__UxOut`, 'returnType') = '_p_coin__UxOut'
class(`coin__UxOut`) = c("SWIGFunction", class('coin__UxOut'))

# Start of delete_coin__UxOut

`delete_coin__UxOut` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_coin__UxOut', self, PACKAGE='skycoin');
  
}

attr(`delete_coin__UxOut`, 'returnType') = 'void'
attr(`delete_coin__UxOut`, "inputTypes") = c('_p_coin__UxOut')
class(`delete_coin__UxOut`) = c("SWIGFunction", class('delete_coin__UxOut'))

# Start of accessor method for coin__UxOut
setMethod('$', '_p_coin__UxOut', function(x, name)

{
  accessorFuns = list('isEqual' = coin__UxOut_isEqual, 'Head' = coin__UxOut_Head_get, 'Body' = coin__UxOut_Body_get);
  vaccessors = c('Head', 'Body');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for coin__UxOut
# Start of accessor method for coin__UxOut
setMethod('$<-', '_p_coin__UxOut', function(x, name, value)

{
  accessorFuns = list('Head' = coin__UxOut_Head_set, 'Body' = coin__UxOut_Body_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_coin__UxOut', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Head' = coin__UxOut_Head_set, 'Body' = coin__UxOut_Body_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for coin__UxOut
setMethod('delete', '_p_coin__UxOut', function(obj) {delete_coin__UxOut(obj)})
# Start definition of copy functions & methods for coin__UxOut
CopyToR_coin__UxOut = function(value, obj = new("coin__UxOut"))
{
  obj;
}



CopyToC_coin__UxOut = function(value, obj)
{
  obj
}



# Start definition of copy methods for coin__UxOut
setMethod('copyToR', '_p_coin__UxOut', CopyToR_coin__UxOut);
setMethod('copyToC', 'coin__UxOut', CopyToC_coin__UxOut);

# End definition of copy methods for coin__UxOut
# End definition of copy functions & methods for coin__UxOut
# Start of httphelper__Address__unnamed_set

`httphelper__Address__unnamed_set` = function(self, s_unnamed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_unnamed, "ExternalReference")) s_unnamed = slot(s_unnamed,"ref") 
  ;.Call('R_swig_httphelper__Address__unnamed_set', self, s_unnamed, PACKAGE='skycoin');
  
}

attr(`httphelper__Address__unnamed_set`, 'returnType') = 'void'
attr(`httphelper__Address__unnamed_set`, "inputTypes") = c('_p_httphelper__Address', '_p_cipher__Address')
class(`httphelper__Address__unnamed_set`) = c("SWIGFunction", class('httphelper__Address__unnamed_set'))

# Start of httphelper__Address__unnamed_get

`httphelper__Address__unnamed_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_httphelper__Address__unnamed_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  ans
  
}

attr(`httphelper__Address__unnamed_get`, 'returnType') = '_p_cipher__Address'
attr(`httphelper__Address__unnamed_get`, "inputTypes") = c('_p_httphelper__Address')
class(`httphelper__Address__unnamed_get`) = c("SWIGFunction", class('httphelper__Address__unnamed_get'))

# Start of new_httphelper__Address

`httphelper__Address` = function()
{
  ;ans = .Call('R_swig_new_httphelper__Address', PACKAGE='skycoin');
  ans <- new("_p_httphelper__Address", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_httphelper__Address)
  ans
  
}

attr(`httphelper__Address`, 'returnType') = '_p_httphelper__Address'
class(`httphelper__Address`) = c("SWIGFunction", class('httphelper__Address'))

# Start of delete_httphelper__Address

`delete_httphelper__Address` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_httphelper__Address', self, PACKAGE='skycoin');
  
}

attr(`delete_httphelper__Address`, 'returnType') = 'void'
attr(`delete_httphelper__Address`, "inputTypes") = c('_p_httphelper__Address')
class(`delete_httphelper__Address`) = c("SWIGFunction", class('delete_httphelper__Address'))

# Start of accessor method for httphelper__Address
setMethod('$', '_p_httphelper__Address', function(x, name)

{
  accessorFuns = list('_unnamed' = httphelper__Address__unnamed_get);
  vaccessors = c('_unnamed');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for httphelper__Address
# Start of accessor method for httphelper__Address
setMethod('$<-', '_p_httphelper__Address', function(x, name, value)

{
  accessorFuns = list('_unnamed' = httphelper__Address__unnamed_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_httphelper__Address', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('_unnamed' = httphelper__Address__unnamed_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for httphelper__Address
setMethod('delete', '_p_httphelper__Address', function(obj) {delete_httphelper__Address(obj)})
# Start definition of copy functions & methods for httphelper__Address
CopyToR_httphelper__Address = function(value, obj = new("httphelper__Address"))
{
  obj;
}



CopyToC_httphelper__Address = function(value, obj)
{
  obj
}



# Start definition of copy methods for httphelper__Address
setMethod('copyToR', '_p_httphelper__Address', CopyToR_httphelper__Address);
setMethod('copyToC', 'httphelper__Address', CopyToC_httphelper__Address);

# End definition of copy methods for httphelper__Address
# End definition of copy functions & methods for httphelper__Address
# Start of httphelper__SHA256__unnamed_set

`httphelper__SHA256__unnamed_set` = function(self, s_unnamed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_unnamed))
  assert(all(sapply(s_unnamed, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_unnamed) >= 32)
  
  ;.Call('R_swig_httphelper__SHA256__unnamed_set', self, s_unnamed, PACKAGE='skycoin');
  
}

attr(`httphelper__SHA256__unnamed_set`, 'returnType') = 'void'
attr(`httphelper__SHA256__unnamed_set`, "inputTypes") = c('_p_httphelper__SHA256', '_p_GoUint8_')
class(`httphelper__SHA256__unnamed_set`) = c("SWIGFunction", class('httphelper__SHA256__unnamed_set'))

# Start of httphelper__SHA256__unnamed_get

`httphelper__SHA256__unnamed_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_httphelper__SHA256__unnamed_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`httphelper__SHA256__unnamed_get`, 'returnType') = '_p_GoUint8_'
attr(`httphelper__SHA256__unnamed_get`, "inputTypes") = c('_p_httphelper__SHA256')
class(`httphelper__SHA256__unnamed_get`) = c("SWIGFunction", class('httphelper__SHA256__unnamed_get'))

# Start of new_httphelper__SHA256

`httphelper__SHA256` = function()
{
  ;ans = .Call('R_swig_new_httphelper__SHA256', PACKAGE='skycoin');
  ans <- new("_p_httphelper__SHA256", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_httphelper__SHA256)
  ans
  
}

attr(`httphelper__SHA256`, 'returnType') = '_p_httphelper__SHA256'
class(`httphelper__SHA256`) = c("SWIGFunction", class('httphelper__SHA256'))

# Start of delete_httphelper__SHA256

`delete_httphelper__SHA256` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_httphelper__SHA256', self, PACKAGE='skycoin');
  
}

attr(`delete_httphelper__SHA256`, 'returnType') = 'void'
attr(`delete_httphelper__SHA256`, "inputTypes") = c('_p_httphelper__SHA256')
class(`delete_httphelper__SHA256`) = c("SWIGFunction", class('delete_httphelper__SHA256'))

# Start of accessor method for httphelper__SHA256
setMethod('$', '_p_httphelper__SHA256', function(x, name)

{
  accessorFuns = list('_unnamed' = httphelper__SHA256__unnamed_get);
  vaccessors = c('_unnamed');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for httphelper__SHA256
# Start of accessor method for httphelper__SHA256
setMethod('$<-', '_p_httphelper__SHA256', function(x, name, value)

{
  accessorFuns = list('_unnamed' = httphelper__SHA256__unnamed_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_httphelper__SHA256', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('_unnamed' = httphelper__SHA256__unnamed_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for httphelper__SHA256
setMethod('delete', '_p_httphelper__SHA256', function(obj) {delete_httphelper__SHA256(obj)})
# Start definition of copy functions & methods for httphelper__SHA256
CopyToR_httphelper__SHA256 = function(value, obj = new("httphelper__SHA256"))
{
  obj;
}



CopyToC_httphelper__SHA256 = function(value, obj)
{
  obj
}



# Start definition of copy methods for httphelper__SHA256
setMethod('copyToR', '_p_httphelper__SHA256', CopyToR_httphelper__SHA256);
setMethod('copyToC', 'httphelper__SHA256', CopyToC_httphelper__SHA256);

# End definition of copy methods for httphelper__SHA256
# End definition of copy functions & methods for httphelper__SHA256
# Start of wallet__Balance_Coins_set

`wallet__Balance_Coins_set` = function(self, s_Coins)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Coins = as.integer(s_Coins);
  
  if(length(s_Coins) > 1) {
    warning("using only the first element of s_Coins");
  };
  
  ;.Call('R_swig_wallet__Balance_Coins_set', self, s_Coins, PACKAGE='skycoin');
  
}

attr(`wallet__Balance_Coins_set`, 'returnType') = 'void'
attr(`wallet__Balance_Coins_set`, "inputTypes") = c('_p_wallet__Balance', 'integer')
class(`wallet__Balance_Coins_set`) = c("SWIGFunction", class('wallet__Balance_Coins_set'))

# Start of wallet__Balance_Coins_get

`wallet__Balance_Coins_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_wallet__Balance_Coins_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`wallet__Balance_Coins_get`, 'returnType') = 'integer'
attr(`wallet__Balance_Coins_get`, "inputTypes") = c('_p_wallet__Balance')
class(`wallet__Balance_Coins_get`) = c("SWIGFunction", class('wallet__Balance_Coins_get'))

# Start of wallet__Balance_Hours_set

`wallet__Balance_Hours_set` = function(self, s_Hours)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Hours = as.integer(s_Hours);
  
  if(length(s_Hours) > 1) {
    warning("using only the first element of s_Hours");
  };
  
  ;.Call('R_swig_wallet__Balance_Hours_set', self, s_Hours, PACKAGE='skycoin');
  
}

attr(`wallet__Balance_Hours_set`, 'returnType') = 'void'
attr(`wallet__Balance_Hours_set`, "inputTypes") = c('_p_wallet__Balance', 'integer')
class(`wallet__Balance_Hours_set`) = c("SWIGFunction", class('wallet__Balance_Hours_set'))

# Start of wallet__Balance_Hours_get

`wallet__Balance_Hours_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_wallet__Balance_Hours_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`wallet__Balance_Hours_get`, 'returnType') = 'integer'
attr(`wallet__Balance_Hours_get`, "inputTypes") = c('_p_wallet__Balance')
class(`wallet__Balance_Hours_get`) = c("SWIGFunction", class('wallet__Balance_Hours_get'))

# Start of new_wallet__Balance

`wallet__Balance` = function()
{
  ;ans = .Call('R_swig_new_wallet__Balance', PACKAGE='skycoin');
  ans <- new("_p_wallet__Balance", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_wallet__Balance)
  ans
  
}

attr(`wallet__Balance`, 'returnType') = '_p_wallet__Balance'
class(`wallet__Balance`) = c("SWIGFunction", class('wallet__Balance'))

# Start of delete_wallet__Balance

`delete_wallet__Balance` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_wallet__Balance', self, PACKAGE='skycoin');
  
}

attr(`delete_wallet__Balance`, 'returnType') = 'void'
attr(`delete_wallet__Balance`, "inputTypes") = c('_p_wallet__Balance')
class(`delete_wallet__Balance`) = c("SWIGFunction", class('delete_wallet__Balance'))

# Start of accessor method for wallet__Balance
setMethod('$', '_p_wallet__Balance', function(x, name)

{
  accessorFuns = list('Coins' = wallet__Balance_Coins_get, 'Hours' = wallet__Balance_Hours_get);
  vaccessors = c('Coins', 'Hours');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for wallet__Balance
# Start of accessor method for wallet__Balance
setMethod('$<-', '_p_wallet__Balance', function(x, name, value)

{
  accessorFuns = list('Coins' = wallet__Balance_Coins_set, 'Hours' = wallet__Balance_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_wallet__Balance', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Coins' = wallet__Balance_Coins_set, 'Hours' = wallet__Balance_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for wallet__Balance
setMethod('delete', '_p_wallet__Balance', function(obj) {delete_wallet__Balance(obj)})
# Start definition of copy functions & methods for wallet__Balance
CopyToR_wallet__Balance = function(value, obj = new("wallet__Balance"))
{
  obj@Coins = value$Coins;
  obj@Hours = value$Hours;
  obj;
}



CopyToC_wallet__Balance = function(value, obj)
{
  obj$Coins = value@Coins;
  obj$Hours = value@Hours;
  obj
}



# Start definition of copy methods for wallet__Balance
setMethod('copyToR', '_p_wallet__Balance', CopyToR_wallet__Balance);
setMethod('copyToC', 'wallet__Balance', CopyToC_wallet__Balance);

# End definition of copy methods for wallet__Balance
# End definition of copy functions & methods for wallet__Balance
# Start of wallet__BalancePair_Confirmed_set

`wallet__BalancePair_Confirmed_set` = function(self, s_Confirmed)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Confirmed, "ExternalReference")) s_Confirmed = slot(s_Confirmed,"ref") 
  ;.Call('R_swig_wallet__BalancePair_Confirmed_set', self, s_Confirmed, PACKAGE='skycoin');
  
}

attr(`wallet__BalancePair_Confirmed_set`, 'returnType') = 'void'
attr(`wallet__BalancePair_Confirmed_set`, "inputTypes") = c('_p_wallet__BalancePair', '_p_wallet__Balance')
class(`wallet__BalancePair_Confirmed_set`) = c("SWIGFunction", class('wallet__BalancePair_Confirmed_set'))

# Start of wallet__BalancePair_Confirmed_get

`wallet__BalancePair_Confirmed_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__BalancePair_Confirmed_get', self, PACKAGE='skycoin');
  ans <- new("_p_wallet__Balance", ref=ans) ;
  
  ans
  
}

attr(`wallet__BalancePair_Confirmed_get`, 'returnType') = '_p_wallet__Balance'
attr(`wallet__BalancePair_Confirmed_get`, "inputTypes") = c('_p_wallet__BalancePair')
class(`wallet__BalancePair_Confirmed_get`) = c("SWIGFunction", class('wallet__BalancePair_Confirmed_get'))

# Start of wallet__BalancePair_Predicted_set

`wallet__BalancePair_Predicted_set` = function(self, s_Predicted)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Predicted, "ExternalReference")) s_Predicted = slot(s_Predicted,"ref") 
  ;.Call('R_swig_wallet__BalancePair_Predicted_set', self, s_Predicted, PACKAGE='skycoin');
  
}

attr(`wallet__BalancePair_Predicted_set`, 'returnType') = 'void'
attr(`wallet__BalancePair_Predicted_set`, "inputTypes") = c('_p_wallet__BalancePair', '_p_wallet__Balance')
class(`wallet__BalancePair_Predicted_set`) = c("SWIGFunction", class('wallet__BalancePair_Predicted_set'))

# Start of wallet__BalancePair_Predicted_get

`wallet__BalancePair_Predicted_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__BalancePair_Predicted_get', self, PACKAGE='skycoin');
  ans <- new("_p_wallet__Balance", ref=ans) ;
  
  ans
  
}

attr(`wallet__BalancePair_Predicted_get`, 'returnType') = '_p_wallet__Balance'
attr(`wallet__BalancePair_Predicted_get`, "inputTypes") = c('_p_wallet__BalancePair')
class(`wallet__BalancePair_Predicted_get`) = c("SWIGFunction", class('wallet__BalancePair_Predicted_get'))

# Start of new_wallet__BalancePair

`wallet__BalancePair` = function()
{
  ;ans = .Call('R_swig_new_wallet__BalancePair', PACKAGE='skycoin');
  ans <- new("_p_wallet__BalancePair", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_wallet__BalancePair)
  ans
  
}

attr(`wallet__BalancePair`, 'returnType') = '_p_wallet__BalancePair'
class(`wallet__BalancePair`) = c("SWIGFunction", class('wallet__BalancePair'))

# Start of delete_wallet__BalancePair

`delete_wallet__BalancePair` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_wallet__BalancePair', self, PACKAGE='skycoin');
  
}

attr(`delete_wallet__BalancePair`, 'returnType') = 'void'
attr(`delete_wallet__BalancePair`, "inputTypes") = c('_p_wallet__BalancePair')
class(`delete_wallet__BalancePair`) = c("SWIGFunction", class('delete_wallet__BalancePair'))

# Start of accessor method for wallet__BalancePair
setMethod('$', '_p_wallet__BalancePair', function(x, name)

{
  accessorFuns = list('Confirmed' = wallet__BalancePair_Confirmed_get, 'Predicted' = wallet__BalancePair_Predicted_get);
  vaccessors = c('Confirmed', 'Predicted');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for wallet__BalancePair
# Start of accessor method for wallet__BalancePair
setMethod('$<-', '_p_wallet__BalancePair', function(x, name, value)

{
  accessorFuns = list('Confirmed' = wallet__BalancePair_Confirmed_set, 'Predicted' = wallet__BalancePair_Predicted_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_wallet__BalancePair', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Confirmed' = wallet__BalancePair_Confirmed_set, 'Predicted' = wallet__BalancePair_Predicted_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for wallet__BalancePair
setMethod('delete', '_p_wallet__BalancePair', function(obj) {delete_wallet__BalancePair(obj)})
# Start definition of copy functions & methods for wallet__BalancePair
CopyToR_wallet__BalancePair = function(value, obj = new("wallet__BalancePair"))
{
  obj;
}



CopyToC_wallet__BalancePair = function(value, obj)
{
  obj
}



# Start definition of copy methods for wallet__BalancePair
setMethod('copyToR', '_p_wallet__BalancePair', CopyToR_wallet__BalancePair);
setMethod('copyToC', 'wallet__BalancePair', CopyToC_wallet__BalancePair);

# End definition of copy methods for wallet__BalancePair
# End definition of copy functions & methods for wallet__BalancePair
# Start of wallet__Entry_Address_set

`wallet__Entry_Address_set` = function(self, s_Address)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Address, "ExternalReference")) s_Address = slot(s_Address,"ref") 
  ;.Call('R_swig_wallet__Entry_Address_set', self, s_Address, PACKAGE='skycoin');
  
}

attr(`wallet__Entry_Address_set`, 'returnType') = 'void'
attr(`wallet__Entry_Address_set`, "inputTypes") = c('_p_wallet__Entry', '_p_cipher__Address')
class(`wallet__Entry_Address_set`) = c("SWIGFunction", class('wallet__Entry_Address_set'))

# Start of wallet__Entry_Address_get

`wallet__Entry_Address_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__Entry_Address_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  ans
  
}

attr(`wallet__Entry_Address_get`, 'returnType') = '_p_cipher__Address'
attr(`wallet__Entry_Address_get`, "inputTypes") = c('_p_wallet__Entry')
class(`wallet__Entry_Address_get`) = c("SWIGFunction", class('wallet__Entry_Address_get'))

# Start of wallet__Entry_Public_set

`wallet__Entry_Public_set` = function(self, s_Public)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_Public))
  assert(all(sapply(s_Public, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_Public) >= 33)
  
  ;.Call('R_swig_wallet__Entry_Public_set', self, s_Public, PACKAGE='skycoin');
  
}

attr(`wallet__Entry_Public_set`, 'returnType') = 'void'
attr(`wallet__Entry_Public_set`, "inputTypes") = c('_p_wallet__Entry', '_p_GoUint8_')
class(`wallet__Entry_Public_set`) = c("SWIGFunction", class('wallet__Entry_Public_set'))

# Start of wallet__Entry_Public_get

`wallet__Entry_Public_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__Entry_Public_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`wallet__Entry_Public_get`, 'returnType') = '_p_GoUint8_'
attr(`wallet__Entry_Public_get`, "inputTypes") = c('_p_wallet__Entry')
class(`wallet__Entry_Public_get`) = c("SWIGFunction", class('wallet__Entry_Public_get'))

# Start of wallet__Entry_Secret_set

`wallet__Entry_Secret_set` = function(self, s_Secret)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_Secret))
  assert(all(sapply(s_Secret, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_Secret) >= 32)
  
  ;.Call('R_swig_wallet__Entry_Secret_set', self, s_Secret, PACKAGE='skycoin');
  
}

attr(`wallet__Entry_Secret_set`, 'returnType') = 'void'
attr(`wallet__Entry_Secret_set`, "inputTypes") = c('_p_wallet__Entry', '_p_GoUint8_')
class(`wallet__Entry_Secret_set`) = c("SWIGFunction", class('wallet__Entry_Secret_set'))

# Start of wallet__Entry_Secret_get

`wallet__Entry_Secret_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__Entry_Secret_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`wallet__Entry_Secret_get`, 'returnType') = '_p_GoUint8_'
attr(`wallet__Entry_Secret_get`, "inputTypes") = c('_p_wallet__Entry')
class(`wallet__Entry_Secret_get`) = c("SWIGFunction", class('wallet__Entry_Secret_get'))

# Start of new_wallet__Entry

`wallet__Entry` = function()
{
  ;ans = .Call('R_swig_new_wallet__Entry', PACKAGE='skycoin');
  ans <- new("_p_wallet__Entry", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_wallet__Entry)
  ans
  
}

attr(`wallet__Entry`, 'returnType') = '_p_wallet__Entry'
class(`wallet__Entry`) = c("SWIGFunction", class('wallet__Entry'))

# Start of delete_wallet__Entry

`delete_wallet__Entry` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_wallet__Entry', self, PACKAGE='skycoin');
  
}

attr(`delete_wallet__Entry`, 'returnType') = 'void'
attr(`delete_wallet__Entry`, "inputTypes") = c('_p_wallet__Entry')
class(`delete_wallet__Entry`) = c("SWIGFunction", class('delete_wallet__Entry'))

# Start of accessor method for wallet__Entry
setMethod('$', '_p_wallet__Entry', function(x, name)

{
  accessorFuns = list('Address' = wallet__Entry_Address_get, 'Public' = wallet__Entry_Public_get, 'Secret' = wallet__Entry_Secret_get);
  vaccessors = c('Address', 'Public', 'Secret');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for wallet__Entry
# Start of accessor method for wallet__Entry
setMethod('$<-', '_p_wallet__Entry', function(x, name, value)

{
  accessorFuns = list('Address' = wallet__Entry_Address_set, 'Public' = wallet__Entry_Public_set, 'Secret' = wallet__Entry_Secret_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_wallet__Entry', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Address' = wallet__Entry_Address_set, 'Public' = wallet__Entry_Public_set, 'Secret' = wallet__Entry_Secret_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for wallet__Entry
setMethod('delete', '_p_wallet__Entry', function(obj) {delete_wallet__Entry(obj)})
# Start definition of copy functions & methods for wallet__Entry
CopyToR_wallet__Entry = function(value, obj = new("wallet__Entry"))
{
  obj;
}



CopyToC_wallet__Entry = function(value, obj)
{
  obj
}



# Start definition of copy methods for wallet__Entry
setMethod('copyToR', '_p_wallet__Entry', CopyToR_wallet__Entry);
setMethod('copyToC', 'wallet__Entry', CopyToC_wallet__Entry);

# End definition of copy methods for wallet__Entry
# End definition of copy functions & methods for wallet__Entry
# Start of wallet__Note_TxID_set

`wallet__Note_TxID_set` = function(self, s_TxID)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_TxID, "ExternalReference")) s_TxID = slot(s_TxID,"ref") 
  ;.Call('R_swig_wallet__Note_TxID_set', self, s_TxID, PACKAGE='skycoin');
  
}

attr(`wallet__Note_TxID_set`, 'returnType') = 'void'
attr(`wallet__Note_TxID_set`, "inputTypes") = c('_p_wallet__Note', '_p_GoString_')
class(`wallet__Note_TxID_set`) = c("SWIGFunction", class('wallet__Note_TxID_set'))

# Start of wallet__Note_TxID_get

`wallet__Note_TxID_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__Note_TxID_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoString_", ref=ans);
  
  ans
  
}

attr(`wallet__Note_TxID_get`, 'returnType') = '_p_GoString_'
attr(`wallet__Note_TxID_get`, "inputTypes") = c('_p_wallet__Note')
class(`wallet__Note_TxID_get`) = c("SWIGFunction", class('wallet__Note_TxID_get'))

# Start of wallet__Note_Value_set

`wallet__Note_Value_set` = function(self, s_Value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Value, "ExternalReference")) s_Value = slot(s_Value,"ref") 
  ;.Call('R_swig_wallet__Note_Value_set', self, s_Value, PACKAGE='skycoin');
  
}

attr(`wallet__Note_Value_set`, 'returnType') = 'void'
attr(`wallet__Note_Value_set`, "inputTypes") = c('_p_wallet__Note', '_p_GoString_')
class(`wallet__Note_Value_set`) = c("SWIGFunction", class('wallet__Note_Value_set'))

# Start of wallet__Note_Value_get

`wallet__Note_Value_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__Note_Value_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoString_", ref=ans);
  
  ans
  
}

attr(`wallet__Note_Value_get`, 'returnType') = '_p_GoString_'
attr(`wallet__Note_Value_get`, "inputTypes") = c('_p_wallet__Note')
class(`wallet__Note_Value_get`) = c("SWIGFunction", class('wallet__Note_Value_get'))

# Start of new_wallet__Note

`wallet__Note` = function()
{
  ;ans = .Call('R_swig_new_wallet__Note', PACKAGE='skycoin');
  ans <- new("_p_wallet__Note", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_wallet__Note)
  ans
  
}

attr(`wallet__Note`, 'returnType') = '_p_wallet__Note'
class(`wallet__Note`) = c("SWIGFunction", class('wallet__Note'))

# Start of delete_wallet__Note

`delete_wallet__Note` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_wallet__Note', self, PACKAGE='skycoin');
  
}

attr(`delete_wallet__Note`, 'returnType') = 'void'
attr(`delete_wallet__Note`, "inputTypes") = c('_p_wallet__Note')
class(`delete_wallet__Note`) = c("SWIGFunction", class('delete_wallet__Note'))

# Start of accessor method for wallet__Note
setMethod('$', '_p_wallet__Note', function(x, name)

{
  accessorFuns = list('TxID' = wallet__Note_TxID_get, 'Value' = wallet__Note_Value_get);
  vaccessors = c('TxID', 'Value');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for wallet__Note
# Start of accessor method for wallet__Note
setMethod('$<-', '_p_wallet__Note', function(x, name, value)

{
  accessorFuns = list('TxID' = wallet__Note_TxID_set, 'Value' = wallet__Note_Value_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_wallet__Note', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('TxID' = wallet__Note_TxID_set, 'Value' = wallet__Note_Value_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for wallet__Note
setMethod('delete', '_p_wallet__Note', function(obj) {delete_wallet__Note(obj)})
# Start definition of copy functions & methods for wallet__Note
CopyToR_wallet__Note = function(value, obj = new("wallet__Note"))
{
  obj;
}



CopyToC_wallet__Note = function(value, obj)
{
  obj
}



# Start definition of copy methods for wallet__Note
setMethod('copyToR', '_p_wallet__Note', CopyToR_wallet__Note);
setMethod('copyToC', 'wallet__Note', CopyToC_wallet__Note);

# End definition of copy methods for wallet__Note
# End definition of copy functions & methods for wallet__Note
# Start of wallet__ReadableNote_TransactionID_set

`wallet__ReadableNote_TransactionID_set` = function(self, s_TransactionID)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_TransactionID, "ExternalReference")) s_TransactionID = slot(s_TransactionID,"ref") 
  ;.Call('R_swig_wallet__ReadableNote_TransactionID_set', self, s_TransactionID, PACKAGE='skycoin');
  
}

attr(`wallet__ReadableNote_TransactionID_set`, 'returnType') = 'void'
attr(`wallet__ReadableNote_TransactionID_set`, "inputTypes") = c('_p_wallet__ReadableNote', '_p_GoString_')
class(`wallet__ReadableNote_TransactionID_set`) = c("SWIGFunction", class('wallet__ReadableNote_TransactionID_set'))

# Start of wallet__ReadableNote_TransactionID_get

`wallet__ReadableNote_TransactionID_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__ReadableNote_TransactionID_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoString_", ref=ans);
  
  ans
  
}

attr(`wallet__ReadableNote_TransactionID_get`, 'returnType') = '_p_GoString_'
attr(`wallet__ReadableNote_TransactionID_get`, "inputTypes") = c('_p_wallet__ReadableNote')
class(`wallet__ReadableNote_TransactionID_get`) = c("SWIGFunction", class('wallet__ReadableNote_TransactionID_get'))

# Start of wallet__ReadableNote_ActualNote_set

`wallet__ReadableNote_ActualNote_set` = function(self, s_ActualNote)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_ActualNote, "ExternalReference")) s_ActualNote = slot(s_ActualNote,"ref") 
  ;.Call('R_swig_wallet__ReadableNote_ActualNote_set', self, s_ActualNote, PACKAGE='skycoin');
  
}

attr(`wallet__ReadableNote_ActualNote_set`, 'returnType') = 'void'
attr(`wallet__ReadableNote_ActualNote_set`, "inputTypes") = c('_p_wallet__ReadableNote', '_p_GoString_')
class(`wallet__ReadableNote_ActualNote_set`) = c("SWIGFunction", class('wallet__ReadableNote_ActualNote_set'))

# Start of wallet__ReadableNote_ActualNote_get

`wallet__ReadableNote_ActualNote_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__ReadableNote_ActualNote_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoString_", ref=ans);
  
  ans
  
}

attr(`wallet__ReadableNote_ActualNote_get`, 'returnType') = '_p_GoString_'
attr(`wallet__ReadableNote_ActualNote_get`, "inputTypes") = c('_p_wallet__ReadableNote')
class(`wallet__ReadableNote_ActualNote_get`) = c("SWIGFunction", class('wallet__ReadableNote_ActualNote_get'))

# Start of new_wallet__ReadableNote

`wallet__ReadableNote` = function()
{
  ;ans = .Call('R_swig_new_wallet__ReadableNote', PACKAGE='skycoin');
  ans <- new("_p_wallet__ReadableNote", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_wallet__ReadableNote)
  ans
  
}

attr(`wallet__ReadableNote`, 'returnType') = '_p_wallet__ReadableNote'
class(`wallet__ReadableNote`) = c("SWIGFunction", class('wallet__ReadableNote'))

# Start of delete_wallet__ReadableNote

`delete_wallet__ReadableNote` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_wallet__ReadableNote', self, PACKAGE='skycoin');
  
}

attr(`delete_wallet__ReadableNote`, 'returnType') = 'void'
attr(`delete_wallet__ReadableNote`, "inputTypes") = c('_p_wallet__ReadableNote')
class(`delete_wallet__ReadableNote`) = c("SWIGFunction", class('delete_wallet__ReadableNote'))

# Start of accessor method for wallet__ReadableNote
setMethod('$', '_p_wallet__ReadableNote', function(x, name)

{
  accessorFuns = list('TransactionID' = wallet__ReadableNote_TransactionID_get, 'ActualNote' = wallet__ReadableNote_ActualNote_get);
  vaccessors = c('TransactionID', 'ActualNote');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for wallet__ReadableNote
# Start of accessor method for wallet__ReadableNote
setMethod('$<-', '_p_wallet__ReadableNote', function(x, name, value)

{
  accessorFuns = list('TransactionID' = wallet__ReadableNote_TransactionID_set, 'ActualNote' = wallet__ReadableNote_ActualNote_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_wallet__ReadableNote', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('TransactionID' = wallet__ReadableNote_TransactionID_set, 'ActualNote' = wallet__ReadableNote_ActualNote_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for wallet__ReadableNote
setMethod('delete', '_p_wallet__ReadableNote', function(obj) {delete_wallet__ReadableNote(obj)})
# Start definition of copy functions & methods for wallet__ReadableNote
CopyToR_wallet__ReadableNote = function(value, obj = new("wallet__ReadableNote"))
{
  obj;
}



CopyToC_wallet__ReadableNote = function(value, obj)
{
  obj
}



# Start definition of copy methods for wallet__ReadableNote
setMethod('copyToR', '_p_wallet__ReadableNote', CopyToR_wallet__ReadableNote);
setMethod('copyToC', 'wallet__ReadableNote', CopyToC_wallet__ReadableNote);

# End definition of copy methods for wallet__ReadableNote
# End definition of copy functions & methods for wallet__ReadableNote
# Start of wallet__UxBalance_Hash_set

`wallet__UxBalance_Hash_set` = function(self, s_Hash)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  if(is.list(s_Hash))
  assert(all(sapply(s_Hash, class) == "_p_GoUint8_"));
  
  
#  assert(length(s_Hash) >= 32)
  
  ;.Call('R_swig_wallet__UxBalance_Hash_set', self, s_Hash, PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_Hash_set`, 'returnType') = 'void'
attr(`wallet__UxBalance_Hash_set`, "inputTypes") = c('_p_wallet__UxBalance', '_p_GoUint8_')
class(`wallet__UxBalance_Hash_set`) = c("SWIGFunction", class('wallet__UxBalance_Hash_set'))

# Start of wallet__UxBalance_Hash_get

`wallet__UxBalance_Hash_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__UxBalance_Hash_get', self, as.logical(.copy), PACKAGE='skycoin');
  ans <- new("_p_GoUint8_", ref=ans) ;
  
  ans
  
}

attr(`wallet__UxBalance_Hash_get`, 'returnType') = '_p_GoUint8_'
attr(`wallet__UxBalance_Hash_get`, "inputTypes") = c('_p_wallet__UxBalance')
class(`wallet__UxBalance_Hash_get`) = c("SWIGFunction", class('wallet__UxBalance_Hash_get'))

# Start of wallet__UxBalance_BkSeq_set

`wallet__UxBalance_BkSeq_set` = function(self, s_BkSeq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_BkSeq = as.integer(s_BkSeq);
  
  if(length(s_BkSeq) > 1) {
    warning("using only the first element of s_BkSeq");
  };
  
  ;.Call('R_swig_wallet__UxBalance_BkSeq_set', self, s_BkSeq, PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_BkSeq_set`, 'returnType') = 'void'
attr(`wallet__UxBalance_BkSeq_set`, "inputTypes") = c('_p_wallet__UxBalance', 'integer')
class(`wallet__UxBalance_BkSeq_set`) = c("SWIGFunction", class('wallet__UxBalance_BkSeq_set'))

# Start of wallet__UxBalance_BkSeq_get

`wallet__UxBalance_BkSeq_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_wallet__UxBalance_BkSeq_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_BkSeq_get`, 'returnType') = 'integer'
attr(`wallet__UxBalance_BkSeq_get`, "inputTypes") = c('_p_wallet__UxBalance')
class(`wallet__UxBalance_BkSeq_get`) = c("SWIGFunction", class('wallet__UxBalance_BkSeq_get'))

# Start of wallet__UxBalance_Address_set

`wallet__UxBalance_Address_set` = function(self, s_Address)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Address, "ExternalReference")) s_Address = slot(s_Address,"ref") 
  ;.Call('R_swig_wallet__UxBalance_Address_set', self, s_Address, PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_Address_set`, 'returnType') = 'void'
attr(`wallet__UxBalance_Address_set`, "inputTypes") = c('_p_wallet__UxBalance', '_p_cipher__Address')
class(`wallet__UxBalance_Address_set`) = c("SWIGFunction", class('wallet__UxBalance_Address_set'))

# Start of wallet__UxBalance_Address_get

`wallet__UxBalance_Address_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_wallet__UxBalance_Address_get', self, PACKAGE='skycoin');
  ans <- new("_p_cipher__Address", ref=ans) ;
  
  ans
  
}

attr(`wallet__UxBalance_Address_get`, 'returnType') = '_p_cipher__Address'
attr(`wallet__UxBalance_Address_get`, "inputTypes") = c('_p_wallet__UxBalance')
class(`wallet__UxBalance_Address_get`) = c("SWIGFunction", class('wallet__UxBalance_Address_get'))

# Start of wallet__UxBalance_Coins_set

`wallet__UxBalance_Coins_set` = function(self, s_Coins)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Coins = as.integer(s_Coins);
  
  if(length(s_Coins) > 1) {
    warning("using only the first element of s_Coins");
  };
  
  ;.Call('R_swig_wallet__UxBalance_Coins_set', self, s_Coins, PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_Coins_set`, 'returnType') = 'void'
attr(`wallet__UxBalance_Coins_set`, "inputTypes") = c('_p_wallet__UxBalance', 'integer')
class(`wallet__UxBalance_Coins_set`) = c("SWIGFunction", class('wallet__UxBalance_Coins_set'))

# Start of wallet__UxBalance_Coins_get

`wallet__UxBalance_Coins_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_wallet__UxBalance_Coins_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_Coins_get`, 'returnType') = 'integer'
attr(`wallet__UxBalance_Coins_get`, "inputTypes") = c('_p_wallet__UxBalance')
class(`wallet__UxBalance_Coins_get`) = c("SWIGFunction", class('wallet__UxBalance_Coins_get'))

# Start of wallet__UxBalance_Hours_set

`wallet__UxBalance_Hours_set` = function(self, s_Hours)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_Hours = as.integer(s_Hours);
  
  if(length(s_Hours) > 1) {
    warning("using only the first element of s_Hours");
  };
  
  ;.Call('R_swig_wallet__UxBalance_Hours_set', self, s_Hours, PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_Hours_set`, 'returnType') = 'void'
attr(`wallet__UxBalance_Hours_set`, "inputTypes") = c('_p_wallet__UxBalance', 'integer')
class(`wallet__UxBalance_Hours_set`) = c("SWIGFunction", class('wallet__UxBalance_Hours_set'))

# Start of wallet__UxBalance_Hours_get

`wallet__UxBalance_Hours_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_wallet__UxBalance_Hours_get', self, as.logical(.copy), PACKAGE='skycoin');
  
}

attr(`wallet__UxBalance_Hours_get`, 'returnType') = 'integer'
attr(`wallet__UxBalance_Hours_get`, "inputTypes") = c('_p_wallet__UxBalance')
class(`wallet__UxBalance_Hours_get`) = c("SWIGFunction", class('wallet__UxBalance_Hours_get'))

# Start of new_wallet__UxBalance

`wallet__UxBalance` = function()
{
  ;ans = .Call('R_swig_new_wallet__UxBalance', PACKAGE='skycoin');
  ans <- new("_p_wallet__UxBalance", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_wallet__UxBalance)
  ans
  
}

attr(`wallet__UxBalance`, 'returnType') = '_p_wallet__UxBalance'
class(`wallet__UxBalance`) = c("SWIGFunction", class('wallet__UxBalance'))

# Start of delete_wallet__UxBalance

`delete_wallet__UxBalance` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_wallet__UxBalance', self, PACKAGE='skycoin');
  
}

attr(`delete_wallet__UxBalance`, 'returnType') = 'void'
attr(`delete_wallet__UxBalance`, "inputTypes") = c('_p_wallet__UxBalance')
class(`delete_wallet__UxBalance`) = c("SWIGFunction", class('delete_wallet__UxBalance'))

# Start of accessor method for wallet__UxBalance
setMethod('$', '_p_wallet__UxBalance', function(x, name)

{
  accessorFuns = list('Hash' = wallet__UxBalance_Hash_get, 'BkSeq' = wallet__UxBalance_BkSeq_get, 'Address' = wallet__UxBalance_Address_get, 'Coins' = wallet__UxBalance_Coins_get, 'Hours' = wallet__UxBalance_Hours_get);
  vaccessors = c('Hash', 'BkSeq', 'Address', 'Coins', 'Hours');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for wallet__UxBalance
# Start of accessor method for wallet__UxBalance
setMethod('$<-', '_p_wallet__UxBalance', function(x, name, value)

{
  accessorFuns = list('Hash' = wallet__UxBalance_Hash_set, 'BkSeq' = wallet__UxBalance_BkSeq_set, 'Address' = wallet__UxBalance_Address_set, 'Coins' = wallet__UxBalance_Coins_set, 'Hours' = wallet__UxBalance_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_wallet__UxBalance', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('Hash' = wallet__UxBalance_Hash_set, 'BkSeq' = wallet__UxBalance_BkSeq_set, 'Address' = wallet__UxBalance_Address_set, 'Coins' = wallet__UxBalance_Coins_set, 'Hours' = wallet__UxBalance_Hours_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for wallet__UxBalance
setMethod('delete', '_p_wallet__UxBalance', function(obj) {delete_wallet__UxBalance(obj)})
# Start definition of copy functions & methods for wallet__UxBalance
CopyToR_wallet__UxBalance = function(value, obj = new("wallet__UxBalance"))
{
  obj@BkSeq = value$BkSeq;
  obj@Coins = value$Coins;
  obj@Hours = value$Hours;
  obj;
}



CopyToC_wallet__UxBalance = function(value, obj)
{
  obj$BkSeq = value@BkSeq;
  obj$Coins = value@Coins;
  obj$Hours = value@Hours;
  obj
}



# Start definition of copy methods for wallet__UxBalance
setMethod('copyToR', '_p_wallet__UxBalance', CopyToR_wallet__UxBalance);
setMethod('copyToC', 'wallet__UxBalance', CopyToC_wallet__UxBalance);

# End definition of copy methods for wallet__UxBalance
# End definition of copy functions & methods for wallet__UxBalance

